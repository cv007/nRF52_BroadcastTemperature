
_build/nrf52840_xxaa.out:     file format elf32-littlearm


Disassembly of section .text:

00027000 <__isr_vector>:
   27000:	20006000 	.word	0x20006000
   27004:	000272bd 	.word	0x000272bd
   27008:	000272e5 	.word	0x000272e5
   2700c:	000272e7 	.word	0x000272e7
   27010:	000272e9 	.word	0x000272e9
   27014:	000272eb 	.word	0x000272eb
   27018:	000272ed 	.word	0x000272ed
	...
   2702c:	000272ef 	.word	0x000272ef
   27030:	000272f1 	.word	0x000272f1
   27034:	00000000 	.word	0x00000000
   27038:	000272f3 	.word	0x000272f3
   2703c:	000272f5 	.word	0x000272f5
   27040:	00028031 	.word	0x00028031
   27044:	000272f7 	.word	0x000272f7
   27048:	0002863d 	.word	0x0002863d
   2704c:	000272f7 	.word	0x000272f7
   27050:	000272f7 	.word	0x000272f7
   27054:	000272f7 	.word	0x000272f7
   27058:	0002809d 	.word	0x0002809d
   2705c:	000272f7 	.word	0x000272f7
   27060:	000272f7 	.word	0x000272f7
   27064:	000272f7 	.word	0x000272f7
   27068:	000272f7 	.word	0x000272f7
   2706c:	000272f7 	.word	0x000272f7
   27070:	000272f7 	.word	0x000272f7
   27074:	000272f7 	.word	0x000272f7
   27078:	000272f7 	.word	0x000272f7
   2707c:	000272f7 	.word	0x000272f7
   27080:	000272f7 	.word	0x000272f7
   27084:	00027abd 	.word	0x00027abd
   27088:	000272f7 	.word	0x000272f7
   2708c:	000272f7 	.word	0x000272f7
   27090:	000272f7 	.word	0x000272f7
   27094:	000272f7 	.word	0x000272f7
   27098:	000296cd 	.word	0x000296cd
   2709c:	000272f7 	.word	0x000272f7
   270a0:	000272f7 	.word	0x000272f7
   270a4:	000272f7 	.word	0x000272f7
   270a8:	000272f7 	.word	0x000272f7
   270ac:	000272f7 	.word	0x000272f7
   270b0:	000272f7 	.word	0x000272f7
   270b4:	000272f7 	.word	0x000272f7
	...
   270c0:	000272f7 	.word	0x000272f7
   270c4:	000272f7 	.word	0x000272f7
   270c8:	000272f7 	.word	0x000272f7
   270cc:	000272f7 	.word	0x000272f7
   270d0:	000272f7 	.word	0x000272f7
   270d4:	000272f7 	.word	0x000272f7
   270d8:	000272f7 	.word	0x000272f7
   270dc:	000272f7 	.word	0x000272f7
   270e0:	000272f7 	.word	0x000272f7
   270e4:	000272f7 	.word	0x000272f7
   270e8:	000272f7 	.word	0x000272f7
	...
   270f4:	000272f7 	.word	0x000272f7
   270f8:	00000000 	.word	0x00000000
   270fc:	000272f7 	.word	0x000272f7
	...

00027200 <__do_global_dtors_aux>:
   27200:	b510      	push	{r4, lr}
   27202:	4c05      	ldr	r4, [pc, #20]	; (27218 <__do_global_dtors_aux+0x18>)
   27204:	7823      	ldrb	r3, [r4, #0]
   27206:	b933      	cbnz	r3, 27216 <__do_global_dtors_aux+0x16>
   27208:	4b04      	ldr	r3, [pc, #16]	; (2721c <__do_global_dtors_aux+0x1c>)
   2720a:	b113      	cbz	r3, 27212 <__do_global_dtors_aux+0x12>
   2720c:	4804      	ldr	r0, [pc, #16]	; (27220 <__do_global_dtors_aux+0x20>)
   2720e:	f3af 8000 	nop.w
   27212:	2301      	movs	r3, #1
   27214:	7023      	strb	r3, [r4, #0]
   27216:	bd10      	pop	{r4, pc}
   27218:	200020a8 	.word	0x200020a8
   2721c:	00000000 	.word	0x00000000
   27220:	0002bda0 	.word	0x0002bda0

00027224 <frame_dummy>:
   27224:	b508      	push	{r3, lr}
   27226:	4b03      	ldr	r3, [pc, #12]	; (27234 <frame_dummy+0x10>)
   27228:	b11b      	cbz	r3, 27232 <frame_dummy+0xe>
   2722a:	4903      	ldr	r1, [pc, #12]	; (27238 <frame_dummy+0x14>)
   2722c:	4803      	ldr	r0, [pc, #12]	; (2723c <frame_dummy+0x18>)
   2722e:	f3af 8000 	nop.w
   27232:	bd08      	pop	{r3, pc}
   27234:	00000000 	.word	0x00000000
   27238:	200020ac 	.word	0x200020ac
   2723c:	0002bda0 	.word	0x0002bda0

00027240 <_stack_init>:
   27240:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
   27244:	4770      	bx	lr
   27246:	bf00      	nop

00027248 <_mainCRTStartup>:
   27248:	4b17      	ldr	r3, [pc, #92]	; (272a8 <_mainCRTStartup+0x60>)
   2724a:	2b00      	cmp	r3, #0
   2724c:	bf08      	it	eq
   2724e:	4b13      	ldreq	r3, [pc, #76]	; (2729c <_mainCRTStartup+0x54>)
   27250:	469d      	mov	sp, r3
   27252:	f7ff fff5 	bl	27240 <_stack_init>
   27256:	2100      	movs	r1, #0
   27258:	468b      	mov	fp, r1
   2725a:	460f      	mov	r7, r1
   2725c:	4813      	ldr	r0, [pc, #76]	; (272ac <_mainCRTStartup+0x64>)
   2725e:	4a14      	ldr	r2, [pc, #80]	; (272b0 <_mainCRTStartup+0x68>)
   27260:	1a12      	subs	r2, r2, r0
   27262:	f002 fcc7 	bl	29bf4 <memset>
   27266:	4b0e      	ldr	r3, [pc, #56]	; (272a0 <_mainCRTStartup+0x58>)
   27268:	2b00      	cmp	r3, #0
   2726a:	d000      	beq.n	2726e <_mainCRTStartup+0x26>
   2726c:	4798      	blx	r3
   2726e:	4b0d      	ldr	r3, [pc, #52]	; (272a4 <_mainCRTStartup+0x5c>)
   27270:	2b00      	cmp	r3, #0
   27272:	d000      	beq.n	27276 <_mainCRTStartup+0x2e>
   27274:	4798      	blx	r3
   27276:	2000      	movs	r0, #0
   27278:	2100      	movs	r1, #0
   2727a:	0004      	movs	r4, r0
   2727c:	000d      	movs	r5, r1
   2727e:	480d      	ldr	r0, [pc, #52]	; (272b4 <_mainCRTStartup+0x6c>)
   27280:	2800      	cmp	r0, #0
   27282:	d002      	beq.n	2728a <_mainCRTStartup+0x42>
   27284:	480c      	ldr	r0, [pc, #48]	; (272b8 <_mainCRTStartup+0x70>)
   27286:	f3af 8000 	nop.w
   2728a:	f002 fc81 	bl	29b90 <__libc_init_array>
   2728e:	0020      	movs	r0, r4
   27290:	0029      	movs	r1, r5
   27292:	f002 f8e3 	bl	2945c <main>
   27296:	f002 fc67 	bl	29b68 <exit>
   2729a:	bf00      	nop
   2729c:	00080000 	.word	0x00080000
	...
   272a8:	20006000 	.word	0x20006000
   272ac:	200020a8 	.word	0x200020a8
   272b0:	20002348 	.word	0x20002348
	...

000272bc <Reset_Handler>:
 *      __bss_start__: VMA of end of the section to copy to. Normally __data_end__ is used, but by using __bss_start__
 *                    the user can add their own initialized data section before BSS section with the INTERT AFTER command.
 *
 * All addresses must be aligned to 4 bytes boundary.
 */
    ldr r1, =__etext
   272bc:	4906      	ldr	r1, [pc, #24]	; (272d8 <Reset_Handler+0x1c>)
    ldr r2, =__data_start__
   272be:	4a07      	ldr	r2, [pc, #28]	; (272dc <Reset_Handler+0x20>)
    ldr r3, =__bss_start__
   272c0:	4b07      	ldr	r3, [pc, #28]	; (272e0 <Reset_Handler+0x24>)

    subs r3, r3, r2
   272c2:	1a9b      	subs	r3, r3, r2
    ble .L_loop1_done
   272c4:	dd03      	ble.n	272ce <Reset_Handler+0x12>

.L_loop1:
    subs r3, r3, #4
   272c6:	3b04      	subs	r3, #4
    ldr r0, [r1,r3]
   272c8:	58c8      	ldr	r0, [r1, r3]
    str r0, [r2,r3]
   272ca:	50d0      	str	r0, [r2, r3]
    bgt .L_loop1
   272cc:	dcfb      	bgt.n	272c6 <Reset_Handler+0xa>

.L_loop3_done:
#endif /* __STARTUP_CLEAR_BSS */

/* Execute SystemInit function. */
    bl SystemInit
   272ce:	f000 fd19 	bl	27d04 <SystemInit>
 * If those libraries are not accessible, define __START as your entry point.
 */
#ifndef __START
#define __START _start
#endif
    bl __START
   272d2:	f7ff ffb9 	bl	27248 <_mainCRTStartup>
   272d6:	0000      	.short	0x0000
    ldr r1, =__etext
   272d8:	0002bf4c 	.word	0x0002bf4c
    ldr r2, =__data_start__
   272dc:	20002000 	.word	0x20002000
    ldr r3, =__bss_start__
   272e0:	200020a8 	.word	0x200020a8

000272e4 <NMI_Handler>:
/* Dummy Exception Handlers (infinite loops which can be modified) */

    .weak   NMI_Handler
    .type   NMI_Handler, %function
NMI_Handler:
    b       .
   272e4:	e7fe      	b.n	272e4 <NMI_Handler>

000272e6 <HardFault_Handler>:


    .weak   HardFault_Handler
    .type   HardFault_Handler, %function
HardFault_Handler:
    b       .
   272e6:	e7fe      	b.n	272e6 <HardFault_Handler>

000272e8 <MemoryManagement_Handler>:


    .weak   MemoryManagement_Handler
    .type   MemoryManagement_Handler, %function
MemoryManagement_Handler:
    b       .
   272e8:	e7fe      	b.n	272e8 <MemoryManagement_Handler>

000272ea <BusFault_Handler>:


    .weak   BusFault_Handler
    .type   BusFault_Handler, %function
BusFault_Handler:
    b       .
   272ea:	e7fe      	b.n	272ea <BusFault_Handler>

000272ec <UsageFault_Handler>:


    .weak   UsageFault_Handler
    .type   UsageFault_Handler, %function
UsageFault_Handler:
    b       .
   272ec:	e7fe      	b.n	272ec <UsageFault_Handler>

000272ee <SVC_Handler>:


    .weak   SVC_Handler
    .type   SVC_Handler, %function
SVC_Handler:
    b       .
   272ee:	e7fe      	b.n	272ee <SVC_Handler>

000272f0 <DebugMon_Handler>:


    .weak   DebugMon_Handler
    .type   DebugMon_Handler, %function
DebugMon_Handler:
    b       .
   272f0:	e7fe      	b.n	272f0 <DebugMon_Handler>

000272f2 <PendSV_Handler>:


    .weak   PendSV_Handler
    .type   PendSV_Handler, %function
PendSV_Handler:
    b       .
   272f2:	e7fe      	b.n	272f2 <PendSV_Handler>

000272f4 <SysTick_Handler>:


    .weak   SysTick_Handler
    .type   SysTick_Handler, %function
SysTick_Handler:
    b       .
   272f4:	e7fe      	b.n	272f4 <SysTick_Handler>

000272f6 <Default_Handler>:
/* IRQ Handlers */

    .globl  Default_Handler
    .type   Default_Handler, %function
Default_Handler:
    b       .
   272f6:	e7fe      	b.n	272f6 <Default_Handler>

000272f8 <app_error_handler_bare>:
 * @param[in] error_code  Error code supplied to the handler.
 * @param[in] line_num    Line number where the handler is called.
 * @param[in] p_file_name Pointer to the file name.
 */
void app_error_handler_bare(ret_code_t error_code)
{
   272f8:	b500      	push	{lr}
   272fa:	b085      	sub	sp, #20
   272fc:	4603      	mov	r3, r0
    error_info_t error_info =
   272fe:	2100      	movs	r1, #0
        .line_num    = 0,
        .p_file_name = NULL,
        .err_code    = error_code,
    };

    app_error_fault_handler(NRF_FAULT_ID_SDK_ERROR, 0, (uint32_t)(&error_info));
   27300:	aa01      	add	r2, sp, #4
   27302:	f244 0001 	movw	r0, #16385	; 0x4001
    error_info_t error_info =
   27306:	e9cd 1101 	strd	r1, r1, [sp, #4]
   2730a:	9303      	str	r3, [sp, #12]
    app_error_fault_handler(NRF_FAULT_ID_SDK_ERROR, 0, (uint32_t)(&error_info));
   2730c:	f000 f804 	bl	27318 <app_error_fault_handler>

    UNUSED_VARIABLE(error_info);
}
   27310:	b005      	add	sp, #20
   27312:	f85d fb04 	ldr.w	pc, [sp], #4
   27316:	bf00      	nop

00027318 <app_error_fault_handler>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   27318:	b672      	cpsid	i
            NRF_LOG_ERROR("UNKNOWN FAULT at 0x%08X", pc);
            break;
    }
#endif

    NRF_BREAKPOINT_COND;
   2731a:	4b09      	ldr	r3, [pc, #36]	; (27340 <app_error_fault_handler+0x28>)
   2731c:	681b      	ldr	r3, [r3, #0]
   2731e:	07db      	lsls	r3, r3, #31
   27320:	d500      	bpl.n	27324 <app_error_fault_handler+0xc>
   27322:	be00      	bkpt	0x0000
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   27324:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   27328:	4906      	ldr	r1, [pc, #24]	; (27344 <app_error_fault_handler+0x2c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   2732a:	4b07      	ldr	r3, [pc, #28]	; (27348 <app_error_fault_handler+0x30>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   2732c:	68ca      	ldr	r2, [r1, #12]
   2732e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   27332:	4313      	orrs	r3, r2
   27334:	60cb      	str	r3, [r1, #12]
   27336:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
   2733a:	bf00      	nop
   2733c:	e7fd      	b.n	2733a <app_error_fault_handler+0x22>
   2733e:	bf00      	nop
   27340:	e000edf0 	.word	0xe000edf0
   27344:	e000ed00 	.word	0xe000ed00
   27348:	05fa0004 	.word	0x05fa0004

0002734c <compare_func>:
    app_timer_t * p0 = CONTAINER_OF(p_item0, app_timer_t, list_item);
    app_timer_t * p1 = CONTAINER_OF(p_item1, app_timer_t, list_item);

    uint64_t p0_end = p0->end_val;
    uint64_t p1_end = p1->end_val;
    return (p0_end <= p1_end) ? true : false;
   2734c:	e9d0 2302 	ldrd	r2, r3, [r0, #8]
   27350:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
   27354:	4299      	cmp	r1, r3
   27356:	bf08      	it	eq
   27358:	4290      	cmpeq	r0, r2
}
   2735a:	bf2c      	ite	cs
   2735c:	2001      	movcs	r0, #1
   2735e:	2000      	movcc	r0, #0
   27360:	4770      	bx	lr
   27362:	bf00      	nop

00027364 <rtc_irq>:
        p_req = nrf_atfifo_item_get(m_req_fifo, &fifo_ctx);
    }
}

static void rtc_irq(drv_rtc_t const * const  p_instance)
{
   27364:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   27368:	ed2d 8b02 	vpush	{d8}
   2736c:	b085      	sub	sp, #20
   2736e:	4606      	mov	r6, r0
    if (drv_rtc_overflow_pending(p_instance))
   27370:	f000 fb64 	bl	27a3c <drv_rtc_overflow_pending>
   27374:	b140      	cbz	r0, 27388 <rtc_irq+0x24>
    m_base_counter += (DRV_RTC_MAX_CNT + 1);
   27376:	4ab5      	ldr	r2, [pc, #724]	; (2764c <rtc_irq+0x2e8>)
   27378:	e9d2 3100 	ldrd	r3, r1, [r2]
   2737c:	f113 7380 	adds.w	r3, r3, #16777216	; 0x1000000
   27380:	f141 0100 	adc.w	r1, r1, #0
   27384:	e9c2 3100 	strd	r3, r1, [r2]
    {
        on_overflow_evt();
    }
    if (drv_rtc_compare_pending(p_instance, 0))
   27388:	2100      	movs	r1, #0
   2738a:	4630      	mov	r0, r6
   2738c:	f000 fb72 	bl	27a74 <drv_rtc_compare_pending>
    if (mp_active_timer)
   27390:	4caf      	ldr	r4, [pc, #700]	; (27650 <rtc_irq+0x2ec>)
    if (drv_rtc_compare_pending(p_instance, 0))
   27392:	b160      	cbz	r0, 273ae <rtc_irq+0x4a>
    if (mp_active_timer)
   27394:	6823      	ldr	r3, [r4, #0]
   27396:	b153      	cbz	r3, 273ae <rtc_irq+0x4a>
    if ((m_global_active == true) && (p_timer != NULL) && (p_timer->active))
   27398:	4bae      	ldr	r3, [pc, #696]	; (27654 <rtc_irq+0x2f0>)
        UNUSED_RETURN_VALUE(timer_expire(mp_active_timer));
   2739a:	6825      	ldr	r5, [r4, #0]
    if ((m_global_active == true) && (p_timer != NULL) && (p_timer->active))
   2739c:	781b      	ldrb	r3, [r3, #0]
   2739e:	b123      	cbz	r3, 273aa <rtc_irq+0x46>
   273a0:	b11d      	cbz	r5, 273aa <rtc_irq+0x46>
   273a2:	7f2b      	ldrb	r3, [r5, #28]
   273a4:	2b00      	cmp	r3, #0
   273a6:	f040 811c 	bne.w	275e2 <rtc_irq+0x27e>
        mp_active_timer = NULL;
   273aa:	2300      	movs	r3, #0
   273ac:	6023      	str	r3, [r4, #0]
    {
        on_compare_evt(p_instance);
    }
    if (drv_rtc_compare_pending(p_instance, 1))
   273ae:	2101      	movs	r1, #1
   273b0:	4630      	mov	r0, r6
   273b2:	f000 fb5f 	bl	27a74 <drv_rtc_compare_pending>
   273b6:	2800      	cmp	r0, #0
   273b8:	f040 80f6 	bne.w	275a8 <rtc_irq+0x244>
    timer_req_t *         p_req = nrf_atfifo_item_get(m_req_fifo, &fifo_ctx);
   273bc:	48a6      	ldr	r0, [pc, #664]	; (27658 <rtc_irq+0x2f4>)
   273be:	a903      	add	r1, sp, #12
   273c0:	f000 fbdc 	bl	27b7c <nrf_atfifo_item_get>
    while (p_req)
   273c4:	b378      	cbz	r0, 27426 <rtc_irq+0xc2>
                    bool found = nrf_sortlist_remove(&m_app_timer_sortlist, &(p_req->p_timer->list_item));
   273c6:	4da5      	ldr	r5, [pc, #660]	; (2765c <rtc_irq+0x2f8>)
                m_global_active = true;
   273c8:	f8df 8288 	ldr.w	r8, [pc, #648]	; 27654 <rtc_irq+0x2f0>
        UNUSED_RETURN_VALUE(nrf_atfifo_item_free(m_req_fifo, &fifo_ctx));
   273cc:	4fa2      	ldr	r7, [pc, #648]	; (27658 <rtc_irq+0x2f4>)
   273ce:	e00b      	b.n	273e8 <rtc_irq+0x84>
        switch (p_req->type)
   273d0:	2b00      	cmp	r3, #0
   273d2:	f000 80cd 	beq.w	27570 <rtc_irq+0x20c>
        UNUSED_RETURN_VALUE(nrf_atfifo_item_free(m_req_fifo, &fifo_ctx));
   273d6:	a903      	add	r1, sp, #12
   273d8:	4638      	mov	r0, r7
   273da:	f000 fbff 	bl	27bdc <nrf_atfifo_item_free>
        p_req = nrf_atfifo_item_get(m_req_fifo, &fifo_ctx);
   273de:	a903      	add	r1, sp, #12
   273e0:	4638      	mov	r0, r7
   273e2:	f000 fbcb 	bl	27b7c <nrf_atfifo_item_get>
    while (p_req)
   273e6:	b1f0      	cbz	r0, 27426 <rtc_irq+0xc2>
        switch (p_req->type)
   273e8:	7803      	ldrb	r3, [r0, #0]
   273ea:	2b01      	cmp	r3, #1
   273ec:	d012      	beq.n	27414 <rtc_irq+0xb0>
   273ee:	2b02      	cmp	r3, #2
   273f0:	d1ee      	bne.n	273d0 <rtc_irq+0x6c>
    nrf_sortlist_item_t * p_next_item = nrf_sortlist_pop(&m_app_timer_sortlist);
   273f2:	4628      	mov	r0, r5
            p_next->active = false;
   273f4:	f04f 0900 	mov.w	r9, #0
    nrf_sortlist_item_t * p_next_item = nrf_sortlist_pop(&m_app_timer_sortlist);
   273f8:	f000 fc6c 	bl	27cd4 <nrf_sortlist_pop>
        if (p_next)
   273fc:	b130      	cbz	r0, 2740c <rtc_irq+0xa8>
            p_next->active = false;
   273fe:	f880 901c 	strb.w	r9, [r0, #28]
    nrf_sortlist_item_t * p_next_item = nrf_sortlist_pop(&m_app_timer_sortlist);
   27402:	4628      	mov	r0, r5
   27404:	f000 fc66 	bl	27cd4 <nrf_sortlist_pop>
        if (p_next)
   27408:	2800      	cmp	r0, #0
   2740a:	d1f8      	bne.n	273fe <rtc_irq+0x9a>
                m_global_active = true;
   2740c:	2301      	movs	r3, #1
   2740e:	f888 3000 	strb.w	r3, [r8]
                break;
   27412:	e7e0      	b.n	273d6 <rtc_irq+0x72>
                if (p_req->p_timer == mp_active_timer)
   27414:	6841      	ldr	r1, [r0, #4]
   27416:	6823      	ldr	r3, [r4, #0]
   27418:	4299      	cmp	r1, r3
   2741a:	f000 80ba 	beq.w	27592 <rtc_irq+0x22e>
                    bool found = nrf_sortlist_remove(&m_app_timer_sortlist, &(p_req->p_timer->list_item));
   2741e:	4628      	mov	r0, r5
   27420:	f000 fc62 	bl	27ce8 <nrf_sortlist_remove>
                    if (!found)
   27424:	e7d7      	b.n	273d6 <rtc_irq+0x72>
    nrf_sortlist_item_t const * p_next_item = nrf_sortlist_peek(&m_app_timer_sortlist);
   27426:	f8df 8234 	ldr.w	r8, [pc, #564]	; 2765c <rtc_irq+0x2f8>
    uint64_t now = m_base_counter + drv_rtc_counter_get(&m_rtc_inst);
   2742a:	4f8d      	ldr	r7, [pc, #564]	; (27660 <rtc_irq+0x2fc>)
   2742c:	f8df 921c 	ldr.w	r9, [pc, #540]	; 2764c <rtc_irq+0x2e8>
   27430:	ee08 6a10 	vmov	s16, r6
}
   27434:	e037      	b.n	274a6 <rtc_irq+0x142>
    nrf_sortlist_item_t * p_next_item = nrf_sortlist_pop(&m_app_timer_sortlist);
   27436:	4640      	mov	r0, r8
   27438:	f000 fc4c 	bl	27cd4 <nrf_sortlist_pop>
   2743c:	4605      	mov	r5, r0
    uint64_t now = m_base_counter + drv_rtc_counter_get(&m_rtc_inst);
   2743e:	4638      	mov	r0, r7
    int64_t remaining = (int64_t)(p_timer->end_val - get_now());
   27440:	68ab      	ldr	r3, [r5, #8]
   27442:	68ea      	ldr	r2, [r5, #12]
   27444:	9301      	str	r3, [sp, #4]
   27446:	9200      	str	r2, [sp, #0]
    uint64_t now = m_base_counter + drv_rtc_counter_get(&m_rtc_inst);
   27448:	f000 fb24 	bl	27a94 <drv_rtc_counter_get>
    if (now < m_stamp64) {
   2744c:	4e85      	ldr	r6, [pc, #532]	; (27664 <rtc_irq+0x300>)
    uint64_t now = m_base_counter + drv_rtc_counter_get(&m_rtc_inst);
   2744e:	4684      	mov	ip, r0
   27450:	e9d9 0100 	ldrd	r0, r1, [r9]
    if (now < m_stamp64) {
   27454:	e9d6 2300 	ldrd	r2, r3, [r6]
    uint64_t now = m_base_counter + drv_rtc_counter_get(&m_rtc_inst);
   27458:	eb10 000c 	adds.w	r0, r0, ip
   2745c:	f141 0100 	adc.w	r1, r1, #0
    if (now < m_stamp64) {
   27460:	4299      	cmp	r1, r3
   27462:	bf08      	it	eq
   27464:	4290      	cmpeq	r0, r2
   27466:	e9dd 2300 	ldrd	r2, r3, [sp]
   2746a:	d203      	bcs.n	27474 <rtc_irq+0x110>
        now += (DRV_RTC_MAX_CNT + 1);
   2746c:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
   27470:	f141 0100 	adc.w	r1, r1, #0
    int64_t remaining = (int64_t)(p_timer->end_val - get_now());
   27474:	ebb3 0a00 	subs.w	sl, r3, r0
   27478:	eb62 0b01 	sbc.w	fp, r2, r1
    if (remaining > 0) {
   2747c:	f1ba 0f01 	cmp.w	sl, #1
   27480:	f17b 0300 	sbcs.w	r3, fp, #0
   27484:	db29      	blt.n	274da <rtc_irq+0x176>
        uint32_t cc_val = ((uint32_t)remaining > APP_TIMER_RTC_MAX_VALUE) ?
   27486:	f5ba 0f35 	cmp.w	sl, #11862016	; 0xb50000
   2748a:	d26b      	bcs.n	27564 <rtc_irq+0x200>
   2748c:	68aa      	ldr	r2, [r5, #8]
        ret = drv_rtc_windowed_compare_set(&m_rtc_inst, 0, cc_val, APP_TIMER_SAFE_WINDOW);
   2748e:	f44f 0396 	mov.w	r3, #4915200	; 0x4b0000
   27492:	2100      	movs	r1, #0
   27494:	4638      	mov	r0, r7
   27496:	f000 fa4b 	bl	27930 <drv_rtc_windowed_compare_set>
        if (ret == NRF_SUCCESS)
   2749a:	2800      	cmp	r0, #0
   2749c:	d05a      	beq.n	27554 <rtc_irq+0x1f0>
    if (ret == NRF_ERROR_TIMEOUT)
   2749e:	280d      	cmp	r0, #13
   274a0:	d01f      	beq.n	274e2 <rtc_irq+0x17e>
                    mp_active_timer = NULL;
   274a2:	2300      	movs	r3, #0
   274a4:	6023      	str	r3, [r4, #0]
    nrf_sortlist_item_t const * p_next_item = nrf_sortlist_peek(&m_app_timer_sortlist);
   274a6:	4640      	mov	r0, r8
   274a8:	f000 fc1a 	bl	27ce0 <nrf_sortlist_peek>
        if (p_next) //Candidate for active timer
   274ac:	2800      	cmp	r0, #0
   274ae:	d073      	beq.n	27598 <rtc_irq+0x234>
            if (mp_active_timer == NULL)
   274b0:	6823      	ldr	r3, [r4, #0]
   274b2:	2b00      	cmp	r3, #0
   274b4:	d0bf      	beq.n	27436 <rtc_irq+0xd2>
            else if (p_next->end_val < mp_active_timer->end_val)
   274b6:	6823      	ldr	r3, [r4, #0]
   274b8:	e9d0 0102 	ldrd	r0, r1, [r0, #8]
   274bc:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
   274c0:	4299      	cmp	r1, r3
   274c2:	bf08      	it	eq
   274c4:	4290      	cmpeq	r0, r2
   274c6:	d248      	bcs.n	2755a <rtc_irq+0x1f6>
                if (mp_active_timer->active)
   274c8:	6823      	ldr	r3, [r4, #0]
   274ca:	7f1b      	ldrb	r3, [r3, #28]
   274cc:	2b00      	cmp	r3, #0
   274ce:	d0b2      	beq.n	27436 <rtc_irq+0xd2>
                    nrf_sortlist_add(&m_app_timer_sortlist, &mp_active_timer->list_item);
   274d0:	6821      	ldr	r1, [r4, #0]
   274d2:	4640      	mov	r0, r8
   274d4:	f000 fbea 	bl	27cac <nrf_sortlist_add>
            if (rtc_reconf)
   274d8:	e7ad      	b.n	27436 <rtc_irq+0xd2>
        drv_rtc_compare_disable(&m_rtc_inst, 0);
   274da:	2100      	movs	r1, #0
   274dc:	4638      	mov	r0, r7
   274de:	f000 fabd 	bl	27a5c <drv_rtc_compare_disable>
    if ((m_global_active == true) && (p_timer != NULL) && (p_timer->active))
   274e2:	4b5c      	ldr	r3, [pc, #368]	; (27654 <rtc_irq+0x2f0>)
   274e4:	781b      	ldrb	r3, [r3, #0]
   274e6:	2b00      	cmp	r3, #0
   274e8:	d0db      	beq.n	274a2 <rtc_irq+0x13e>
   274ea:	7f2b      	ldrb	r3, [r5, #28]
   274ec:	2b00      	cmp	r3, #0
   274ee:	d0d8      	beq.n	274a2 <rtc_irq+0x13e>
    uint64_t now = m_base_counter + drv_rtc_counter_get(&m_rtc_inst);
   274f0:	4638      	mov	r0, r7
   274f2:	f000 facf 	bl	27a94 <drv_rtc_counter_get>
   274f6:	4684      	mov	ip, r0
   274f8:	e9d9 0100 	ldrd	r0, r1, [r9]
    if (now < m_stamp64) {
   274fc:	e9d6 2300 	ldrd	r2, r3, [r6]
    uint64_t now = m_base_counter + drv_rtc_counter_get(&m_rtc_inst);
   27500:	eb10 000c 	adds.w	r0, r0, ip
   27504:	f141 0100 	adc.w	r1, r1, #0
    if (now < m_stamp64) {
   27508:	4299      	cmp	r1, r3
   2750a:	bf08      	it	eq
   2750c:	4290      	cmpeq	r0, r2
   2750e:	d203      	bcs.n	27518 <rtc_irq+0x1b4>
        now += (DRV_RTC_MAX_CNT + 1);
   27510:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
   27514:	f141 0100 	adc.w	r1, r1, #0
        if (get_now() >= p_timer->end_val) {
   27518:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
   2751c:	4299      	cmp	r1, r3
   2751e:	bf08      	it	eq
   27520:	4290      	cmpeq	r0, r2
   27522:	d359      	bcc.n	275d8 <rtc_irq+0x274>
            if (p_timer->repeat_period == 0)
   27524:	692b      	ldr	r3, [r5, #16]
   27526:	b903      	cbnz	r3, 2752a <rtc_irq+0x1c6>
                p_timer->active = false;
   27528:	772b      	strb	r3, [r5, #28]
            p_timer->handler(p_timer->p_context);
   2752a:	e9d5 3005 	ldrd	r3, r0, [r5, #20]
   2752e:	4798      	blx	r3
            if ((p_timer->repeat_period) && (p_timer->active))
   27530:	6929      	ldr	r1, [r5, #16]
   27532:	2900      	cmp	r1, #0
   27534:	d0b5      	beq.n	274a2 <rtc_irq+0x13e>
   27536:	7f2b      	ldrb	r3, [r5, #28]
   27538:	2b00      	cmp	r3, #0
   2753a:	d0b2      	beq.n	274a2 <rtc_irq+0x13e>
                p_timer->end_val += p_timer->repeat_period;
   2753c:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
   27540:	1852      	adds	r2, r2, r1
   27542:	f143 0300 	adc.w	r3, r3, #0
   27546:	e9c5 2302 	strd	r2, r3, [r5, #8]
                nrf_sortlist_add(&m_app_timer_sortlist, &p_timer->list_item);
   2754a:	4629      	mov	r1, r5
   2754c:	4640      	mov	r0, r8
   2754e:	f000 fbad 	bl	27cac <nrf_sortlist_add>
                ret = true;
   27552:	e7a6      	b.n	274a2 <rtc_irq+0x13e>
                    if (!APP_TIMER_KEEPS_RTC_ACTIVE && (mp_active_timer == NULL))
   27554:	6823      	ldr	r3, [r4, #0]
   27556:	b1bb      	cbz	r3, 27588 <rtc_irq+0x224>
                    mp_active_timer = p_next;
   27558:	6025      	str	r5, [r4, #0]
        on_compare1_evt(p_instance);
    }

    timer_req_process(p_instance);
    rtc_update(p_instance);
}
   2755a:	b005      	add	sp, #20
   2755c:	ecbd 8b02 	vpop	{d8}
   27560:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return ((ticks_to - ticks_from) & RTC_COUNTER_COUNTER_Msk);
}

uint32_t app_timer_cnt_get(void)
{
    return drv_rtc_counter_get(&m_rtc_inst);
   27564:	4638      	mov	r0, r7
   27566:	f000 fa95 	bl	27a94 <drv_rtc_counter_get>
        uint32_t cc_val = ((uint32_t)remaining > APP_TIMER_RTC_MAX_VALUE) ?
   2756a:	4a3f      	ldr	r2, [pc, #252]	; (27668 <rtc_irq+0x304>)
   2756c:	4402      	add	r2, r0
   2756e:	e78e      	b.n	2748e <rtc_irq+0x12a>
                if (!p_req->p_timer->active)
   27570:	6843      	ldr	r3, [r0, #4]
   27572:	7f1a      	ldrb	r2, [r3, #28]
   27574:	2a00      	cmp	r2, #0
   27576:	f47f af2e 	bne.w	273d6 <rtc_irq+0x72>
                    p_req->p_timer->active = true;
   2757a:	2201      	movs	r2, #1
   2757c:	771a      	strb	r2, [r3, #28]
                    nrf_sortlist_add(&m_app_timer_sortlist, &(p_req->p_timer->list_item));
   2757e:	6841      	ldr	r1, [r0, #4]
   27580:	4628      	mov	r0, r5
   27582:	f000 fb93 	bl	27cac <nrf_sortlist_add>
                    NRF_LOG_INST_DEBUG(p_req->p_timer->p_log,"Start request (expiring at %d/0x%08x).",
   27586:	e726      	b.n	273d6 <rtc_irq+0x72>
                        drv_rtc_start(p_instance);
   27588:	ee18 0a10 	vmov	r0, s16
   2758c:	f000 f9a2 	bl	278d4 <drv_rtc_start>
   27590:	e7e2      	b.n	27558 <rtc_irq+0x1f4>
                    mp_active_timer = NULL;
   27592:	2300      	movs	r3, #0
   27594:	6023      	str	r3, [r4, #0]
   27596:	e71e      	b.n	273d6 <rtc_irq+0x72>
            if (!APP_TIMER_KEEPS_RTC_ACTIVE && (mp_active_timer == NULL))
   27598:	6823      	ldr	r3, [r4, #0]
   2759a:	2b00      	cmp	r3, #0
   2759c:	d1dd      	bne.n	2755a <rtc_irq+0x1f6>
                drv_rtc_stop(p_instance);
   2759e:	ee18 0a10 	vmov	r0, s16
   275a2:	f000 f99b 	bl	278dc <drv_rtc_stop>
}
   275a6:	e7d8      	b.n	2755a <rtc_irq+0x1f6>
    uint64_t now = m_base_counter + drv_rtc_counter_get(&m_rtc_inst);
   275a8:	482d      	ldr	r0, [pc, #180]	; (27660 <rtc_irq+0x2fc>)
    if (now < m_stamp64) {
   275aa:	4d2e      	ldr	r5, [pc, #184]	; (27664 <rtc_irq+0x300>)
    uint64_t now = m_base_counter + drv_rtc_counter_get(&m_rtc_inst);
   275ac:	f000 fa72 	bl	27a94 <drv_rtc_counter_get>
   275b0:	4b26      	ldr	r3, [pc, #152]	; (2764c <rtc_irq+0x2e8>)
   275b2:	e9d3 8900 	ldrd	r8, r9, [r3]
    if (now < m_stamp64) {
   275b6:	e9d5 2300 	ldrd	r2, r3, [r5]
    uint64_t now = m_base_counter + drv_rtc_counter_get(&m_rtc_inst);
   275ba:	eb18 0800 	adds.w	r8, r8, r0
   275be:	f149 0900 	adc.w	r9, r9, #0
    if (now < m_stamp64) {
   275c2:	4599      	cmp	r9, r3
   275c4:	bf08      	it	eq
   275c6:	4590      	cmpeq	r8, r2
   275c8:	d203      	bcs.n	275d2 <rtc_irq+0x26e>
        now += (DRV_RTC_MAX_CNT + 1);
   275ca:	f118 7880 	adds.w	r8, r8, #16777216	; 0x1000000
   275ce:	f149 0900 	adc.w	r9, r9, #0
    m_stamp64 = get_now();
   275d2:	e9c5 8900 	strd	r8, r9, [r5]
}
   275d6:	e6f1      	b.n	273bc <rtc_irq+0x58>
            nrf_sortlist_add(&m_app_timer_sortlist, &p_timer->list_item);
   275d8:	4629      	mov	r1, r5
   275da:	4640      	mov	r0, r8
   275dc:	f000 fb66 	bl	27cac <nrf_sortlist_add>
            ret = true;
   275e0:	e75f      	b.n	274a2 <rtc_irq+0x13e>
    uint64_t now = m_base_counter + drv_rtc_counter_get(&m_rtc_inst);
   275e2:	481f      	ldr	r0, [pc, #124]	; (27660 <rtc_irq+0x2fc>)
   275e4:	f000 fa56 	bl	27a94 <drv_rtc_counter_get>
   275e8:	4a18      	ldr	r2, [pc, #96]	; (2764c <rtc_irq+0x2e8>)
    if (now < m_stamp64) {
   275ea:	4b1e      	ldr	r3, [pc, #120]	; (27664 <rtc_irq+0x300>)
    uint64_t now = m_base_counter + drv_rtc_counter_get(&m_rtc_inst);
   275ec:	e9d2 8900 	ldrd	r8, r9, [r2]
    if (now < m_stamp64) {
   275f0:	e9d3 2300 	ldrd	r2, r3, [r3]
    uint64_t now = m_base_counter + drv_rtc_counter_get(&m_rtc_inst);
   275f4:	eb18 0800 	adds.w	r8, r8, r0
   275f8:	f149 0900 	adc.w	r9, r9, #0
    if (now < m_stamp64) {
   275fc:	4599      	cmp	r9, r3
   275fe:	bf08      	it	eq
   27600:	4590      	cmpeq	r8, r2
   27602:	d203      	bcs.n	2760c <rtc_irq+0x2a8>
        now += (DRV_RTC_MAX_CNT + 1);
   27604:	f118 7880 	adds.w	r8, r8, #16777216	; 0x1000000
   27608:	f149 0900 	adc.w	r9, r9, #0
        if (get_now() >= p_timer->end_val) {
   2760c:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
   27610:	4599      	cmp	r9, r3
   27612:	bf08      	it	eq
   27614:	4590      	cmpeq	r8, r2
   27616:	d329      	bcc.n	2766c <rtc_irq+0x308>
            if (p_timer->repeat_period == 0)
   27618:	692b      	ldr	r3, [r5, #16]
   2761a:	b903      	cbnz	r3, 2761e <rtc_irq+0x2ba>
                p_timer->active = false;
   2761c:	772b      	strb	r3, [r5, #28]
            p_timer->handler(p_timer->p_context);
   2761e:	e9d5 3005 	ldrd	r3, r0, [r5, #20]
   27622:	4798      	blx	r3
            if ((p_timer->repeat_period) && (p_timer->active))
   27624:	6929      	ldr	r1, [r5, #16]
   27626:	2900      	cmp	r1, #0
   27628:	f43f aebf 	beq.w	273aa <rtc_irq+0x46>
   2762c:	7f2b      	ldrb	r3, [r5, #28]
   2762e:	2b00      	cmp	r3, #0
   27630:	f43f aebb 	beq.w	273aa <rtc_irq+0x46>
                p_timer->end_val += p_timer->repeat_period;
   27634:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
   27638:	1852      	adds	r2, r2, r1
   2763a:	f143 0300 	adc.w	r3, r3, #0
   2763e:	e9c5 2302 	strd	r2, r3, [r5, #8]
                nrf_sortlist_add(&m_app_timer_sortlist, &p_timer->list_item);
   27642:	4806      	ldr	r0, [pc, #24]	; (2765c <rtc_irq+0x2f8>)
   27644:	4629      	mov	r1, r5
   27646:	f000 fb31 	bl	27cac <nrf_sortlist_add>
                ret = true;
   2764a:	e6ae      	b.n	273aa <rtc_irq+0x46>
   2764c:	200020c8 	.word	0x200020c8
   27650:	20002148 	.word	0x20002148
   27654:	200020d0 	.word	0x200020d0
   27658:	2000212c 	.word	0x2000212c
   2765c:	0002bcd4 	.word	0x0002bcd4
   27660:	20002000 	.word	0x20002000
   27664:	20002140 	.word	0x20002140
   27668:	00b4ffff 	.word	0x00b4ffff
            nrf_sortlist_add(&m_app_timer_sortlist, &p_timer->list_item);
   2766c:	4802      	ldr	r0, [pc, #8]	; (27678 <rtc_irq+0x314>)
   2766e:	4629      	mov	r1, r5
   27670:	f000 fb1c 	bl	27cac <nrf_sortlist_add>
            ret = true;
   27674:	e699      	b.n	273aa <rtc_irq+0x46>
   27676:	bf00      	nop
   27678:	0002bcd4 	.word	0x0002bcd4

0002767c <app_timer_init>:
{
   2767c:	b510      	push	{r4, lr}
    drv_rtc_config_t config = {
   2767e:	4b13      	ldr	r3, [pc, #76]	; (276cc <app_timer_init+0x50>)
    err_code = NRF_ATFIFO_INIT(m_req_fifo);
   27680:	4913      	ldr	r1, [pc, #76]	; (276d0 <app_timer_init+0x54>)
    drv_rtc_config_t config = {
   27682:	681b      	ldr	r3, [r3, #0]
    err_code = NRF_ATFIFO_INIT(m_req_fifo);
   27684:	4813      	ldr	r0, [pc, #76]	; (276d4 <app_timer_init+0x58>)
{
   27686:	b082      	sub	sp, #8
    err_code = NRF_ATFIFO_INIT(m_req_fifo);
   27688:	2258      	movs	r2, #88	; 0x58
    drv_rtc_config_t config = {
   2768a:	9301      	str	r3, [sp, #4]
    err_code = NRF_ATFIFO_INIT(m_req_fifo);
   2768c:	2308      	movs	r3, #8
   2768e:	f000 fa1f 	bl	27ad0 <nrf_atfifo_init>
    if (err_code != NRFX_SUCCESS)
   27692:	4604      	mov	r4, r0
   27694:	b110      	cbz	r0, 2769c <app_timer_init+0x20>
}
   27696:	4620      	mov	r0, r4
   27698:	b002      	add	sp, #8
   2769a:	bd10      	pop	{r4, pc}
    err_code = drv_rtc_init(&m_rtc_inst, &config, rtc_irq);
   2769c:	4a0e      	ldr	r2, [pc, #56]	; (276d8 <app_timer_init+0x5c>)
   2769e:	480f      	ldr	r0, [pc, #60]	; (276dc <app_timer_init+0x60>)
   276a0:	a901      	add	r1, sp, #4
   276a2:	f000 f8d5 	bl	27850 <drv_rtc_init>
    if (err_code != NRFX_SUCCESS)
   276a6:	4604      	mov	r4, r0
   276a8:	2800      	cmp	r0, #0
   276aa:	d1f4      	bne.n	27696 <app_timer_init+0x1a>
    drv_rtc_overflow_enable(&m_rtc_inst, true);
   276ac:	480b      	ldr	r0, [pc, #44]	; (276dc <app_timer_init+0x60>)
   276ae:	2101      	movs	r1, #1
   276b0:	f000 f9ba 	bl	27a28 <drv_rtc_overflow_enable>
    drv_rtc_compare_set(&m_rtc_inst, 1, DRV_RTC_MAX_CNT >> 1, true);
   276b4:	2301      	movs	r3, #1
   276b6:	4619      	mov	r1, r3
   276b8:	4a09      	ldr	r2, [pc, #36]	; (276e0 <app_timer_init+0x64>)
   276ba:	4808      	ldr	r0, [pc, #32]	; (276dc <app_timer_init+0x60>)
   276bc:	f000 f912 	bl	278e4 <drv_rtc_compare_set>
    m_global_active = true;
   276c0:	4b08      	ldr	r3, [pc, #32]	; (276e4 <app_timer_init+0x68>)
   276c2:	2201      	movs	r2, #1
}
   276c4:	4620      	mov	r0, r4
    m_global_active = true;
   276c6:	701a      	strb	r2, [r3, #0]
}
   276c8:	b002      	add	sp, #8
   276ca:	bd10      	pop	{r4, pc}
   276cc:	0002bcd0 	.word	0x0002bcd0
   276d0:	200020d4 	.word	0x200020d4
   276d4:	2000212c 	.word	0x2000212c
   276d8:	00027365 	.word	0x00027365
   276dc:	20002000 	.word	0x20002000
   276e0:	007fffff 	.word	0x007fffff
   276e4:	200020d0 	.word	0x200020d0

000276e8 <app_timer_create>:
    if (timeout_handler == NULL)
   276e8:	b14a      	cbz	r2, 276fe <app_timer_create+0x16>
    p_t->repeat_period = (mode == APP_TIMER_MODE_REPEATED) ? 1 : 0;
   276ea:	f1a1 0101 	sub.w	r1, r1, #1
    app_timer_t * p_t = (app_timer_t *) *p_timer_id;
   276ee:	6803      	ldr	r3, [r0, #0]
    p_t->repeat_period = (mode == APP_TIMER_MODE_REPEATED) ? 1 : 0;
   276f0:	fab1 f181 	clz	r1, r1
   276f4:	0949      	lsrs	r1, r1, #5
   276f6:	e9c3 1204 	strd	r1, r2, [r3, #16]
    return NRF_SUCCESS;
   276fa:	2000      	movs	r0, #0
   276fc:	4770      	bx	lr
        return NRF_ERROR_INVALID_PARAM;
   276fe:	2007      	movs	r0, #7
}
   27700:	4770      	bx	lr
   27702:	bf00      	nop

00027704 <app_timer_start>:
    if (p_t->active)
   27704:	7f03      	ldrb	r3, [r0, #28]
   27706:	b10b      	cbz	r3, 2770c <app_timer_start+0x8>
        return NRF_SUCCESS;
   27708:	2000      	movs	r0, #0
}
   2770a:	4770      	bx	lr
{
   2770c:	b5f0      	push	{r4, r5, r6, r7, lr}
    p_t->p_context = p_context;
   2770e:	6182      	str	r2, [r0, #24]
{
   27710:	b083      	sub	sp, #12
   27712:	4604      	mov	r4, r0
    uint64_t now = m_base_counter + drv_rtc_counter_get(&m_rtc_inst);
   27714:	481a      	ldr	r0, [pc, #104]	; (27780 <app_timer_start+0x7c>)
   27716:	460d      	mov	r5, r1
   27718:	f000 f9bc 	bl	27a94 <drv_rtc_counter_get>
   2771c:	4b19      	ldr	r3, [pc, #100]	; (27784 <app_timer_start+0x80>)
    if (now < m_stamp64) {
   2771e:	491a      	ldr	r1, [pc, #104]	; (27788 <app_timer_start+0x84>)
    uint64_t now = m_base_counter + drv_rtc_counter_get(&m_rtc_inst);
   27720:	e9d3 2300 	ldrd	r2, r3, [r3]
    if (now < m_stamp64) {
   27724:	e9d1 6700 	ldrd	r6, r7, [r1]
    uint64_t now = m_base_counter + drv_rtc_counter_get(&m_rtc_inst);
   27728:	1812      	adds	r2, r2, r0
   2772a:	f143 0300 	adc.w	r3, r3, #0
    if (now < m_stamp64) {
   2772e:	42bb      	cmp	r3, r7
   27730:	bf08      	it	eq
   27732:	42b2      	cmpeq	r2, r6
   27734:	d203      	bcs.n	2773e <app_timer_start+0x3a>
        now += (DRV_RTC_MAX_CNT + 1);
   27736:	f112 7280 	adds.w	r2, r2, #16777216	; 0x1000000
   2773a:	f143 0300 	adc.w	r3, r3, #0
    p_t->end_val = get_now() + timeout_ticks;
   2773e:	1952      	adds	r2, r2, r5
    if (p_t->repeat_period)
   27740:	6921      	ldr	r1, [r4, #16]
    p_t->end_val = get_now() + timeout_ticks;
   27742:	f143 0300 	adc.w	r3, r3, #0
   27746:	e9c4 2302 	strd	r2, r3, [r4, #8]
    if (p_t->repeat_period)
   2774a:	b101      	cbz	r1, 2774e <app_timer_start+0x4a>
        p_t->repeat_period = timeout_ticks;
   2774c:	6125      	str	r5, [r4, #16]
    p_req = nrf_atfifo_item_alloc(m_req_fifo, &fifo_ctx);
   2774e:	480f      	ldr	r0, [pc, #60]	; (2778c <app_timer_start+0x88>)
   27750:	a901      	add	r1, sp, #4
   27752:	f000 f9d5 	bl	27b00 <nrf_atfifo_item_alloc>
    if (p_req)
   27756:	b148      	cbz	r0, 2776c <app_timer_start+0x68>
        p_req->type    = type;
   27758:	2500      	movs	r5, #0
        p_req->p_timer = p_timer;
   2775a:	6044      	str	r4, [r0, #4]
        p_req->type    = type;
   2775c:	7005      	strb	r5, [r0, #0]
        if (nrf_atfifo_item_put(m_req_fifo, &fifo_ctx))
   2775e:	a901      	add	r1, sp, #4
   27760:	480a      	ldr	r0, [pc, #40]	; (2778c <app_timer_start+0x88>)
   27762:	f000 f9fb 	bl	27b5c <nrf_atfifo_item_put>
   27766:	b920      	cbnz	r0, 27772 <app_timer_start+0x6e>
}
   27768:	b003      	add	sp, #12
   2776a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return NRF_ERROR_NO_MEM;
   2776c:	2004      	movs	r0, #4
}
   2776e:	b003      	add	sp, #12
   27770:	bdf0      	pop	{r4, r5, r6, r7, pc}
    drv_rtc_irq_trigger(&m_rtc_inst);
   27772:	4803      	ldr	r0, [pc, #12]	; (27780 <app_timer_start+0x7c>)
   27774:	f000 f992 	bl	27a9c <drv_rtc_irq_trigger>
        return NRF_SUCCESS;
   27778:	4628      	mov	r0, r5
}
   2777a:	b003      	add	sp, #12
   2777c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2777e:	bf00      	nop
   27780:	20002000 	.word	0x20002000
   27784:	200020c8 	.word	0x200020c8
   27788:	20002140 	.word	0x20002140
   2778c:	2000212c 	.word	0x2000212c

00027790 <app_timer_stop>:
{
   27790:	b530      	push	{r4, r5, lr}
    p_t->active = false;
   27792:	2500      	movs	r5, #0
{
   27794:	b083      	sub	sp, #12
   27796:	4604      	mov	r4, r0
    p_t->active = false;
   27798:	7705      	strb	r5, [r0, #28]
    p_req = nrf_atfifo_item_alloc(m_req_fifo, &fifo_ctx);
   2779a:	a901      	add	r1, sp, #4
   2779c:	480b      	ldr	r0, [pc, #44]	; (277cc <app_timer_stop+0x3c>)
   2779e:	f000 f9af 	bl	27b00 <nrf_atfifo_item_alloc>
    if (p_req)
   277a2:	b178      	cbz	r0, 277c4 <app_timer_stop+0x34>
        p_req->type    = type;
   277a4:	2201      	movs	r2, #1
        p_req->p_timer = p_timer;
   277a6:	6044      	str	r4, [r0, #4]
        p_req->type    = type;
   277a8:	7002      	strb	r2, [r0, #0]
        if (nrf_atfifo_item_put(m_req_fifo, &fifo_ctx))
   277aa:	a901      	add	r1, sp, #4
   277ac:	4807      	ldr	r0, [pc, #28]	; (277cc <app_timer_stop+0x3c>)
   277ae:	f000 f9d5 	bl	27b5c <nrf_atfifo_item_put>
   277b2:	b908      	cbnz	r0, 277b8 <app_timer_stop+0x28>
}
   277b4:	b003      	add	sp, #12
   277b6:	bd30      	pop	{r4, r5, pc}
    drv_rtc_irq_trigger(&m_rtc_inst);
   277b8:	4805      	ldr	r0, [pc, #20]	; (277d0 <app_timer_stop+0x40>)
   277ba:	f000 f96f 	bl	27a9c <drv_rtc_irq_trigger>
        return NRF_SUCCESS;
   277be:	4628      	mov	r0, r5
}
   277c0:	b003      	add	sp, #12
   277c2:	bd30      	pop	{r4, r5, pc}
        return NRF_ERROR_NO_MEM;
   277c4:	2004      	movs	r0, #4
}
   277c6:	b003      	add	sp, #12
   277c8:	bd30      	pop	{r4, r5, pc}
   277ca:	bf00      	nop
   277cc:	2000212c 	.word	0x2000212c
   277d0:	20002000 	.word	0x20002000

000277d4 <app_util_critical_region_enter>:
        __enable_irq();
    }
}

void app_util_critical_region_enter(uint8_t *p_nested)
{
   277d4:	b470      	push	{r4, r5, r6}
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   277d6:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   277da:	b672      	cpsid	i
}

__STATIC_INLINE uint32_t sd_nvic_critical_region_enter(uint8_t * p_is_nested_critical_region)
{
  int was_masked = __sd_nvic_irq_disable();
  if (!nrf_nvic_state.__cr_flag)
   277dc:	4b0d      	ldr	r3, [pc, #52]	; (27814 <app_util_critical_region_enter+0x40>)
   277de:	689a      	ldr	r2, [r3, #8]
   277e0:	b9aa      	cbnz	r2, 2780e <app_util_critical_region_enter+0x3a>
  {
    nrf_nvic_state.__cr_flag = 1;
    nrf_nvic_state.__irq_masks[0] = ( NVIC->ICER[0] & __NRF_NVIC_APP_IRQS_0 );
   277e2:	490d      	ldr	r1, [pc, #52]	; (27818 <app_util_critical_region_enter+0x44>)
   277e4:	4e0d      	ldr	r6, [pc, #52]	; (2781c <app_util_critical_region_enter+0x48>)
    nrf_nvic_state.__cr_flag = 1;
   277e6:	2501      	movs	r5, #1
   277e8:	609d      	str	r5, [r3, #8]
    nrf_nvic_state.__irq_masks[0] = ( NVIC->ICER[0] & __NRF_NVIC_APP_IRQS_0 );
   277ea:	f8d1 5080 	ldr.w	r5, [r1, #128]	; 0x80
   277ee:	4035      	ands	r5, r6
   277f0:	601d      	str	r5, [r3, #0]
    NVIC->ICER[0] = __NRF_NVIC_APP_IRQS_0;
   277f2:	f8c1 6080 	str.w	r6, [r1, #128]	; 0x80
    nrf_nvic_state.__irq_masks[1] = ( NVIC->ICER[1] & __NRF_NVIC_APP_IRQS_1 );
   277f6:	f8d1 5084 	ldr.w	r5, [r1, #132]	; 0x84
   277fa:	605d      	str	r5, [r3, #4]
    NVIC->ICER[1] = __NRF_NVIC_APP_IRQS_1;
   277fc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   27800:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    *p_is_nested_critical_region = 0;
   27804:	7002      	strb	r2, [r0, #0]
  }
  else
  {
    *p_is_nested_critical_region = 1;
  }
  if (!was_masked)
   27806:	b904      	cbnz	r4, 2780a <app_util_critical_region_enter+0x36>
  __ASM volatile ("cpsie i" : : : "memory");
   27808:	b662      	cpsie	i
    /* return value can be safely ignored */
    (void) sd_nvic_critical_region_enter(p_nested);
#else
    app_util_disable_irq();
#endif
}
   2780a:	bc70      	pop	{r4, r5, r6}
   2780c:	4770      	bx	lr
    *p_is_nested_critical_region = 1;
   2780e:	2301      	movs	r3, #1
   27810:	7003      	strb	r3, [r0, #0]
   27812:	e7f8      	b.n	27806 <app_util_critical_region_enter+0x32>
   27814:	2000232c 	.word	0x2000232c
   27818:	e000e100 	.word	0xe000e100
   2781c:	bdff06fc 	.word	0xbdff06fc

00027820 <app_util_critical_region_exit>:
  return NRF_SUCCESS;
}

__STATIC_INLINE uint32_t sd_nvic_critical_region_exit(uint8_t is_nested_critical_region)
{
  if (nrf_nvic_state.__cr_flag && (is_nested_critical_region == 0))
   27820:	4b09      	ldr	r3, [pc, #36]	; (27848 <app_util_critical_region_exit+0x28>)
   27822:	689a      	ldr	r2, [r3, #8]
   27824:	b17a      	cbz	r2, 27846 <app_util_critical_region_exit+0x26>
   27826:	b970      	cbnz	r0, 27846 <app_util_critical_region_exit+0x26>

void app_util_critical_region_exit(uint8_t nested)
{
   27828:	b410      	push	{r4}
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   2782a:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   2782e:	b672      	cpsid	i
  {
    int was_masked = __sd_nvic_irq_disable();
    NVIC->ISER[0] = nrf_nvic_state.__irq_masks[0];
   27830:	4a06      	ldr	r2, [pc, #24]	; (2784c <app_util_critical_region_exit+0x2c>)
   27832:	681c      	ldr	r4, [r3, #0]
   27834:	6014      	str	r4, [r2, #0]
    NVIC->ISER[1] = nrf_nvic_state.__irq_masks[1];
   27836:	685c      	ldr	r4, [r3, #4]
   27838:	6054      	str	r4, [r2, #4]
    nrf_nvic_state.__cr_flag = 0;
   2783a:	6098      	str	r0, [r3, #8]
    if (!was_masked)
   2783c:	b901      	cbnz	r1, 27840 <app_util_critical_region_exit+0x20>
  __ASM volatile ("cpsie i" : : : "memory");
   2783e:	b662      	cpsie	i
    /* return value can be safely ignored */
    (void) sd_nvic_critical_region_exit(nested);
#else
    app_util_enable_irq();
#endif
}
   27840:	f85d 4b04 	ldr.w	r4, [sp], #4
   27844:	4770      	bx	lr
   27846:	4770      	bx	lr
   27848:	2000232c 	.word	0x2000232c
   2784c:	e000e100 	.word	0xe000e100

00027850 <drv_rtc_init>:
#define COUNTER_TO_CC_MIN_DISTANCE 2

ret_code_t drv_rtc_init(drv_rtc_t const * const  p_instance,
                        drv_rtc_config_t const * p_config,
                        drv_rtc_handler_t        handler)
{
   27850:	b470      	push	{r4, r5, r6}

    ret_code_t err_code;

    m_handlers[p_instance->instance_id] = handler;

    if (m_cb[p_instance->instance_id].state != NRFX_DRV_STATE_UNINITIALIZED)
   27852:	4c1c      	ldr	r4, [pc, #112]	; (278c4 <drv_rtc_init+0x74>)
    m_handlers[p_instance->instance_id] = handler;
   27854:	7943      	ldrb	r3, [r0, #5]
   27856:	4e1c      	ldr	r6, [pc, #112]	; (278c8 <drv_rtc_init+0x78>)
    if (m_cb[p_instance->instance_id].state != NRFX_DRV_STATE_UNINITIALIZED)
   27858:	eb04 05c3 	add.w	r5, r4, r3, lsl #3
    m_handlers[p_instance->instance_id] = handler;
   2785c:	f846 2023 	str.w	r2, [r6, r3, lsl #2]
    if (m_cb[p_instance->instance_id].state != NRFX_DRV_STATE_UNINITIALIZED)
   27860:	792d      	ldrb	r5, [r5, #4]
   27862:	bb65      	cbnz	r5, 278be <drv_rtc_init+0x6e>
        err_code = NRF_ERROR_INVALID_STATE;
        NRF_LOG_WARNING("RTC instance already initialized.");
        return err_code;
    }

    nrf_rtc_prescaler_set(p_instance->p_reg, p_config->prescaler);
   27864:	6803      	ldr	r3, [r0, #0]
   27866:	880a      	ldrh	r2, [r1, #0]
}

__STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
   27868:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    NRFX_IRQ_PRIORITY_SET(p_instance->irq, p_config->interrupt_priority);
   2786c:	f990 3004 	ldrsb.w	r3, [r0, #4]
   27870:	788a      	ldrb	r2, [r1, #2]
  if ((int32_t)(IRQn) < 0)
   27872:	2b00      	cmp	r3, #0
   27874:	db1b      	blt.n	278ae <drv_rtc_init+0x5e>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   27876:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   2787a:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
   2787e:	0152      	lsls	r2, r2, #5
   27880:	b2d2      	uxtb	r2, r2
   27882:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    NRFX_IRQ_ENABLE(p_instance->irq);
   27886:	f990 3004 	ldrsb.w	r3, [r0, #4]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   2788a:	4d10      	ldr	r5, [pc, #64]	; (278cc <drv_rtc_init+0x7c>)
   2788c:	f003 021f 	and.w	r2, r3, #31
   27890:	2101      	movs	r1, #1
   27892:	095b      	lsrs	r3, r3, #5
   27894:	fa01 f202 	lsl.w	r2, r1, r2
   27898:	f845 2023 	str.w	r2, [r5, r3, lsl #2]

    m_cb[p_instance->instance_id].state = NRFX_DRV_STATE_INITIALIZED;
   2789c:	7943      	ldrb	r3, [r0, #5]
   2789e:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
    m_cb[p_instance->instance_id].p_instance = p_instance;
   278a2:	f844 0033 	str.w	r0, [r4, r3, lsl #3]
    m_cb[p_instance->instance_id].state = NRFX_DRV_STATE_INITIALIZED;
   278a6:	7111      	strb	r1, [r2, #4]

    err_code = NRF_SUCCESS;
    NRF_LOG_INFO("RTC: initialized.");
    return err_code;
   278a8:	2000      	movs	r0, #0
}
   278aa:	bc70      	pop	{r4, r5, r6}
   278ac:	4770      	bx	lr
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   278ae:	4908      	ldr	r1, [pc, #32]	; (278d0 <drv_rtc_init+0x80>)
   278b0:	f003 030f 	and.w	r3, r3, #15
   278b4:	0152      	lsls	r2, r2, #5
   278b6:	4419      	add	r1, r3
   278b8:	b2d2      	uxtb	r2, r2
   278ba:	760a      	strb	r2, [r1, #24]
   278bc:	e7e3      	b.n	27886 <drv_rtc_init+0x36>
        return err_code;
   278be:	2008      	movs	r0, #8
}
   278c0:	bc70      	pop	{r4, r5, r6}
   278c2:	4770      	bx	lr
   278c4:	2000214c 	.word	0x2000214c
   278c8:	20002154 	.word	0x20002154
   278cc:	e000e100 	.word	0xe000e100
   278d0:	e000ecfc 	.word	0xe000ecfc

000278d4 <drv_rtc_start>:
}

void drv_rtc_start(drv_rtc_t const * const p_instance)
{
    ASSERT(p_instance);
    nrf_rtc_task_trigger(p_instance->p_reg, NRF_RTC_TASK_START);
   278d4:	6803      	ldr	r3, [r0, #0]
    return (uint32_t)p_reg + task;
}

__STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   278d6:	2201      	movs	r2, #1
   278d8:	601a      	str	r2, [r3, #0]
}
   278da:	4770      	bx	lr

000278dc <drv_rtc_stop>:
   278dc:	6803      	ldr	r3, [r0, #0]
   278de:	2201      	movs	r2, #1
   278e0:	605a      	str	r2, [r3, #4]

void drv_rtc_stop(drv_rtc_t const * const p_instance)
{
    ASSERT(p_instance);
    nrf_rtc_task_trigger(p_instance->p_reg, NRF_RTC_TASK_STOP);
}
   278e2:	4770      	bx	lr

000278e4 <drv_rtc_compare_set>:

void drv_rtc_compare_set(drv_rtc_t const * const p_instance,
                         uint32_t                cc,
                         uint32_t                abs_value,
                         bool                    irq_enable)
{
   278e4:	b4f0      	push	{r4, r5, r6, r7}
    ASSERT(p_instance);
    nrf_rtc_int_t   cc_int_mask = (nrf_rtc_int_t)(NRF_RTC_INT_COMPARE0_MASK << cc);
    nrf_rtc_event_t cc_evt      = CC_IDX_TO_CC_EVENT(cc);
    abs_value &= RTC_COUNTER_COUNTER_Msk;

    nrf_rtc_int_disable(p_instance->p_reg, cc_int_mask);
   278e6:	6804      	ldr	r4, [r0, #0]
    nrf_rtc_int_t   cc_int_mask = (nrf_rtc_int_t)(NRF_RTC_INT_COMPARE0_MASK << cc);
   278e8:	f44f 3580 	mov.w	r5, #65536	; 0x10000
   278ec:	408d      	lsls	r5, r1
    p_reg->INTENCLR = mask;
   278ee:	f8c4 5308 	str.w	r5, [r4, #776]	; 0x308
    nrf_rtc_event_disable(p_instance->p_reg, cc_int_mask);
   278f2:	6806      	ldr	r6, [r0, #0]
    nrf_rtc_event_t cc_evt      = CC_IDX_TO_CC_EVENT(cc);
   278f4:	f101 0450 	add.w	r4, r1, #80	; 0x50
    p_reg->EVTENSET = mask;
}

__STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   278f8:	f8c6 5348 	str.w	r5, [r6, #840]	; 0x348
   278fc:	00a4      	lsls	r4, r4, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   278fe:	6806      	ldr	r6, [r0, #0]
   27900:	b2a4      	uxth	r4, r4
   27902:	2700      	movs	r7, #0
   27904:	5137      	str	r7, [r6, r4]
{
   27906:	b082      	sub	sp, #8
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   27908:	5936      	ldr	r6, [r6, r4]
    nrf_rtc_event_clear(p_instance->p_reg, cc_evt);
    nrf_rtc_cc_set(p_instance->p_reg, cc,abs_value);
   2790a:	6804      	ldr	r4, [r0, #0]
   2790c:	9601      	str	r6, [sp, #4]
    p_reg->CC[ch] = cc_val;
   2790e:	f501 71a8 	add.w	r1, r1, #336	; 0x150
    abs_value &= RTC_COUNTER_COUNTER_Msk;
   27912:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    (void)dummy;
   27916:	9e01      	ldr	r6, [sp, #4]
    p_reg->CC[ch] = cc_val;
   27918:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
    nrf_rtc_event_enable(p_instance->p_reg, cc_int_mask);
   2791c:	6802      	ldr	r2, [r0, #0]
    p_reg->EVTENSET = mask;
   2791e:	f8c2 5344 	str.w	r5, [r2, #836]	; 0x344

    if (irq_enable)
   27922:	b113      	cbz	r3, 2792a <drv_rtc_compare_set+0x46>
    {
        nrf_rtc_int_enable(p_instance->p_reg, cc_int_mask);
   27924:	6803      	ldr	r3, [r0, #0]
    p_reg->INTENSET = mask;
   27926:	f8c3 5304 	str.w	r5, [r3, #772]	; 0x304
    }
}
   2792a:	b002      	add	sp, #8
   2792c:	bcf0      	pop	{r4, r5, r6, r7}
   2792e:	4770      	bx	lr

00027930 <drv_rtc_windowed_compare_set>:

ret_code_t drv_rtc_windowed_compare_set(drv_rtc_t const * const p_instance,
                                        uint32_t                cc,
                                        uint32_t                abs_value,
                                        uint32_t                safe_window)
{
   27930:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   27934:	4604      	mov	r4, r0
    ASSERT(p_instance);
    uint32_t        prev_cc_set;
    uint32_t        now;
    uint32_t        diff;
    nrf_rtc_int_t   cc_int_mask = (nrf_rtc_int_t)(NRF_RTC_INT_COMPARE0_MASK << cc);
   27936:	f44f 3680 	mov.w	r6, #65536	; 0x10000
    nrf_rtc_event_disable(p_instance->p_reg, mask);
   2793a:	6800      	ldr	r0, [r0, #0]
    nrf_rtc_int_t   cc_int_mask = (nrf_rtc_int_t)(NRF_RTC_INT_COMPARE0_MASK << cc);
   2793c:	408e      	lsls	r6, r1
    p_reg->EVTENCLR = mask;
   2793e:	f8c0 6348 	str.w	r6, [r0, #840]	; 0x348
    nrf_rtc_int_disable(p_instance->p_reg, mask);
   27942:	6820      	ldr	r0, [r4, #0]
    p_reg->INTENCLR = mask;
   27944:	f8c0 6308 	str.w	r6, [r0, #776]	; 0x308
     * - read previous CC
     * - write current counter value to CC (furtherest in future)
     * - if previous CC was in one tick from now wait half of the 32k tick and clear event which
     *   may be set. Half tick delay is used because CC is latched in the middle of the 32k tick.
     */
    now = nrf_rtc_counter_get(p_instance->p_reg);
   27948:	6820      	ldr	r0, [r4, #0]
   2794a:	eb00 0581 	add.w	r5, r0, r1, lsl #2
{
   2794e:	468a      	mov	sl, r1
     return p_reg->COUNTER;
   27950:	f8d0 1504 	ldr.w	r1, [r0, #1284]	; 0x504
    return p_reg->CC[ch];
   27954:	f8d5 0540 	ldr.w	r0, [r5, #1344]	; 0x540
    p_reg->CC[ch] = cc_val;
   27958:	f8c5 1540 	str.w	r1, [r5, #1344]	; 0x540
    nrf_rtc_event_t cc_evt      = CC_IDX_TO_CC_EVENT(cc);;
   2795c:	f10a 0550 	add.w	r5, sl, #80	; 0x50
   27960:	00ad      	lsls	r5, r5, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   27962:	6827      	ldr	r7, [r4, #0]
   27964:	b2ad      	uxth	r5, r5
   27966:	f04f 0800 	mov.w	r8, #0
   2796a:	f847 8005 	str.w	r8, [r7, r5]
{
   2796e:	b082      	sub	sp, #8
    return (a - b) & RTC_COUNTER_COUNTER_Msk;
   27970:	1a40      	subs	r0, r0, r1
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   27972:	597f      	ldr	r7, [r7, r5]
   27974:	9700      	str	r7, [sp, #0]
   27976:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    prev_cc_set = nrf_rtc_cc_get(p_instance->p_reg, cc);
    nrf_rtc_cc_set(p_instance->p_reg, cc, now);
    nrf_rtc_event_clear(p_instance->p_reg, cc_evt);

    if (ticks_sub(prev_cc_set, now) == 1)
   2797a:	2801      	cmp	r0, #1
    abs_value &=RTC_COUNTER_COUNTER_Msk;
   2797c:	f022 477f 	bic.w	r7, r2, #4278190080	; 0xff000000
{
   27980:	4699      	mov	r9, r3
    (void)dummy;
   27982:	9a00      	ldr	r2, [sp, #0]
    if (ticks_sub(prev_cc_set, now) == 1)
   27984:	d041      	beq.n	27a0a <drv_rtc_windowed_compare_set+0xda>
    {
        nrf_delay_us(16);
        nrf_rtc_event_clear(p_instance->p_reg, cc_evt);
    }

    now = nrf_rtc_counter_get(p_instance->p_reg);
   27986:	6822      	ldr	r2, [r4, #0]
     return p_reg->COUNTER;
   27988:	f8d2 5504 	ldr.w	r5, [r2, #1284]	; 0x504
    p_reg->EVTENSET = mask;
   2798c:	f8c2 6344 	str.w	r6, [r2, #836]	; 0x344
    return (a - b) & RTC_COUNTER_COUNTER_Msk;
   27990:	1b7a      	subs	r2, r7, r5
   27992:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000

    nrf_rtc_event_enable(p_instance->p_reg, cc_int_mask);

    /* Setting CC for +1 from now may not generate event. In that case set CC+2 and check if counter
     * changed during that process. If changed it means that 1 tick expired. */
    if (diff == 1)
   27996:	2a01      	cmp	r2, #1
    p_reg->CC[ch] = cc_val;
   27998:	f50a 71a8 	add.w	r1, sl, #336	; 0x150
   2799c:	d025      	beq.n	279ea <drv_rtc_windowed_compare_set+0xba>
        {
            /* one tick elapsed already. */
            return NRF_ERROR_TIMEOUT;
        }
    } else {
        nrf_rtc_cc_set(p_instance->p_reg, cc, abs_value);
   2799e:	6822      	ldr	r2, [r4, #0]
   279a0:	f842 7021 	str.w	r7, [r2, r1, lsl #2]
        now = nrf_rtc_counter_get(p_instance->p_reg);
   279a4:	6820      	ldr	r0, [r4, #0]
     return p_reg->COUNTER;
   279a6:	f8d0 5504 	ldr.w	r5, [r0, #1284]	; 0x504
    return (a - b) & RTC_COUNTER_COUNTER_Msk;
   279aa:	1b7a      	subs	r2, r7, r5
        diff = ticks_sub(abs_value - 1, now);
        /* Check if counter equals cc value or is behind in the safe window. If yes it means that
         * CC expired. */
        if (diff > (RTC_COUNTER_COUNTER_Msk - safe_window))
   279ac:	f1c9 13ff 	rsb	r3, r9, #16711935	; 0xff00ff
    return (a - b) & RTC_COUNTER_COUNTER_Msk;
   279b0:	3a01      	subs	r2, #1
        if (diff > (RTC_COUNTER_COUNTER_Msk - safe_window))
   279b2:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
    return (a - b) & RTC_COUNTER_COUNTER_Msk;
   279b6:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
        if (diff > (RTC_COUNTER_COUNTER_Msk - safe_window))
   279ba:	4293      	cmp	r3, r2
   279bc:	d311      	bcc.n	279e2 <drv_rtc_windowed_compare_set+0xb2>
        {
            return NRF_ERROR_TIMEOUT;
        }
        else if (diff == 0)
   279be:	b142      	cbz	r2, 279d2 <drv_rtc_windowed_compare_set+0xa2>
    p_reg->EVTENSET = mask;
   279c0:	f8c0 6344 	str.w	r6, [r0, #836]	; 0x344
        nrf_rtc_int_enable(p_instance->p_reg, mask);
   279c4:	6823      	ldr	r3, [r4, #0]
        }
    }

    evt_enable(p_instance, cc_int_mask, true);

    return NRF_SUCCESS;
   279c6:	2000      	movs	r0, #0
    p_reg->INTENSET = mask;
   279c8:	f8c3 6304 	str.w	r6, [r3, #772]	; 0x304
}
   279cc:	b002      	add	sp, #8
   279ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            nrf_rtc_cc_set(p_instance->p_reg, cc, abs_value + 1);
   279d2:	3701      	adds	r7, #1
    p_reg->CC[ch] = cc_val;
   279d4:	f840 7021 	str.w	r7, [r0, r1, lsl #2]
            if (now != nrf_rtc_counter_get(p_instance->p_reg))
   279d8:	6820      	ldr	r0, [r4, #0]
     return p_reg->COUNTER;
   279da:	f8d0 3504 	ldr.w	r3, [r0, #1284]	; 0x504
   279de:	429d      	cmp	r5, r3
   279e0:	d0ee      	beq.n	279c0 <drv_rtc_windowed_compare_set+0x90>
            return NRF_ERROR_TIMEOUT;
   279e2:	200d      	movs	r0, #13
}
   279e4:	b002      	add	sp, #8
   279e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        nrf_rtc_cc_set(p_instance->p_reg, cc, abs_value + 1);
   279ea:	6820      	ldr	r0, [r4, #0]
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   279ec:	4b0d      	ldr	r3, [pc, #52]	; (27a24 <drv_rtc_windowed_compare_set+0xf4>)
   279ee:	3701      	adds	r7, #1
    p_reg->CC[ch] = cc_val;
   279f0:	f840 7021 	str.w	r7, [r0, r1, lsl #2]
   279f4:	f043 0301 	orr.w	r3, r3, #1
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
   279f8:	f44f 6080 	mov.w	r0, #1024	; 0x400
   279fc:	4798      	blx	r3
        if (now != nrf_rtc_counter_get(p_instance->p_reg))
   279fe:	6820      	ldr	r0, [r4, #0]
     return p_reg->COUNTER;
   27a00:	f8d0 3504 	ldr.w	r3, [r0, #1284]	; 0x504
   27a04:	429d      	cmp	r5, r3
   27a06:	d0db      	beq.n	279c0 <drv_rtc_windowed_compare_set+0x90>
   27a08:	e7eb      	b.n	279e2 <drv_rtc_windowed_compare_set+0xb2>
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   27a0a:	4a06      	ldr	r2, [pc, #24]	; (27a24 <drv_rtc_windowed_compare_set+0xf4>)
    delay_cycles(cycles);
   27a0c:	f44f 6080 	mov.w	r0, #1024	; 0x400
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   27a10:	f042 0201 	orr.w	r2, r2, #1
    delay_cycles(cycles);
   27a14:	4790      	blx	r2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   27a16:	6822      	ldr	r2, [r4, #0]
   27a18:	f842 8005 	str.w	r8, [r2, r5]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   27a1c:	5952      	ldr	r2, [r2, r5]
   27a1e:	9201      	str	r2, [sp, #4]
    (void)dummy;
   27a20:	9a01      	ldr	r2, [sp, #4]
}
   27a22:	e7b0      	b.n	27986 <drv_rtc_windowed_compare_set+0x56>
   27a24:	0002bce0 	.word	0x0002bce0

00027a28 <drv_rtc_overflow_enable>:
    nrf_rtc_event_enable(p_instance->p_reg, mask);
   27a28:	6802      	ldr	r2, [r0, #0]
    p_reg->EVTENSET = mask;
   27a2a:	2302      	movs	r3, #2
   27a2c:	f8c2 3344 	str.w	r3, [r2, #836]	; 0x344
    if (irq_enable)
   27a30:	b111      	cbz	r1, 27a38 <drv_rtc_overflow_enable+0x10>
        nrf_rtc_int_enable(p_instance->p_reg, mask);
   27a32:	6802      	ldr	r2, [r0, #0]
    p_reg->INTENSET = mask;
   27a34:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304

void drv_rtc_overflow_enable(drv_rtc_t const * const p_instance, bool irq_enable)
{
    evt_enable(p_instance, NRF_RTC_INT_OVERFLOW_MASK, irq_enable);
}
   27a38:	4770      	bx	lr
   27a3a:	bf00      	nop

00027a3c <drv_rtc_overflow_pending>:
    evt_disable(p_instance, NRF_RTC_INT_OVERFLOW_MASK);
}

bool drv_rtc_overflow_pending(drv_rtc_t const * const p_instance)
{
    return evt_pending(p_instance, NRF_RTC_EVENT_OVERFLOW);
   27a3c:	6803      	ldr	r3, [r0, #0]
    return *(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   27a3e:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
    if (nrf_rtc_event_pending(p_instance->p_reg, event))
   27a42:	b900      	cbnz	r0, 27a46 <drv_rtc_overflow_pending+0xa>
}
   27a44:	4770      	bx	lr
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   27a46:	2200      	movs	r2, #0
{
   27a48:	b082      	sub	sp, #8
   27a4a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   27a4e:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   27a52:	9301      	str	r3, [sp, #4]
    (void)dummy;
   27a54:	9b01      	ldr	r3, [sp, #4]
        return true;
   27a56:	2001      	movs	r0, #1
}
   27a58:	b002      	add	sp, #8
   27a5a:	4770      	bx	lr

00027a5c <drv_rtc_compare_disable>:
    nrf_rtc_event_disable(p_instance->p_reg, mask);
   27a5c:	6802      	ldr	r2, [r0, #0]
    evt_enable(p_instance, (uint32_t)NRF_RTC_INT_COMPARE0_MASK << cc, irq_enable);
}

void drv_rtc_compare_disable(drv_rtc_t const * const p_instance, uint32_t cc)
{
    evt_disable(p_instance, (uint32_t)NRF_RTC_INT_COMPARE0_MASK << cc);
   27a5e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   27a62:	fa03 f101 	lsl.w	r1, r3, r1
    p_reg->EVTENCLR = mask;
   27a66:	f8c2 1348 	str.w	r1, [r2, #840]	; 0x348
    nrf_rtc_int_disable(p_instance->p_reg, mask);
   27a6a:	6803      	ldr	r3, [r0, #0]
    p_reg->INTENCLR = mask;
   27a6c:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
}
   27a70:	4770      	bx	lr
   27a72:	bf00      	nop

00027a74 <drv_rtc_compare_pending>:

bool drv_rtc_compare_pending(drv_rtc_t const * const p_instance, uint32_t cc)
{
    nrf_rtc_event_t cc_evt = CC_IDX_TO_CC_EVENT(cc);
   27a74:	3150      	adds	r1, #80	; 0x50
   27a76:	0089      	lsls	r1, r1, #2
    return *(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   27a78:	6803      	ldr	r3, [r0, #0]
   27a7a:	b289      	uxth	r1, r1
   27a7c:	5858      	ldr	r0, [r3, r1]
    if (nrf_rtc_event_pending(p_instance->p_reg, event))
   27a7e:	b900      	cbnz	r0, 27a82 <drv_rtc_compare_pending+0xe>
    return evt_pending(p_instance, cc_evt);
}
   27a80:	4770      	bx	lr
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   27a82:	2200      	movs	r2, #0
   27a84:	505a      	str	r2, [r3, r1]
{
   27a86:	b082      	sub	sp, #8
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   27a88:	585b      	ldr	r3, [r3, r1]
   27a8a:	9301      	str	r3, [sp, #4]
    (void)dummy;
   27a8c:	9b01      	ldr	r3, [sp, #4]
        return true;
   27a8e:	2001      	movs	r0, #1
}
   27a90:	b002      	add	sp, #8
   27a92:	4770      	bx	lr

00027a94 <drv_rtc_counter_get>:

uint32_t drv_rtc_counter_get(drv_rtc_t const * const p_instance)
{
    return nrf_rtc_counter_get(p_instance->p_reg);
   27a94:	6803      	ldr	r3, [r0, #0]
     return p_reg->COUNTER;
   27a96:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
}
   27a9a:	4770      	bx	lr

00027a9c <drv_rtc_irq_trigger>:

void drv_rtc_irq_trigger(drv_rtc_t const * const p_instance)
{
    NVIC_SetPendingIRQ(p_instance->irq);
   27a9c:	f990 3004 	ldrsb.w	r3, [r0, #4]
  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   27aa0:	4805      	ldr	r0, [pc, #20]	; (27ab8 <drv_rtc_irq_trigger+0x1c>)
   27aa2:	095a      	lsrs	r2, r3, #5
   27aa4:	2101      	movs	r1, #1
   27aa6:	3240      	adds	r2, #64	; 0x40
   27aa8:	f003 031f 	and.w	r3, r3, #31
   27aac:	fa01 f303 	lsl.w	r3, r1, r3
   27ab0:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
}
   27ab4:	4770      	bx	lr
   27ab6:	bf00      	nop
   27ab8:	e000e100 	.word	0xe000e100

00027abc <RTC1_IRQHandler>:
#endif

#if defined(APP_TIMER_V2_RTC1_ENABLED)
void drv_rtc_rtc_1_irq_handler(void)
{
    m_handlers[DRV_RTC_RTC1_INST_IDX](m_cb[DRV_RTC_RTC1_INST_IDX].p_instance);
   27abc:	4a02      	ldr	r2, [pc, #8]	; (27ac8 <RTC1_IRQHandler+0xc>)
   27abe:	4b03      	ldr	r3, [pc, #12]	; (27acc <RTC1_IRQHandler+0x10>)
   27ac0:	6810      	ldr	r0, [r2, #0]
   27ac2:	681b      	ldr	r3, [r3, #0]
   27ac4:	4718      	bx	r3
   27ac6:	bf00      	nop
   27ac8:	2000214c 	.word	0x2000214c
   27acc:	20002154 	.word	0x20002154

00027ad0 <nrf_atfifo_init>:
STATIC_ASSERT(sizeof(nrf_atfifo_postag_t) == sizeof(uint32_t));


ret_code_t nrf_atfifo_init(nrf_atfifo_t * const p_fifo, void * p_buf, uint16_t buf_size, uint16_t item_size)
{
    if (NULL == p_buf)
   27ad0:	b199      	cbz	r1, 27afa <nrf_atfifo_init+0x2a>
{
   27ad2:	b410      	push	{r4}
    {
        NRF_LOG_INST_ERROR(p_fifo->p_log, "Initialization failed. p_buf == NULL");
        return NRF_ERROR_NULL;
    }
    if (0 != (buf_size % item_size))
   27ad4:	fbb2 f4f3 	udiv	r4, r2, r3
   27ad8:	fb03 2414 	mls	r4, r3, r4, r2
   27adc:	b2a4      	uxth	r4, r4
   27ade:	b944      	cbnz	r4, 27af2 <nrf_atfifo_init+0x22>
        NRF_LOG_INST_ERROR(p_fifo->p_log, "Initialization failed. Buf_size not multiple of item_size");
        return NRF_ERROR_INVALID_LENGTH;
    }

    p_fifo->p_buf     = p_buf;
    p_fifo->tail.tag  = 0;
   27ae0:	e9c0 1400 	strd	r1, r4, [r0]
    p_fifo->head.tag  = 0;
   27ae4:	6084      	str	r4, [r0, #8]
    p_fifo->buf_size  = buf_size;
   27ae6:	8182      	strh	r2, [r0, #12]
    p_fifo->item_size = item_size;
   27ae8:	81c3      	strh	r3, [r0, #14]

    NRF_LOG_INST_INFO(p_fifo->p_log, "Initialized.");
    return NRF_SUCCESS;
   27aea:	4620      	mov	r0, r4
}
   27aec:	f85d 4b04 	ldr.w	r4, [sp], #4
   27af0:	4770      	bx	lr
        return NRF_ERROR_INVALID_LENGTH;
   27af2:	2009      	movs	r0, #9
}
   27af4:	f85d 4b04 	ldr.w	r4, [sp], #4
   27af8:	4770      	bx	lr
        return NRF_ERROR_NULL;
   27afa:	200e      	movs	r0, #14
}
   27afc:	4770      	bx	lr
   27afe:	bf00      	nop

00027b00 <nrf_atfifo_item_alloc>:
    return NRF_SUCCESS;
}


void * nrf_atfifo_item_alloc(nrf_atfifo_t * const p_fifo, nrf_atfifo_item_put_t * p_context)
{
   27b00:	b430      	push	{r4, r5}
   27b02:	b082      	sub	sp, #8
    volatile bool ret;
    volatile uint32_t old_tail;
    uint32_t new_tail;
    uint32_t temp;

    __ASM volatile(
   27b04:	e850 3f01 	ldrex	r3, [r0, #4]
   27b08:	b29d      	uxth	r5, r3
   27b0a:	89c4      	ldrh	r4, [r0, #14]
   27b0c:	4425      	add	r5, r4
   27b0e:	8984      	ldrh	r4, [r0, #12]
   27b10:	42a5      	cmp	r5, r4
   27b12:	bf28      	it	cs
   27b14:	1b2d      	subcs	r5, r5, r4
   27b16:	8904      	ldrh	r4, [r0, #8]
   27b18:	42a5      	cmp	r5, r4
   27b1a:	bf02      	ittt	eq
   27b1c:	f3bf 8f2f 	clrexeq
   27b20:	2200      	moveq	r2, #0
   27b22:	e007      	beq.n	27b34 <nrf_atfifo_item_alloc+0x34>
   27b24:	eac5 0503 	pkhbt	r5, r5, r3
   27b28:	e840 5401 	strex	r4, r5, [r0, #4]
   27b2c:	2c00      	cmp	r4, #0
   27b2e:	d1e9      	bne.n	27b04 <nrf_atfifo_item_alloc+0x4>
   27b30:	f04f 0201 	mov.w	r2, #1
   27b34:	f88d 2003 	strb.w	r2, [sp, #3]
   27b38:	9301      	str	r3, [sp, #4]
            [true_val]        "I"(true),
            [false_val]       "I"(false)
        : /* Clobbers */
            "cc");

    p_old_tail->tag = old_tail;
   27b3a:	9b01      	ldr	r3, [sp, #4]
    UNUSED_VARIABLE(new_tail);
    UNUSED_VARIABLE(temp);
    return ret;
   27b3c:	f89d 2003 	ldrb.w	r2, [sp, #3]
    p_old_tail->tag = old_tail;
   27b40:	600b      	str	r3, [r1, #0]
    if (nrf_atfifo_wspace_req(p_fifo, &(p_context->last_tail)))
   27b42:	b12a      	cbz	r2, 27b50 <nrf_atfifo_item_alloc+0x50>
    {
        void * p_item = ((uint8_t*)(p_fifo->p_buf)) + p_context->last_tail.pos.wr;
   27b44:	880b      	ldrh	r3, [r1, #0]
   27b46:	6800      	ldr	r0, [r0, #0]
   27b48:	4418      	add	r0, r3
        NRF_LOG_INST_DEBUG(p_fifo->p_log, "Allocated  element (0x%08X).", p_item);
        return p_item;
    }
    NRF_LOG_INST_WARNING(p_fifo->p_log, "Allocation failed - no space.");
    return NULL;
}
   27b4a:	b002      	add	sp, #8
   27b4c:	bc30      	pop	{r4, r5}
   27b4e:	4770      	bx	lr
   27b50:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    return NULL;
   27b54:	4618      	mov	r0, r3
}
   27b56:	b002      	add	sp, #8
   27b58:	bc30      	pop	{r4, r5}
   27b5a:	4770      	bx	lr

00027b5c <nrf_atfifo_item_put>:


bool nrf_atfifo_item_put(nrf_atfifo_t * const p_fifo, nrf_atfifo_item_put_t * p_context)
{
    if ((p_context->last_tail.pos.wr) == (p_context->last_tail.pos.rd))
   27b5c:	880a      	ldrh	r2, [r1, #0]
   27b5e:	884b      	ldrh	r3, [r1, #2]
   27b60:	429a      	cmp	r2, r3
   27b62:	d001      	beq.n	27b68 <nrf_atfifo_item_put+0xc>
        NRF_LOG_INST_DEBUG(p_fifo->p_log, "Put (uninterrupted)");
        nrf_atfifo_wspace_close(p_fifo);
        return true;
    }
    NRF_LOG_INST_DEBUG(p_fifo->p_log, "Put (interrupted!)");
    return false;
   27b64:	2000      	movs	r0, #0
}
   27b66:	4770      	bx	lr
void nrf_atfifo_wspace_close(nrf_atfifo_t * const p_fifo)
{
    uint32_t temp;
    uint32_t new_tail;

    __ASM volatile(
   27b68:	e850 2f01 	ldrex	r2, [r0, #4]
   27b6c:	eac2 4202 	pkhbt	r2, r2, r2, lsl #16
   27b70:	e840 2301 	strex	r3, r2, [r0, #4]
   27b74:	2b00      	cmp	r3, #0
   27b76:	d1f7      	bne.n	27b68 <nrf_atfifo_item_put+0xc>
   27b78:	2001      	movs	r0, #1
   27b7a:	4770      	bx	lr

00027b7c <nrf_atfifo_item_get>:
    return NRF_SUCCESS;
}


void * nrf_atfifo_item_get(nrf_atfifo_t * const p_fifo, nrf_atfifo_item_get_t * p_context)
{
   27b7c:	b430      	push	{r4, r5}
   27b7e:	b082      	sub	sp, #8
    volatile bool ret;
    volatile uint32_t old_head;
    uint32_t new_head;
    uint32_t temp;

    __ASM volatile(
   27b80:	e850 3f02 	ldrex	r3, [r0, #8]
   27b84:	fa1f f5a3 	uxth.w	r5, r3, ror #16
   27b88:	88c4      	ldrh	r4, [r0, #6]
   27b8a:	42a5      	cmp	r5, r4
   27b8c:	bf02      	ittt	eq
   27b8e:	f3bf 8f2f 	clrexeq
   27b92:	2200      	moveq	r2, #0
   27b94:	e00d      	beq.n	27bb2 <nrf_atfifo_item_get+0x36>
   27b96:	89c4      	ldrh	r4, [r0, #14]
   27b98:	4425      	add	r5, r4
   27b9a:	8984      	ldrh	r4, [r0, #12]
   27b9c:	42a5      	cmp	r5, r4
   27b9e:	bf28      	it	cs
   27ba0:	1b2d      	subcs	r5, r5, r4
   27ba2:	eac3 4505 	pkhbt	r5, r3, r5, lsl #16
   27ba6:	e840 5402 	strex	r4, r5, [r0, #8]
   27baa:	2c00      	cmp	r4, #0
   27bac:	d1e8      	bne.n	27b80 <nrf_atfifo_item_get+0x4>
   27bae:	f04f 0201 	mov.w	r2, #1
   27bb2:	f88d 2003 	strb.w	r2, [sp, #3]
   27bb6:	9301      	str	r3, [sp, #4]
            [true_val]        "I"(true),
            [false_val]       "I"(false)
        : /* Clobbers */
            "cc");

    p_old_head->tag = old_head;
   27bb8:	9b01      	ldr	r3, [sp, #4]
    UNUSED_VARIABLE(new_head);
    UNUSED_VARIABLE(temp);
    return ret;
   27bba:	f89d 2003 	ldrb.w	r2, [sp, #3]
    p_old_head->tag = old_head;
   27bbe:	600b      	str	r3, [r1, #0]
    if (nrf_atfifo_rspace_req(p_fifo, &(p_context->last_head)))
   27bc0:	b12a      	cbz	r2, 27bce <nrf_atfifo_item_get+0x52>
    {
        void * p_item = ((uint8_t*)(p_fifo->p_buf)) + p_context->last_head.pos.rd;
   27bc2:	884b      	ldrh	r3, [r1, #2]
   27bc4:	6800      	ldr	r0, [r0, #0]
   27bc6:	4418      	add	r0, r3
        NRF_LOG_INST_DEBUG(p_fifo->p_log, "Get element: 0x%08X", p_item);
        return p_item;
    }
    NRF_LOG_INST_WARNING(p_fifo->p_log, "Get failed - no item in the FIFO.");
    return NULL;
}
   27bc8:	b002      	add	sp, #8
   27bca:	bc30      	pop	{r4, r5}
   27bcc:	4770      	bx	lr
   27bce:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    return NULL;
   27bd2:	4618      	mov	r0, r3
}
   27bd4:	b002      	add	sp, #8
   27bd6:	bc30      	pop	{r4, r5}
   27bd8:	4770      	bx	lr
   27bda:	bf00      	nop

00027bdc <nrf_atfifo_item_free>:


bool nrf_atfifo_item_free(nrf_atfifo_t * const p_fifo, nrf_atfifo_item_get_t * p_context)
{
    if ((p_context->last_head.pos.wr) == (p_context->last_head.pos.rd))
   27bdc:	880a      	ldrh	r2, [r1, #0]
   27bde:	884b      	ldrh	r3, [r1, #2]
   27be0:	429a      	cmp	r2, r3
   27be2:	d001      	beq.n	27be8 <nrf_atfifo_item_free+0xc>
        NRF_LOG_INST_DEBUG(p_fifo->p_log, "Free (uninterrupted)");
        nrf_atfifo_rspace_close(p_fifo);
        return true;
    }
    NRF_LOG_INST_DEBUG(p_fifo->p_log, "Free (interrupted)");
    return false;
   27be4:	2000      	movs	r0, #0
}
   27be6:	4770      	bx	lr
void nrf_atfifo_rspace_close(nrf_atfifo_t * const p_fifo)
{
    uint32_t temp;
    uint32_t new_head;

    __ASM volatile(
   27be8:	e850 2f02 	ldrex	r2, [r0, #8]
   27bec:	eac2 4222 	pkhtb	r2, r2, r2, asr #16
   27bf0:	e840 2302 	strex	r3, r2, [r0, #8]
   27bf4:	2b00      	cmp	r3, #0
   27bf6:	d1f7      	bne.n	27be8 <nrf_atfifo_item_free+0xc>
   27bf8:	2001      	movs	r0, #1
   27bfa:	4770      	bx	lr

00027bfc <sd_app_evt_wait>:
 *
 * @post An application interrupt has happened or a interrupt pending flag is set.
 *
 * @retval ::NRF_SUCCESS
 */
SVCALL(SD_APP_EVT_WAIT, uint32_t, sd_app_evt_wait(void));
   27bfc:	df41      	svc	65	; 0x41
   27bfe:	4770      	bx	lr

00027c00 <nrf_pwr_mgmt_init>:

ret_code_t nrf_pwr_mgmt_init(void)
{
    NRF_LOG_INFO("Init");

    m_shutdown_started = false;
   27c00:	4a06      	ldr	r2, [pc, #24]	; (27c1c <nrf_pwr_mgmt_init+0x1c>)

__STATIC_INLINE void nrf_mtx_init(nrf_mtx_t * p_mtx)
{
    ASSERT(p_mtx  != NULL);

    *p_mtx = NRF_MTX_UNLOCKED;
   27c02:	4b07      	ldr	r3, [pc, #28]	; (27c20 <nrf_pwr_mgmt_init+0x20>)
{
   27c04:	b510      	push	{r4, lr}
    m_shutdown_started = false;
   27c06:	2400      	movs	r4, #0
   27c08:	7014      	strb	r4, [r2, #0]
   27c0a:	601c      	str	r4, [r3, #0]
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
   27c0c:	f3bf 8f5f 	dmb	sy
    nrf_mtx_init(&m_sysoff_mtx);
    nrf_section_iter_init(&m_handlers_iter, &pwr_mgmt_data);
   27c10:	4904      	ldr	r1, [pc, #16]	; (27c24 <nrf_pwr_mgmt_init+0x24>)
   27c12:	4805      	ldr	r0, [pc, #20]	; (27c28 <nrf_pwr_mgmt_init+0x28>)
   27c14:	f000 f834 	bl	27c80 <nrf_section_iter_init>
    PWR_MGMT_DEBUG_PINS_INIT();
    PWR_MGMT_STANDBY_TIMEOUT_INIT();
    PWR_MGMT_CPU_USAGE_MONITOR_INIT();

    return PWR_MGMT_TIMER_CREATE();
}
   27c18:	4620      	mov	r0, r4
   27c1a:	bd10      	pop	{r4, pc}
   27c1c:	20002160 	.word	0x20002160
   27c20:	20002164 	.word	0x20002164
   27c24:	0002bce8 	.word	0x0002bce8
   27c28:	20002158 	.word	0x20002158

00027c2c <nrf_pwr_mgmt_run>:

void nrf_pwr_mgmt_run(void)
{
   27c2c:	b500      	push	{lr}
   27c2e:	b083      	sub	sp, #12
        CRITICAL_REGION_ENTER();
   27c30:	2300      	movs	r3, #0
   27c32:	f10d 0007 	add.w	r0, sp, #7
   27c36:	f88d 3007 	strb.w	r3, [sp, #7]
   27c3a:	f7ff fdcb 	bl	277d4 <app_util_critical_region_enter>
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
   27c3e:	eef1 3a10 	vmrs	r3, fpscr
        __set_FPSCR(original_fpscr & ~0x9Fu);
   27c42:	f023 039f 	bic.w	r3, r3, #159	; 0x9f
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
   27c46:	eee1 3a10 	vmsr	fpscr, r3
  __ASM volatile ("dmb 0xF":::"memory");
   27c4a:	f3bf 8f5f 	dmb	sy
  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   27c4e:	4b0b      	ldr	r3, [pc, #44]	; (27c7c <nrf_pwr_mgmt_run+0x50>)
   27c50:	2240      	movs	r2, #64	; 0x40
   27c52:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
        CRITICAL_REGION_EXIT();
   27c56:	f89d 0007 	ldrb.w	r0, [sp, #7]
   27c5a:	f7ff fde1 	bl	27820 <app_util_critical_region_exit>
    PWR_MGMT_CPU_USAGE_MONITOR_SECTION_ENTER();
    PWR_MGMT_DEBUG_PIN_SET();

    // Wait for an event.
#ifdef SOFTDEVICE_PRESENT
    if (nrf_sdh_is_enabled())
   27c5e:	f001 fd2f 	bl	296c0 <nrf_sdh_is_enabled>
   27c62:	b928      	cbnz	r0, 27c70 <nrf_pwr_mgmt_run+0x44>
  __ASM volatile ("wfe");
   27c64:	bf20      	wfe
  __ASM volatile ("sev");
   27c66:	bf40      	sev
  __ASM volatile ("wfe");
   27c68:	bf20      	wfe
    }

    PWR_MGMT_DEBUG_PIN_CLEAR();
    PWR_MGMT_CPU_USAGE_MONITOR_SECTION_EXIT();
    PWR_MGMT_SLEEP_LOCK_RELEASE();
}
   27c6a:	b003      	add	sp, #12
   27c6c:	f85d fb04 	ldr.w	pc, [sp], #4
        ret_code_t ret_code = sd_app_evt_wait();
   27c70:	f7ff ffc4 	bl	27bfc <sd_app_evt_wait>
}
   27c74:	b003      	add	sp, #12
   27c76:	f85d fb04 	ldr.w	pc, [sp], #4
   27c7a:	bf00      	nop
   27c7c:	e000e100 	.word	0xe000e100

00027c80 <nrf_section_iter_init>:
void nrf_section_iter_init(nrf_section_iter_t * p_iter, nrf_section_set_t const * p_set)
{
    ASSERT(p_iter != NULL);
    ASSERT(p_set  != NULL);

    p_iter->p_set = p_set;
   27c80:	6001      	str	r1, [r0, #0]

#if defined(__GNUC__)
    p_iter->p_item = p_iter->p_set->section.p_start;
   27c82:	680b      	ldr	r3, [r1, #0]
   27c84:	6043      	str	r3, [r0, #4]
    if (p_iter->p_item == p_iter->p_set->section.p_end)
   27c86:	684a      	ldr	r2, [r1, #4]
   27c88:	4293      	cmp	r3, r2
    {
        p_iter->p_item = NULL;
   27c8a:	bf04      	itt	eq
   27c8c:	2300      	moveq	r3, #0
   27c8e:	6043      	streq	r3, [r0, #4]
    }
#else
    p_iter->p_section = p_set->p_first;
    nrf_section_iter_item_set(p_iter);
#endif
}
   27c90:	4770      	bx	lr
   27c92:	bf00      	nop

00027c94 <nrf_section_iter_next>:
void nrf_section_iter_next(nrf_section_iter_t * p_iter)
{
    ASSERT(p_iter        != NULL);
    ASSERT(p_iter->p_set != NULL);

    if (p_iter->p_item == NULL)
   27c94:	6843      	ldr	r3, [r0, #4]
   27c96:	b143      	cbz	r3, 27caa <nrf_section_iter_next+0x16>
    {
        return;
    }

    p_iter->p_item = (void *)((size_t)(p_iter->p_item) + p_iter->p_set->item_size);
   27c98:	6802      	ldr	r2, [r0, #0]
   27c9a:	6891      	ldr	r1, [r2, #8]
   27c9c:	440b      	add	r3, r1
   27c9e:	6043      	str	r3, [r0, #4]

#if defined(__GNUC__)
    if (p_iter->p_item == p_iter->p_set->section.p_end)
   27ca0:	6852      	ldr	r2, [r2, #4]
   27ca2:	4293      	cmp	r3, r2
    {
        p_iter->p_item = NULL;
   27ca4:	bf04      	itt	eq
   27ca6:	2300      	moveq	r3, #0
   27ca8:	6043      	streq	r3, [r0, #4]
    {
        p_iter->p_section++;
        nrf_section_iter_item_set(p_iter);
    }
#endif
}
   27caa:	4770      	bx	lr

00027cac <nrf_sortlist_add>:
#endif // NRF_SORTLIST_CONFIG_LOG_ENABLED
#include "nrf_log.h"
NRF_LOG_MODULE_REGISTER();

void nrf_sortlist_add(nrf_sortlist_t const * p_list, nrf_sortlist_item_t * p_item)
{
   27cac:	b570      	push	{r4, r5, r6, lr}
    ASSERT(p_list);
    ASSERT(p_item);

    nrf_sortlist_item_t ** pp_curr = &(p_list->p_cb->p_head);
   27cae:	6844      	ldr	r4, [r0, #4]
{
   27cb0:	4606      	mov	r6, r0

    while(*pp_curr != NULL)
   27cb2:	6820      	ldr	r0, [r4, #0]
{
   27cb4:	460d      	mov	r5, r1
    while(*pp_curr != NULL)
   27cb6:	b918      	cbnz	r0, 27cc0 <nrf_sortlist_add+0x14>
   27cb8:	e008      	b.n	27ccc <nrf_sortlist_add+0x20>
    {
        if(!(p_list->compare_func(*pp_curr, p_item)))
        {
            break;
        }
        pp_curr = &((*pp_curr)->p_next);
   27cba:	6824      	ldr	r4, [r4, #0]
    while(*pp_curr != NULL)
   27cbc:	6820      	ldr	r0, [r4, #0]
   27cbe:	b128      	cbz	r0, 27ccc <nrf_sortlist_add+0x20>
        if(!(p_list->compare_func(*pp_curr, p_item)))
   27cc0:	68b3      	ldr	r3, [r6, #8]
   27cc2:	4629      	mov	r1, r5
   27cc4:	4798      	blx	r3
   27cc6:	2800      	cmp	r0, #0
   27cc8:	d1f7      	bne.n	27cba <nrf_sortlist_add+0xe>
   27cca:	6820      	ldr	r0, [r4, #0]
    }

    p_item->p_next = *pp_curr;
   27ccc:	6028      	str	r0, [r5, #0]
    *pp_curr = p_item;
   27cce:	6025      	str	r5, [r4, #0]

    NRF_LOG_INFO("List:%s, adding element:%08X after:%08X, before:%08X",
                                  p_list->p_name, p_item, *pp_curr, p_item->p_next);
}
   27cd0:	bd70      	pop	{r4, r5, r6, pc}
   27cd2:	bf00      	nop

00027cd4 <nrf_sortlist_pop>:

nrf_sortlist_item_t * nrf_sortlist_pop(nrf_sortlist_t const * p_list)
{
    ASSERT(p_list);
    nrf_sortlist_item_t * ret = p_list->p_cb->p_head;
   27cd4:	6843      	ldr	r3, [r0, #4]
   27cd6:	6818      	ldr	r0, [r3, #0]
    if (p_list->p_cb->p_head != NULL)
   27cd8:	b108      	cbz	r0, 27cde <nrf_sortlist_pop+0xa>
    {
        p_list->p_cb->p_head = p_list->p_cb->p_head->p_next;
   27cda:	6802      	ldr	r2, [r0, #0]
   27cdc:	601a      	str	r2, [r3, #0]
    }
    NRF_LOG_INFO("List:%s, poping element:%08X", p_list->p_name, ret);
    return ret;
}
   27cde:	4770      	bx	lr

00027ce0 <nrf_sortlist_peek>:

nrf_sortlist_item_t const * nrf_sortlist_peek(nrf_sortlist_t const * p_list)
{
    ASSERT(p_list);
    return p_list->p_cb->p_head;
   27ce0:	6843      	ldr	r3, [r0, #4]
}
   27ce2:	6818      	ldr	r0, [r3, #0]
   27ce4:	4770      	bx	lr
   27ce6:	bf00      	nop

00027ce8 <nrf_sortlist_remove>:
{
    ASSERT(p_list);
    ASSERT(p_item);
    bool ret = false;

    nrf_sortlist_item_t ** pp_curr = &(p_list->p_cb->p_head);
   27ce8:	6843      	ldr	r3, [r0, #4]
   27cea:	6818      	ldr	r0, [r3, #0]

    while(*pp_curr != NULL)
   27cec:	b918      	cbnz	r0, 27cf6 <nrf_sortlist_remove+0xe>
   27cee:	e008      	b.n	27d02 <nrf_sortlist_remove+0x1a>
        {
            *pp_curr = p_item->p_next;
            ret = true;
            break;
        }
        pp_curr = &((*pp_curr)->p_next);
   27cf0:	4603      	mov	r3, r0
   27cf2:	6800      	ldr	r0, [r0, #0]
    while(*pp_curr != NULL)
   27cf4:	b128      	cbz	r0, 27d02 <nrf_sortlist_remove+0x1a>
        if(*pp_curr == p_item)
   27cf6:	4281      	cmp	r1, r0
   27cf8:	d1fa      	bne.n	27cf0 <nrf_sortlist_remove+0x8>
            *pp_curr = p_item->p_next;
   27cfa:	680a      	ldr	r2, [r1, #0]
   27cfc:	601a      	str	r2, [r3, #0]
            ret = true;
   27cfe:	2001      	movs	r0, #1
            break;
   27d00:	4770      	bx	lr
    }

    NRF_LOG_INFO("List:%s, removing element:%08X %s",
                                  p_list->p_name, p_item, ret ? "succeeded" : "not found");
    return ret;
}
   27d02:	4770      	bx	lr

00027d04 <SystemInit>:
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
}

void SystemInit(void)
{
   27d04:	b410      	push	{r4}
    #endif
    
    /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_36()){
        NRF_CLOCK->EVENTS_DONE = 0;
   27d06:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    }
    
    /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_66()){
        NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
   27d0a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
        NRF_CLOCK->EVENTS_DONE = 0;
   27d0e:	2000      	movs	r0, #0
   27d10:	f8c1 010c 	str.w	r0, [r1, #268]	; 0x10c
        NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
   27d14:	4b5e      	ldr	r3, [pc, #376]	; (27e90 <SystemInit+0x18c>)
        NRF_CLOCK->EVENTS_CTTO = 0;
   27d16:	f8c1 0110 	str.w	r0, [r1, #272]	; 0x110
        NRF_CLOCK->CTIV = 0;
   27d1a:	f8c1 0538 	str.w	r0, [r1, #1336]	; 0x538
        NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
   27d1e:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
   27d22:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
        NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
   27d26:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
   27d2a:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
        NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
   27d2e:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
   27d32:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
        NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
   27d36:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
   27d3a:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
        NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
   27d3e:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
   27d42:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
        NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
   27d46:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
   27d4a:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
        NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
   27d4e:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
   27d52:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
        NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
   27d56:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
   27d5a:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
        NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
   27d5e:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
   27d62:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
        NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
   27d66:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
   27d6a:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
        NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
   27d6e:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
   27d72:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
        NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
   27d76:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
   27d7a:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
        NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
   27d7e:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
   27d82:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
        NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
   27d86:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
   27d8a:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
        NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
   27d8e:	f8d2 043c 	ldr.w	r0, [r2, #1084]	; 0x43c
   27d92:	f8c3 0568 	str.w	r0, [r3, #1384]	; 0x568
        NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
   27d96:	f8d2 0440 	ldr.w	r0, [r2, #1088]	; 0x440
}


static bool errata_98(void)
{
    if (*(uint32_t *)0x10000130ul == 0x8ul){
   27d9a:	493e      	ldr	r1, [pc, #248]	; (27e94 <SystemInit+0x190>)
        NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
   27d9c:	f8c3 056c 	str.w	r0, [r3, #1388]	; 0x56c
    if (*(uint32_t *)0x10000130ul == 0x8ul){
   27da0:	6809      	ldr	r1, [r1, #0]
        NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
   27da2:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
   27da6:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    if (*(uint32_t *)0x10000130ul == 0x8ul){
   27daa:	2908      	cmp	r1, #8
   27dac:	d024      	beq.n	27df8 <SystemInit+0xf4>
        if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
   27dae:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   27db2:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
   27db6:	07d2      	lsls	r2, r2, #31
            NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
   27db8:	bf44      	itt	mi
   27dba:	f06f 0201 	mvnmi.w	r2, #1
   27dbe:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400
        SCB->CPACR |= (3UL << 20) | (3UL << 22);
   27dc2:	4a35      	ldr	r2, [pc, #212]	; (27e98 <SystemInit+0x194>)
   27dc4:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
   27dc8:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
   27dcc:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
   27dd0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   27dd4:	f3bf 8f6f 	isb	sy
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
   27dd8:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   27ddc:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   27de0:	2a00      	cmp	r2, #0
   27de2:	db23      	blt.n	27e2c <SystemInit+0x128>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
   27de4:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
   27de8:	2b00      	cmp	r3, #0
   27dea:	db1f      	blt.n	27e2c <SystemInit+0x128>
    SystemCoreClock = __SYSTEM_CLOCK_64M;
   27dec:	4b2b      	ldr	r3, [pc, #172]	; (27e9c <SystemInit+0x198>)
   27dee:	4a2c      	ldr	r2, [pc, #176]	; (27ea0 <SystemInit+0x19c>)
   27df0:	601a      	str	r2, [r3, #0]
}
   27df2:	f85d 4b04 	ldr.w	r4, [sp], #4
   27df6:	4770      	bx	lr
        if (*(uint32_t *)0x10000134ul == 0x0ul){
   27df8:	4b2a      	ldr	r3, [pc, #168]	; (27ea4 <SystemInit+0x1a0>)
   27dfa:	681b      	ldr	r3, [r3, #0]
   27dfc:	2b00      	cmp	r3, #0
   27dfe:	d1d6      	bne.n	27dae <SystemInit+0xaa>
        *(volatile uint32_t *)0x4000568Cul = 0x00038148ul;
   27e00:	4829      	ldr	r0, [pc, #164]	; (27ea8 <SystemInit+0x1a4>)
        NRF_CCM->MAXPACKETSIZE = 0xFBul;
   27e02:	4a2a      	ldr	r2, [pc, #168]	; (27eac <SystemInit+0x1a8>)
        *(volatile uint32_t *)0x4000568Cul = 0x00038148ul;
   27e04:	4c2a      	ldr	r4, [pc, #168]	; (27eb0 <SystemInit+0x1ac>)
   27e06:	6004      	str	r4, [r0, #0]
        *(volatile uint32_t *)0x40000EE4ul = (*(volatile uint32_t *)0x40000EE4ul & 0xFFFFFFF0ul) | (*(uint32_t *)0x10000258ul & 0x0000000Ful);
   27e08:	492a      	ldr	r1, [pc, #168]	; (27eb4 <SystemInit+0x1b0>)
   27e0a:	4b2b      	ldr	r3, [pc, #172]	; (27eb8 <SystemInit+0x1b4>)
        NRF_CCM->MAXPACKETSIZE = 0xFBul;
   27e0c:	20fb      	movs	r0, #251	; 0xfb
   27e0e:	f8c2 0518 	str.w	r0, [r2, #1304]	; 0x518
        *(volatile uint32_t *)0x40000EE4ul = (*(volatile uint32_t *)0x40000EE4ul & 0xFFFFFFF0ul) | (*(uint32_t *)0x10000258ul & 0x0000000Ful);
   27e12:	680a      	ldr	r2, [r1, #0]
   27e14:	681b      	ldr	r3, [r3, #0]
        *(volatile uint32_t *)0x40029640ul = 0x200ul;
   27e16:	4829      	ldr	r0, [pc, #164]	; (27ebc <SystemInit+0x1b8>)
        *(volatile uint32_t *)0x40000EE4ul = (*(volatile uint32_t *)0x40000EE4ul & 0xFFFFFFF0ul) | (*(uint32_t *)0x10000258ul & 0x0000000Ful);
   27e18:	f022 020f 	bic.w	r2, r2, #15
   27e1c:	f003 030f 	and.w	r3, r3, #15
   27e20:	4313      	orrs	r3, r2
        *(volatile uint32_t *)0x40029640ul = 0x200ul;
   27e22:	f44f 7200 	mov.w	r2, #512	; 0x200
        *(volatile uint32_t *)0x40000EE4ul = (*(volatile uint32_t *)0x40000EE4ul & 0xFFFFFFF0ul) | (*(uint32_t *)0x10000258ul & 0x0000000Ful);
   27e26:	600b      	str	r3, [r1, #0]
        *(volatile uint32_t *)0x40029640ul = 0x200ul;
   27e28:	6002      	str	r2, [r0, #0]
   27e2a:	e7c0      	b.n	27dae <SystemInit+0xaa>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
   27e2c:	4a24      	ldr	r2, [pc, #144]	; (27ec0 <SystemInit+0x1bc>)
   27e2e:	2301      	movs	r3, #1
   27e30:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   27e34:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
   27e38:	2b00      	cmp	r3, #0
   27e3a:	d0fb      	beq.n	27e34 <SystemInit+0x130>
            NRF_UICR->PSELRESET[0] = 18;
   27e3c:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   27e40:	2112      	movs	r1, #18
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   27e42:	4a1f      	ldr	r2, [pc, #124]	; (27ec0 <SystemInit+0x1bc>)
            NRF_UICR->PSELRESET[0] = 18;
   27e44:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   27e48:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
   27e4c:	2b00      	cmp	r3, #0
   27e4e:	d0fb      	beq.n	27e48 <SystemInit+0x144>
            NRF_UICR->PSELRESET[1] = 18;
   27e50:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   27e54:	2112      	movs	r1, #18
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   27e56:	4a1a      	ldr	r2, [pc, #104]	; (27ec0 <SystemInit+0x1bc>)
            NRF_UICR->PSELRESET[1] = 18;
   27e58:	f8c3 1204 	str.w	r1, [r3, #516]	; 0x204
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   27e5c:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
   27e60:	2b00      	cmp	r3, #0
   27e62:	d0fb      	beq.n	27e5c <SystemInit+0x158>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
   27e64:	2300      	movs	r3, #0
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   27e66:	4916      	ldr	r1, [pc, #88]	; (27ec0 <SystemInit+0x1bc>)
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
   27e68:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   27e6c:	f8d1 3400 	ldr.w	r3, [r1, #1024]	; 0x400
   27e70:	2b00      	cmp	r3, #0
   27e72:	d0fb      	beq.n	27e6c <SystemInit+0x168>
  __ASM volatile ("dsb 0xF":::"memory");
   27e74:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   27e78:	4907      	ldr	r1, [pc, #28]	; (27e98 <SystemInit+0x194>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   27e7a:	4b12      	ldr	r3, [pc, #72]	; (27ec4 <SystemInit+0x1c0>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   27e7c:	68ca      	ldr	r2, [r1, #12]
   27e7e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   27e82:	4313      	orrs	r3, r2
   27e84:	60cb      	str	r3, [r1, #12]
   27e86:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
   27e8a:	bf00      	nop
   27e8c:	e7fd      	b.n	27e8a <SystemInit+0x186>
   27e8e:	bf00      	nop
   27e90:	4000c000 	.word	0x4000c000
   27e94:	10000130 	.word	0x10000130
   27e98:	e000ed00 	.word	0xe000ed00
   27e9c:	20002008 	.word	0x20002008
   27ea0:	03d09000 	.word	0x03d09000
   27ea4:	10000134 	.word	0x10000134
   27ea8:	4000568c 	.word	0x4000568c
   27eac:	4000f000 	.word	0x4000f000
   27eb0:	00038148 	.word	0x00038148
   27eb4:	40000ee4 	.word	0x40000ee4
   27eb8:	10000258 	.word	0x10000258
   27ebc:	40029640 	.word	0x40029640
   27ec0:	4001e000 	.word	0x4001e000
   27ec4:	05fa0004 	.word	0x05fa0004

00027ec8 <clock_irq_handler>:
        p_item->event_handler(evt_type);
    }
}

static void clock_irq_handler(nrfx_clock_evt_type_t evt)
{
   27ec8:	b510      	push	{r4, lr}
    if (evt == NRFX_CLOCK_EVT_HFCLK_STARTED)
   27eca:	b968      	cbnz	r0, 27ee8 <clock_irq_handler+0x20>
    {
        m_clock_cb.hfclk_on = true;
   27ecc:	4c0e      	ldr	r4, [pc, #56]	; (27f08 <clock_irq_handler+0x40>)
    nrf_drv_clock_handler_item_t * p_item = *p_head;
   27ece:	68a3      	ldr	r3, [r4, #8]
        m_clock_cb.hfclk_on = true;
   27ed0:	2201      	movs	r2, #1
   27ed2:	7062      	strb	r2, [r4, #1]
    if (p_item)
   27ed4:	b13b      	cbz	r3, 27ee6 <clock_irq_handler+0x1e>
        p_item->event_handler(evt_type);
   27ed6:	e9d3 2300 	ldrd	r2, r3, [r3]
   27eda:	2000      	movs	r0, #0
        *p_head = p_item->p_next;
   27edc:	60a2      	str	r2, [r4, #8]
        p_item->event_handler(evt_type);
   27ede:	4798      	blx	r3
    nrf_drv_clock_handler_item_t * p_item = *p_head;
   27ee0:	68a3      	ldr	r3, [r4, #8]
    if (p_item)
   27ee2:	2b00      	cmp	r3, #0
   27ee4:	d1f7      	bne.n	27ed6 <clock_irq_handler+0xe>
            m_clock_cb.cal_done_handler(aborted ?
                NRF_DRV_CLOCK_EVT_CAL_ABORTED : NRF_DRV_CLOCK_EVT_CAL_DONE);
        }
    }
#endif // CALIBRATION_SUPPORT
}
   27ee6:	bd10      	pop	{r4, pc}
    if (evt == NRFX_CLOCK_EVT_LFCLK_STARTED)
   27ee8:	2801      	cmp	r0, #1
   27eea:	d1fc      	bne.n	27ee6 <clock_irq_handler+0x1e>
        m_clock_cb.lfclk_on = true;
   27eec:	4c06      	ldr	r4, [pc, #24]	; (27f08 <clock_irq_handler+0x40>)
    nrf_drv_clock_handler_item_t * p_item = *p_head;
   27eee:	6923      	ldr	r3, [r4, #16]
        m_clock_cb.lfclk_on = true;
   27ef0:	70a0      	strb	r0, [r4, #2]
    if (p_item)
   27ef2:	2b00      	cmp	r3, #0
   27ef4:	d0f7      	beq.n	27ee6 <clock_irq_handler+0x1e>
        p_item->event_handler(evt_type);
   27ef6:	e9d3 2300 	ldrd	r2, r3, [r3]
   27efa:	2001      	movs	r0, #1
        *p_head = p_item->p_next;
   27efc:	6122      	str	r2, [r4, #16]
        p_item->event_handler(evt_type);
   27efe:	4798      	blx	r3
    nrf_drv_clock_handler_item_t * p_item = *p_head;
   27f00:	6923      	ldr	r3, [r4, #16]
    if (p_item)
   27f02:	2b00      	cmp	r3, #0
   27f04:	d1f7      	bne.n	27ef6 <clock_irq_handler+0x2e>
}
   27f06:	bd10      	pop	{r4, pc}
   27f08:	20002168 	.word	0x20002168

00027f0c <soc_evt_handler>:
 * @param[in] evt_id    SoC event.
 * @param[in] p_context Context.
 */
static void soc_evt_handler(uint32_t evt_id, void * p_context)
{
    if (evt_id == NRF_EVT_HFCLKSTARTED)
   27f0c:	b970      	cbnz	r0, 27f2c <soc_evt_handler+0x20>
{
   27f0e:	b510      	push	{r4, lr}
    {
        m_clock_cb.hfclk_on = true;
   27f10:	4c07      	ldr	r4, [pc, #28]	; (27f30 <soc_evt_handler+0x24>)
    nrf_drv_clock_handler_item_t * p_item = *p_head;
   27f12:	68a3      	ldr	r3, [r4, #8]
        m_clock_cb.hfclk_on = true;
   27f14:	2201      	movs	r2, #1
   27f16:	7062      	strb	r2, [r4, #1]
    if (p_item)
   27f18:	b13b      	cbz	r3, 27f2a <soc_evt_handler+0x1e>
        p_item->event_handler(evt_type);
   27f1a:	e9d3 2300 	ldrd	r2, r3, [r3]
   27f1e:	2000      	movs	r0, #0
        *p_head = p_item->p_next;
   27f20:	60a2      	str	r2, [r4, #8]
        p_item->event_handler(evt_type);
   27f22:	4798      	blx	r3
    nrf_drv_clock_handler_item_t * p_item = *p_head;
   27f24:	68a3      	ldr	r3, [r4, #8]
    if (p_item)
   27f26:	2b00      	cmp	r3, #0
   27f28:	d1f7      	bne.n	27f1a <soc_evt_handler+0xe>
        clock_clk_started_notify(NRF_DRV_CLOCK_EVT_HFCLK_STARTED);
    }
}
   27f2a:	bd10      	pop	{r4, pc}
   27f2c:	4770      	bx	lr
   27f2e:	bf00      	nop
   27f30:	20002168 	.word	0x20002168

00027f34 <sd_state_evt_handler>:
 *
 * @param[in] state     State.
 * @param[in] p_context Context.
 */
static void sd_state_evt_handler(nrf_sdh_state_evt_t state, void * p_context)
{
   27f34:	b530      	push	{r4, r5, lr}
    switch (state)
   27f36:	2801      	cmp	r0, #1
{
   27f38:	b083      	sub	sp, #12
    switch (state)
   27f3a:	d004      	beq.n	27f46 <sd_state_evt_handler+0x12>
   27f3c:	2803      	cmp	r0, #3
   27f3e:	d01d      	beq.n	27f7c <sd_state_evt_handler+0x48>
   27f40:	b1b0      	cbz	r0, 27f70 <sd_state_evt_handler+0x3c>
            break;

        default:
            break;
    }
}
   27f42:	b003      	add	sp, #12
   27f44:	bd30      	pop	{r4, r5, pc}
            if (!m_clock_cb.module_initialized)
   27f46:	4c22      	ldr	r4, [pc, #136]	; (27fd0 <sd_state_evt_handler+0x9c>)
            CRITICAL_REGION_ENTER();
   27f48:	2300      	movs	r3, #0
   27f4a:	f10d 0007 	add.w	r0, sp, #7
   27f4e:	f88d 3007 	strb.w	r3, [sp, #7]
   27f52:	f7ff fc3f 	bl	277d4 <app_util_critical_region_enter>
            if (!m_clock_cb.module_initialized)
   27f56:	7823      	ldrb	r3, [r4, #0]
   27f58:	b34b      	cbz	r3, 27fae <sd_state_evt_handler+0x7a>
            ++(m_clock_cb.lfclk_requests);
   27f5a:	68e3      	ldr	r3, [r4, #12]
            CRITICAL_REGION_EXIT();
   27f5c:	f89d 0007 	ldrb.w	r0, [sp, #7]
            ++(m_clock_cb.lfclk_requests);
   27f60:	3301      	adds	r3, #1
            m_clock_cb.lfclk_on = true;
   27f62:	2201      	movs	r2, #1
            ++(m_clock_cb.lfclk_requests);
   27f64:	60e3      	str	r3, [r4, #12]
            m_clock_cb.lfclk_on = true;
   27f66:	70a2      	strb	r2, [r4, #2]
            CRITICAL_REGION_EXIT();
   27f68:	f7ff fc5a 	bl	27820 <app_util_critical_region_exit>
}
   27f6c:	b003      	add	sp, #12
   27f6e:	bd30      	pop	{r4, r5, pc}
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   27f70:	4b18      	ldr	r3, [pc, #96]	; (27fd4 <sd_state_evt_handler+0xa0>)
   27f72:	2201      	movs	r2, #1
   27f74:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
   27f78:	b003      	add	sp, #12
   27f7a:	bd30      	pop	{r4, r5, pc}
    --(m_clock_cb.lfclk_requests);
   27f7c:	4c14      	ldr	r4, [pc, #80]	; (27fd0 <sd_state_evt_handler+0x9c>)
            nrfx_clock_enable();
   27f7e:	f000 f839 	bl	27ff4 <nrfx_clock_enable>
    CRITICAL_REGION_ENTER();
   27f82:	2300      	movs	r3, #0
   27f84:	f10d 0007 	add.w	r0, sp, #7
   27f88:	f88d 3007 	strb.w	r3, [sp, #7]
   27f8c:	f7ff fc22 	bl	277d4 <app_util_critical_region_enter>
    --(m_clock_cb.lfclk_requests);
   27f90:	68e3      	ldr	r3, [r4, #12]
   27f92:	3b01      	subs	r3, #1
   27f94:	60e3      	str	r3, [r4, #12]
    if (m_clock_cb.lfclk_requests == 0)
   27f96:	68e5      	ldr	r5, [r4, #12]
   27f98:	b12d      	cbz	r5, 27fa6 <sd_state_evt_handler+0x72>
    CRITICAL_REGION_EXIT();
   27f9a:	f89d 0007 	ldrb.w	r0, [sp, #7]
   27f9e:	f7ff fc3f 	bl	27820 <app_util_critical_region_exit>
}
   27fa2:	b003      	add	sp, #12
   27fa4:	bd30      	pop	{r4, r5, pc}
    nrfx_clock_lfclk_stop();
   27fa6:	f000 f837 	bl	28018 <nrfx_clock_lfclk_stop>
    m_clock_cb.lfclk_on = false;
   27faa:	70a5      	strb	r5, [r4, #2]
}
   27fac:	e7f5      	b.n	27f9a <sd_state_evt_handler+0x66>
        err_code = nrfx_clock_init(clock_irq_handler);
   27fae:	480a      	ldr	r0, [pc, #40]	; (27fd8 <sd_state_evt_handler+0xa4>)
        m_clock_cb.hfclk_requests = 0;
   27fb0:	6063      	str	r3, [r4, #4]
        m_clock_cb.p_hf_head      = NULL;
   27fb2:	60a3      	str	r3, [r4, #8]
        m_clock_cb.p_lf_head      = NULL;
   27fb4:	6123      	str	r3, [r4, #16]
        m_clock_cb.lfclk_requests = 0;
   27fb6:	60e3      	str	r3, [r4, #12]
        err_code = nrfx_clock_init(clock_irq_handler);
   27fb8:	f000 f810 	bl	27fdc <nrfx_clock_init>
        if (!nrf_sdh_is_enabled())
   27fbc:	f001 fb80 	bl	296c0 <nrf_sdh_is_enabled>
   27fc0:	b110      	cbz	r0, 27fc8 <sd_state_evt_handler+0x94>
        m_clock_cb.module_initialized = true;
   27fc2:	2301      	movs	r3, #1
   27fc4:	7023      	strb	r3, [r4, #0]
    return err_code;
   27fc6:	e7c8      	b.n	27f5a <sd_state_evt_handler+0x26>
            nrfx_clock_enable();
   27fc8:	f000 f814 	bl	27ff4 <nrfx_clock_enable>
   27fcc:	e7f9      	b.n	27fc2 <sd_state_evt_handler+0x8e>
   27fce:	bf00      	nop
   27fd0:	20002168 	.word	0x20002168
   27fd4:	e000e100 	.word	0xe000e100
   27fd8:	00027ec9 	.word	0x00027ec9

00027fdc <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
   27fdc:	4a04      	ldr	r2, [pc, #16]	; (27ff0 <nrfx_clock_init+0x14>)
   27fde:	7913      	ldrb	r3, [r2, #4]
   27fe0:	b923      	cbnz	r3, 27fec <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
   27fe2:	2101      	movs	r1, #1
        m_clock_cb.event_handler = event_handler;
   27fe4:	6010      	str	r0, [r2, #0]
        m_clock_cb.module_initialized = true;
   27fe6:	8091      	strh	r1, [r2, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
   27fe8:	4618      	mov	r0, r3
   27fea:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
   27fec:	2085      	movs	r0, #133	; 0x85
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   27fee:	4770      	bx	lr
   27ff0:	2000217c 	.word	0x2000217c

00027ff4 <nrfx_clock_enable>:
 * @retval false Otherwise.
 */
#define NRFX_IRQ_IS_ENABLED(irq_number)  _NRFX_IRQ_IS_ENABLED(irq_number)
static inline bool _NRFX_IRQ_IS_ENABLED(IRQn_Type irq_number)
{
    return 0 != (NVIC->ISER[irq_number / 32] & (1UL << (irq_number % 32)));
   27ff4:	4b07      	ldr	r3, [pc, #28]	; (28014 <nrfx_clock_enable+0x20>)
   27ff6:	681a      	ldr	r2, [r3, #0]
    priority = NRFX_CLOCK_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   27ff8:	07d2      	lsls	r2, r2, #31
   27ffa:	d404      	bmi.n	28006 <nrfx_clock_enable+0x12>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   27ffc:	21c0      	movs	r1, #192	; 0xc0
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   27ffe:	2201      	movs	r2, #1
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   28000:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   28004:	601a      	str	r2, [r3, #0]
    return (bool)*((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event));
}

__STATIC_INLINE void nrf_clock_lf_src_set(nrf_clock_lfclk_t source)
{
    NRF_CLOCK->LFCLKSRC = (uint32_t)(source);
   28006:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   2800a:	2201      	movs	r2, #1
   2800c:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
#if NRFX_CHECK(NRFX_POWER_ENABLED)
    nrfx_clock_irq_enabled = true;
#endif

    NRFX_LOG_INFO("Module enabled.");
}
   28010:	4770      	bx	lr
   28012:	bf00      	nop
   28014:	e000e100 	.word	0xe000e100

00028018 <nrfx_clock_lfclk_stop>:
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + task)) = 0x1UL;
   28018:	4b04      	ldr	r3, [pc, #16]	; (2802c <nrfx_clock_lfclk_stop+0x14>)
   2801a:	2201      	movs	r2, #1
   2801c:	601a      	str	r2, [r3, #0]
                                CLOCK_LFCLKSRCCOPY_SRC_Msk) >> CLOCK_LFCLKSRCCOPY_SRC_Pos);
}

__STATIC_INLINE bool nrf_clock_lf_is_running(void)
{
    return ((NRF_CLOCK->LFCLKSTAT &
   2801e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   28022:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418

void nrfx_clock_lfclk_stop(void)
{
    NRFX_ASSERT(m_clock_cb.module_initialized);
    nrf_clock_task_trigger(NRF_CLOCK_TASK_LFCLKSTOP);
    while (nrf_clock_lf_is_running())
   28026:	03db      	lsls	r3, r3, #15
   28028:	d4fb      	bmi.n	28022 <nrfx_clock_lfclk_stop+0xa>
    {}
}
   2802a:	4770      	bx	lr
   2802c:	4000000c 	.word	0x4000000c

00028030 <POWER_CLOCK_IRQHandler>:
    nrf_clock_task_trigger(NRF_CLOCK_TASK_CTSTOP);
#endif
}

void nrfx_clock_irq_handler(void)
{
   28030:	b510      	push	{r4, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event));
   28032:	4b17      	ldr	r3, [pc, #92]	; (28090 <POWER_CLOCK_IRQHandler+0x60>)
   28034:	681a      	ldr	r2, [r3, #0]
   28036:	b082      	sub	sp, #8
    if (nrf_clock_event_check(NRF_CLOCK_EVENT_HFCLKSTARTED))
   28038:	b162      	cbz	r2, 28054 <POWER_CLOCK_IRQHandler+0x24>
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event)) = 0x0UL;
   2803a:	2100      	movs	r1, #0
        nrf_clock_event_clear(NRF_CLOCK_EVENT_HFCLKSTARTED);
        NRFX_LOG_DEBUG("Event: %s.", EVT_TO_STR(NRF_CLOCK_EVENT_HFCLKSTARTED));
        nrf_clock_int_disable(NRF_CLOCK_INT_HF_STARTED_MASK);

#if NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_201)
        if (!m_clock_cb.hfclk_started)
   2803c:	4a15      	ldr	r2, [pc, #84]	; (28094 <POWER_CLOCK_IRQHandler+0x64>)
   2803e:	6019      	str	r1, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + (uint32_t)event));
   28040:	681b      	ldr	r3, [r3, #0]
   28042:	7950      	ldrb	r0, [r2, #5]
   28044:	9300      	str	r3, [sp, #0]
    NRF_CLOCK->INTENCLR = int_mask;
   28046:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
   2804a:	2301      	movs	r3, #1
    (void)dummy;
   2804c:	9c00      	ldr	r4, [sp, #0]
    NRF_CLOCK->INTENCLR = int_mask;
   2804e:	f8c1 3308 	str.w	r3, [r1, #776]	; 0x308
   28052:	b198      	cbz	r0, 2807c <POWER_CLOCK_IRQHandler+0x4c>
    return (bool)*((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event));
   28054:	4b10      	ldr	r3, [pc, #64]	; (28098 <POWER_CLOCK_IRQHandler+0x68>)
   28056:	681a      	ldr	r2, [r3, #0]
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK_EVENT_LFCLKSTARTED))
   28058:	b1ba      	cbz	r2, 2808a <POWER_CLOCK_IRQHandler+0x5a>
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event)) = 0x0UL;
   2805a:	2200      	movs	r2, #0
   2805c:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + (uint32_t)event));
   2805e:	681b      	ldr	r3, [r3, #0]
   28060:	9301      	str	r3, [sp, #4]
    NRF_CLOCK->INTENCLR = int_mask;
   28062:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   28066:	2102      	movs	r1, #2
    {
        nrf_clock_event_clear(NRF_CLOCK_EVENT_LFCLKSTARTED);
        NRFX_LOG_DEBUG("Event: %s.", EVT_TO_STR(NRF_CLOCK_EVENT_LFCLKSTARTED));
        nrf_clock_int_disable(NRF_CLOCK_INT_LF_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   28068:	4b0a      	ldr	r3, [pc, #40]	; (28094 <POWER_CLOCK_IRQHandler+0x64>)
    (void)dummy;
   2806a:	9801      	ldr	r0, [sp, #4]
    NRF_CLOCK->INTENCLR = int_mask;
   2806c:	f8c2 1308 	str.w	r1, [r2, #776]	; 0x308
   28070:	681b      	ldr	r3, [r3, #0]
   28072:	2001      	movs	r0, #1
        nrf_clock_int_disable(NRF_CLOCK_INT_DONE_MASK);
        m_clock_cb.cal_state = CAL_STATE_IDLE;
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_CAL_DONE);
    }
#endif //  NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
}
   28074:	b002      	add	sp, #8
   28076:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   2807a:	4718      	bx	r3
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
   2807c:	6811      	ldr	r1, [r2, #0]
            m_clock_cb.hfclk_started = true;
   2807e:	7153      	strb	r3, [r2, #5]
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
   28080:	4788      	blx	r1
    return (bool)*((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event));
   28082:	4b05      	ldr	r3, [pc, #20]	; (28098 <POWER_CLOCK_IRQHandler+0x68>)
   28084:	681a      	ldr	r2, [r3, #0]
    if (nrf_clock_event_check(NRF_CLOCK_EVENT_LFCLKSTARTED))
   28086:	2a00      	cmp	r2, #0
   28088:	d1e7      	bne.n	2805a <POWER_CLOCK_IRQHandler+0x2a>
}
   2808a:	b002      	add	sp, #8
   2808c:	bd10      	pop	{r4, pc}
   2808e:	bf00      	nop
   28090:	40000100 	.word	0x40000100
   28094:	2000217c 	.word	0x2000217c
   28098:	40000104 	.word	0x40000104

0002809c <GPIOTE_IRQHandler>:
    return nrf_gpiote_event_addr_get(event);
}


void nrfx_gpiote_irq_handler(void)
{
   2809c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uint32_t status            = 0;
    uint32_t input[GPIO_COUNT] = {0};
   280a0:	2300      	movs	r3, #0
{
   280a2:	b088      	sub	sp, #32
    uint32_t input[GPIO_COUNT] = {0};
   280a4:	e9cd 3302 	strd	r3, r3, [sp, #8]
    return ((uint32_t)NRF_GPIOTE + task);
}

__STATIC_INLINE bool nrf_gpiote_event_is_set(nrf_gpiote_events_t event)
{
    return (*(uint32_t *)nrf_gpiote_event_addr_get(event) == 0x1UL) ? true : false;
   280a8:	4ac9      	ldr	r2, [pc, #804]	; (283d0 <GPIOTE_IRQHandler+0x334>)
    nrf_gpiote_events_t event = NRF_GPIOTE_EVENTS_IN_0;
    uint32_t            mask  = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;

    for (i = 0; i < GPIOTE_CH_NUM; i++)
    {
        if (nrf_gpiote_event_is_set(event) && nrf_gpiote_int_is_enabled(mask))
   280aa:	6811      	ldr	r1, [r2, #0]
   280ac:	2901      	cmp	r1, #1
   280ae:	f000 824b 	beq.w	28548 <GPIOTE_IRQHandler+0x4ac>
    uint32_t status            = 0;
   280b2:	461e      	mov	r6, r3
   280b4:	4bc7      	ldr	r3, [pc, #796]	; (283d4 <GPIOTE_IRQHandler+0x338>)
        if (nrf_gpiote_event_is_set(event) && nrf_gpiote_int_is_enabled(mask))
   280b6:	681a      	ldr	r2, [r3, #0]
   280b8:	2a01      	cmp	r2, #1
   280ba:	f000 8237 	beq.w	2852c <GPIOTE_IRQHandler+0x490>
   280be:	4bc6      	ldr	r3, [pc, #792]	; (283d8 <GPIOTE_IRQHandler+0x33c>)
   280c0:	681a      	ldr	r2, [r3, #0]
   280c2:	2a01      	cmp	r2, #1
   280c4:	f000 8224 	beq.w	28510 <GPIOTE_IRQHandler+0x474>
   280c8:	4bc4      	ldr	r3, [pc, #784]	; (283dc <GPIOTE_IRQHandler+0x340>)
   280ca:	681a      	ldr	r2, [r3, #0]
   280cc:	2a01      	cmp	r2, #1
   280ce:	f000 8211 	beq.w	284f4 <GPIOTE_IRQHandler+0x458>
   280d2:	4bc3      	ldr	r3, [pc, #780]	; (283e0 <GPIOTE_IRQHandler+0x344>)
   280d4:	681a      	ldr	r2, [r3, #0]
   280d6:	2a01      	cmp	r2, #1
   280d8:	f000 81fe 	beq.w	284d8 <GPIOTE_IRQHandler+0x43c>
   280dc:	4bc1      	ldr	r3, [pc, #772]	; (283e4 <GPIOTE_IRQHandler+0x348>)
   280de:	681a      	ldr	r2, [r3, #0]
   280e0:	2a01      	cmp	r2, #1
   280e2:	f000 81eb 	beq.w	284bc <GPIOTE_IRQHandler+0x420>
   280e6:	4bc0      	ldr	r3, [pc, #768]	; (283e8 <GPIOTE_IRQHandler+0x34c>)
   280e8:	681a      	ldr	r2, [r3, #0]
   280ea:	2a01      	cmp	r2, #1
   280ec:	f000 81d8 	beq.w	284a0 <GPIOTE_IRQHandler+0x404>
   280f0:	4bbe      	ldr	r3, [pc, #760]	; (283ec <GPIOTE_IRQHandler+0x350>)
   280f2:	681a      	ldr	r2, [r3, #0]
   280f4:	2a01      	cmp	r2, #1
   280f6:	d008      	beq.n	2810a <GPIOTE_IRQHandler+0x6e>
   280f8:	4bbd      	ldr	r3, [pc, #756]	; (283f0 <GPIOTE_IRQHandler+0x354>)
        event = (nrf_gpiote_events_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* collect PORT status event, if event is set read pins state. Processing is postponed to the
     * end of interrupt. */
    if (nrf_gpiote_event_is_set(NRF_GPIOTE_EVENTS_PORT))
   280fa:	681a      	ldr	r2, [r3, #0]
   280fc:	2a01      	cmp	r2, #1
   280fe:	f000 822f 	beq.w	28560 <GPIOTE_IRQHandler+0x4c4>
        status |= (uint32_t)NRF_GPIOTE_INT_PORT_MASK;
        nrf_gpio_ports_read(0, GPIO_COUNT, input);
    }

    /* Process pin events. */
    if (status & NRF_GPIOTE_INT_IN_MASK)
   28102:	bb16      	cbnz	r6, 2814a <GPIOTE_IRQHandler+0xae>
                }
            }
        }
        while (repeat);
    }
}
   28104:	b008      	add	sp, #32
   28106:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    NRF_GPIOTE->INTENCLR = mask;
}

__STATIC_INLINE uint32_t nrf_gpiote_int_is_enabled(uint32_t mask)
{
    return (NRF_GPIOTE->INTENSET & mask);
   2810a:	4aba      	ldr	r2, [pc, #744]	; (283f4 <GPIOTE_IRQHandler+0x358>)
   2810c:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
        if (nrf_gpiote_event_is_set(event) && nrf_gpiote_int_is_enabled(mask))
   28110:	0617      	lsls	r7, r2, #24
   28112:	d5f1      	bpl.n	280f8 <GPIOTE_IRQHandler+0x5c>
    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
   28114:	2200      	movs	r2, #0
   28116:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
   28118:	6819      	ldr	r1, [r3, #0]
   2811a:	9100      	str	r1, [sp, #0]
    if (nrf_gpiote_event_is_set(NRF_GPIOTE_EVENTS_PORT))
   2811c:	6e19      	ldr	r1, [r3, #96]	; 0x60
    (void)dummy;
   2811e:	9800      	ldr	r0, [sp, #0]
   28120:	2901      	cmp	r1, #1
    return (*(uint32_t *)nrf_gpiote_event_addr_get(event) == 0x1UL) ? true : false;
   28122:	f103 0360 	add.w	r3, r3, #96	; 0x60
            status |= mask;
   28126:	f046 0680 	orr.w	r6, r6, #128	; 0x80
    if (nrf_gpiote_event_is_set(NRF_GPIOTE_EVENTS_PORT))
   2812a:	d10e      	bne.n	2814a <GPIOTE_IRQHandler+0xae>
    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
   2812c:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
   2812e:	681b      	ldr	r3, [r3, #0]
   28130:	9301      	str	r3, [sp, #4]
}


__STATIC_INLINE uint32_t nrf_gpio_port_in_read(NRF_GPIO_Type const * p_reg)
{
    return p_reg->IN;
   28132:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    (void)dummy;
   28136:	9b01      	ldr	r3, [sp, #4]
   28138:	f8d2 2510 	ldr.w	r2, [r2, #1296]	; 0x510
   2813c:	4bae      	ldr	r3, [pc, #696]	; (283f8 <GPIOTE_IRQHandler+0x35c>)
    NRFX_ASSERT(start_port + length <= GPIO_COUNT);
    uint32_t i;

    for (i = start_port; i < (start_port + length); i++)
    {
        *p_masks = nrf_gpio_port_in_read(gpio_regs[i]);
   2813e:	9202      	str	r2, [sp, #8]
    return p_reg->IN;
   28140:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
        *p_masks = nrf_gpio_port_in_read(gpio_regs[i]);
   28144:	9303      	str	r3, [sp, #12]
        status |= (uint32_t)NRF_GPIOTE_INT_PORT_MASK;
   28146:	f046 4600 	orr.w	r6, r6, #2147483648	; 0x80000000
    return m_cb.handlers[channel];
   2814a:	4fac      	ldr	r7, [pc, #688]	; (283fc <GPIOTE_IRQHandler+0x360>)
        mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
   2814c:	2501      	movs	r5, #1
        for (i = 0; i < GPIOTE_CH_NUM; i++)
   2814e:	2400      	movs	r4, #0
                              ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

__STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(uint32_t idx)
{
    return ((NRF_GPIOTE->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   28150:	00a3      	lsls	r3, r4, #2
   28152:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
            if (mask & status)
   28156:	422e      	tst	r6, r5
   28158:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
            mask <<= 1;
   2815c:	ea4f 0545 	mov.w	r5, r5, lsl #1
            if (mask & status)
   28160:	d00b      	beq.n	2817a <GPIOTE_IRQHandler+0xde>
   28162:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return m_cb.handlers[channel];
   28166:	f857 2024 	ldr.w	r2, [r7, r4, lsl #2]
}

__STATIC_INLINE nrf_gpiote_polarity_t nrf_gpiote_event_polarity_get(uint32_t idx)
{
    return (nrf_gpiote_polarity_t)((NRF_GPIOTE->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >> GPIOTE_CONFIG_POLARITY_Pos);
   2816a:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
                    handler(pin, polarity);
   2816e:	f3c0 2005 	ubfx	r0, r0, #8, #6
   28172:	f3c1 4101 	ubfx	r1, r1, #16, #2
                if (handler)
   28176:	b102      	cbz	r2, 2817a <GPIOTE_IRQHandler+0xde>
                    handler(pin, polarity);
   28178:	4790      	blx	r2
        for (i = 0; i < GPIOTE_CH_NUM; i++)
   2817a:	3401      	adds	r4, #1
   2817c:	2c08      	cmp	r4, #8
   2817e:	d1e7      	bne.n	28150 <GPIOTE_IRQHandler+0xb4>
    if (status & (uint32_t)NRF_GPIOTE_INT_PORT_MASK)
   28180:	2e00      	cmp	r6, #0
   28182:	dabf      	bge.n	28104 <GPIOTE_IRQHandler+0x68>
        uint32_t toggle_mask[GPIO_COUNT] = {0};
   28184:	4c9d      	ldr	r4, [pc, #628]	; (283fc <GPIOTE_IRQHandler+0x360>)
        return NRF_P1;
   28186:	4f9c      	ldr	r7, [pc, #624]	; (283f8 <GPIOTE_IRQHandler+0x35c>)
            pins_to_check[port_idx] = 0xFFFFFFFF;
   28188:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2818c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   28190:	e9cd 0106 	strd	r0, r1, [sp, #24]
                uint8_t           pin_and_sense = (uint8_t)m_cb.port_handlers_pins[i];
   28194:	f994 0060 	ldrsb.w	r0, [r4, #96]	; 0x60
        uint32_t toggle_mask[GPIO_COUNT] = {0};
   28198:	f10d 0810 	add.w	r8, sp, #16
   2819c:	2300      	movs	r3, #0
                if ((m_cb.port_handlers_pins[i] != PIN_NOT_USED)
   2819e:	1c45      	adds	r5, r0, #1
        uint32_t toggle_mask[GPIO_COUNT] = {0};
   281a0:	f8c8 3004 	str.w	r3, [r8, #4]
   281a4:	9304      	str	r3, [sp, #16]
__STATIC_INLINE uint32_t nrf_bitmask_bit_is_set(uint32_t bit, void const * p_mask)
{
    uint8_t const * p_mask8 = (uint8_t const *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    return (1 << bit) & p_mask8[byte_idx];
   281a6:	f04f 0601 	mov.w	r6, #1
                if ((m_cb.port_handlers_pins[i] != PIN_NOT_USED)
   281aa:	f000 80f7 	beq.w	2839c <GPIOTE_IRQHandler+0x300>
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   281ae:	f3c0 09c2 	ubfx	r9, r0, #3, #3
    return (1 << bit) & p_mask8[byte_idx];
   281b2:	ab08      	add	r3, sp, #32
   281b4:	eb03 0e09 	add.w	lr, r3, r9
    bit = BITMASK_RELBIT_GET(bit);
   281b8:	f000 0307 	and.w	r3, r0, #7
    return (1 << bit) & p_mask8[byte_idx];
   281bc:	f81e 2c08 	ldrb.w	r2, [lr, #-8]
   281c0:	fa06 f303 	lsl.w	r3, r6, r3
                    && nrf_bitmask_bit_is_set(pin, pins_to_check))
   281c4:	ea12 0503 	ands.w	r5, r2, r3
                uint8_t           pin_and_sense = (uint8_t)m_cb.port_handlers_pins[i];
   281c8:	fa5f fc80 	uxtb.w	ip, r0
                nrfx_gpiote_pin_t pin           = (pin_and_sense & ~SENSE_FIELD_MASK);
   281cc:	f000 003f 	and.w	r0, r0, #63	; 0x3f
                    && nrf_bitmask_bit_is_set(pin, pins_to_check))
   281d0:	d021      	beq.n	28216 <GPIOTE_IRQHandler+0x17a>
    return m_cb.pin_assignments[pin];
   281d2:	1822      	adds	r2, r4, r0
                    nrf_gpiote_polarity_t polarity =
   281d4:	ea4f 119c 	mov.w	r1, ip, lsr #6
                        channel_handler_get((uint32_t)channel_port_get(pin));
   281d8:	f992 2030 	ldrsb.w	r2, [r2, #48]	; 0x30
    return m_cb.handlers[channel];
   281dc:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
                    if (handler || (polarity == NRF_GPIOTE_POLARITY_TOGGLE))
   281e0:	2a00      	cmp	r2, #0
   281e2:	f000 8137 	beq.w	28454 <GPIOTE_IRQHandler+0x3b8>
                        if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
   281e6:	2903      	cmp	r1, #3
   281e8:	f000 8136 	beq.w	28458 <GPIOTE_IRQHandler+0x3bc>
    if (*p_pin < P0_PIN_NUM)
   281ec:	281f      	cmp	r0, #31
   281ee:	f200 80eb 	bhi.w	283c8 <GPIOTE_IRQHandler+0x32c>
   281f2:	4605      	mov	r5, r0
        return NRF_P0;
   281f4:	f04f 4ca0 	mov.w	ip, #1342177280	; 0x50000000
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   281f8:	eb0c 0c85 	add.w	ip, ip, r5, lsl #2
   281fc:	f81e 5c18 	ldrb.w	r5, [lr, #-24]
   28200:	f8dc e700 	ldr.w	lr, [ip, #1792]	; 0x700
                        if ((pin_state && (sense == NRF_GPIO_PIN_SENSE_HIGH)) ||
   28204:	401d      	ands	r5, r3
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
   28206:	f3ce 4e01 	ubfx	lr, lr, #16, #2
   2820a:	f040 80d1 	bne.w	283b0 <GPIOTE_IRQHandler+0x314>
                            (!pin_state && (sense == NRF_GPIO_PIN_SENSE_LOW))  )
   2820e:	f1be 0f03 	cmp.w	lr, #3
   28212:	f000 81b7 	beq.w	28584 <GPIOTE_IRQHandler+0x4e8>
                uint8_t           pin_and_sense = (uint8_t)m_cb.port_handlers_pins[i];
   28216:	f994 0061 	ldrsb.w	r0, [r4, #97]	; 0x61
                if ((m_cb.port_handlers_pins[i] != PIN_NOT_USED)
   2821a:	1c41      	adds	r1, r0, #1
   2821c:	d033      	beq.n	28286 <GPIOTE_IRQHandler+0x1ea>
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   2821e:	f3c0 0ec2 	ubfx	lr, r0, #3, #3
    return (1 << bit) & p_mask8[byte_idx];
   28222:	ab08      	add	r3, sp, #32
   28224:	eb03 0c0e 	add.w	ip, r3, lr
    bit = BITMASK_RELBIT_GET(bit);
   28228:	f000 0307 	and.w	r3, r0, #7
    return (1 << bit) & p_mask8[byte_idx];
   2822c:	f81c 1c08 	ldrb.w	r1, [ip, #-8]
   28230:	fa06 f303 	lsl.w	r3, r6, r3
                    && nrf_bitmask_bit_is_set(pin, pins_to_check))
   28234:	4219      	tst	r1, r3
                uint8_t           pin_and_sense = (uint8_t)m_cb.port_handlers_pins[i];
   28236:	b2c2      	uxtb	r2, r0
                nrfx_gpiote_pin_t pin           = (pin_and_sense & ~SENSE_FIELD_MASK);
   28238:	f000 003f 	and.w	r0, r0, #63	; 0x3f
                    && nrf_bitmask_bit_is_set(pin, pins_to_check))
   2823c:	d023      	beq.n	28286 <GPIOTE_IRQHandler+0x1ea>
    return m_cb.pin_assignments[pin];
   2823e:	eb04 0900 	add.w	r9, r4, r0
                    nrf_gpiote_polarity_t polarity =
   28242:	0991      	lsrs	r1, r2, #6
                        channel_handler_get((uint32_t)channel_port_get(pin));
   28244:	f999 9030 	ldrsb.w	r9, [r9, #48]	; 0x30
    return m_cb.handlers[channel];
   28248:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
                    if (handler || (polarity == NRF_GPIOTE_POLARITY_TOGGLE))
   2824c:	f1b9 0f00 	cmp.w	r9, #0
   28250:	f000 8112 	beq.w	28478 <GPIOTE_IRQHandler+0x3dc>
                        if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
   28254:	2903      	cmp	r1, #3
   28256:	f000 8112 	beq.w	2847e <GPIOTE_IRQHandler+0x3e2>
    if (*p_pin < P0_PIN_NUM)
   2825a:	281f      	cmp	r0, #31
   2825c:	f200 80f6 	bhi.w	2844c <GPIOTE_IRQHandler+0x3b0>
   28260:	4686      	mov	lr, r0
        return NRF_P0;
   28262:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   28266:	eb02 028e 	add.w	r2, r2, lr, lsl #2
   2826a:	f81c ec18 	ldrb.w	lr, [ip, #-24]
   2826e:	f8d2 c700 	ldr.w	ip, [r2, #1792]	; 0x700
                        if ((pin_state && (sense == NRF_GPIO_PIN_SENSE_HIGH)) ||
   28272:	ea1e 0f03 	tst.w	lr, r3
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
   28276:	f3cc 4c01 	ubfx	ip, ip, #16, #2
   2827a:	f040 80da 	bne.w	28432 <GPIOTE_IRQHandler+0x396>
                            (!pin_state && (sense == NRF_GPIO_PIN_SENSE_LOW))  )
   2827e:	f1bc 0f03 	cmp.w	ip, #3
   28282:	f000 8191 	beq.w	285a8 <GPIOTE_IRQHandler+0x50c>
                uint8_t           pin_and_sense = (uint8_t)m_cb.port_handlers_pins[i];
   28286:	f994 0062 	ldrsb.w	r0, [r4, #98]	; 0x62
                if ((m_cb.port_handlers_pins[i] != PIN_NOT_USED)
   2828a:	1c42      	adds	r2, r0, #1
   2828c:	d033      	beq.n	282f6 <GPIOTE_IRQHandler+0x25a>
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   2828e:	f3c0 0ec2 	ubfx	lr, r0, #3, #3
    return (1 << bit) & p_mask8[byte_idx];
   28292:	ab08      	add	r3, sp, #32
   28294:	eb03 0c0e 	add.w	ip, r3, lr
    bit = BITMASK_RELBIT_GET(bit);
   28298:	f000 0307 	and.w	r3, r0, #7
    return (1 << bit) & p_mask8[byte_idx];
   2829c:	f81c 1c08 	ldrb.w	r1, [ip, #-8]
   282a0:	fa06 f303 	lsl.w	r3, r6, r3
                    && nrf_bitmask_bit_is_set(pin, pins_to_check))
   282a4:	4219      	tst	r1, r3
                uint8_t           pin_and_sense = (uint8_t)m_cb.port_handlers_pins[i];
   282a6:	b2c2      	uxtb	r2, r0
                nrfx_gpiote_pin_t pin           = (pin_and_sense & ~SENSE_FIELD_MASK);
   282a8:	f000 003f 	and.w	r0, r0, #63	; 0x3f
                    && nrf_bitmask_bit_is_set(pin, pins_to_check))
   282ac:	d023      	beq.n	282f6 <GPIOTE_IRQHandler+0x25a>
    return m_cb.pin_assignments[pin];
   282ae:	eb04 0900 	add.w	r9, r4, r0
                    nrf_gpiote_polarity_t polarity =
   282b2:	0991      	lsrs	r1, r2, #6
                        channel_handler_get((uint32_t)channel_port_get(pin));
   282b4:	f999 9030 	ldrsb.w	r9, [r9, #48]	; 0x30
    return m_cb.handlers[channel];
   282b8:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
                    if (handler || (polarity == NRF_GPIOTE_POLARITY_TOGGLE))
   282bc:	f1b9 0f00 	cmp.w	r9, #0
   282c0:	f000 80d0 	beq.w	28464 <GPIOTE_IRQHandler+0x3c8>
                        if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
   282c4:	2903      	cmp	r1, #3
   282c6:	f000 80d0 	beq.w	2846a <GPIOTE_IRQHandler+0x3ce>
    if (*p_pin < P0_PIN_NUM)
   282ca:	281f      	cmp	r0, #31
   282cc:	f200 80a5 	bhi.w	2841a <GPIOTE_IRQHandler+0x37e>
   282d0:	4686      	mov	lr, r0
        return NRF_P0;
   282d2:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   282d6:	eb02 028e 	add.w	r2, r2, lr, lsl #2
   282da:	f81c ec18 	ldrb.w	lr, [ip, #-24]
   282de:	f8d2 c700 	ldr.w	ip, [r2, #1792]	; 0x700
                        if ((pin_state && (sense == NRF_GPIO_PIN_SENSE_HIGH)) ||
   282e2:	ea1e 0f03 	tst.w	lr, r3
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
   282e6:	f3cc 4c01 	ubfx	ip, ip, #16, #2
   282ea:	f040 8089 	bne.w	28400 <GPIOTE_IRQHandler+0x364>
                            (!pin_state && (sense == NRF_GPIO_PIN_SENSE_LOW))  )
   282ee:	f1bc 0f03 	cmp.w	ip, #3
   282f2:	f000 816d 	beq.w	285d0 <GPIOTE_IRQHandler+0x534>
                uint8_t           pin_and_sense = (uint8_t)m_cb.port_handlers_pins[i];
   282f6:	f994 0063 	ldrsb.w	r0, [r4, #99]	; 0x63
                if ((m_cb.port_handlers_pins[i] != PIN_NOT_USED)
   282fa:	1c43      	adds	r3, r0, #1
   282fc:	d033      	beq.n	28366 <GPIOTE_IRQHandler+0x2ca>
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   282fe:	f3c0 0ec2 	ubfx	lr, r0, #3, #3
    return (1 << bit) & p_mask8[byte_idx];
   28302:	ab08      	add	r3, sp, #32
   28304:	eb03 0c0e 	add.w	ip, r3, lr
    bit = BITMASK_RELBIT_GET(bit);
   28308:	f000 0307 	and.w	r3, r0, #7
    return (1 << bit) & p_mask8[byte_idx];
   2830c:	f81c 1c08 	ldrb.w	r1, [ip, #-8]
   28310:	fa06 f303 	lsl.w	r3, r6, r3
                    && nrf_bitmask_bit_is_set(pin, pins_to_check))
   28314:	4219      	tst	r1, r3
                uint8_t           pin_and_sense = (uint8_t)m_cb.port_handlers_pins[i];
   28316:	b2c2      	uxtb	r2, r0
                nrfx_gpiote_pin_t pin           = (pin_and_sense & ~SENSE_FIELD_MASK);
   28318:	f000 003f 	and.w	r0, r0, #63	; 0x3f
                    && nrf_bitmask_bit_is_set(pin, pins_to_check))
   2831c:	d023      	beq.n	28366 <GPIOTE_IRQHandler+0x2ca>
    return m_cb.pin_assignments[pin];
   2831e:	eb04 0900 	add.w	r9, r4, r0
                    nrf_gpiote_polarity_t polarity =
   28322:	0991      	lsrs	r1, r2, #6
                        channel_handler_get((uint32_t)channel_port_get(pin));
   28324:	f999 9030 	ldrsb.w	r9, [r9, #48]	; 0x30
    return m_cb.handlers[channel];
   28328:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
                    if (handler || (polarity == NRF_GPIOTE_POLARITY_TOGGLE))
   2832c:	f1b9 0f00 	cmp.w	r9, #0
   28330:	f000 80ac 	beq.w	2848c <GPIOTE_IRQHandler+0x3f0>
                        if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
   28334:	2903      	cmp	r1, #3
   28336:	f000 80ac 	beq.w	28492 <GPIOTE_IRQHandler+0x3f6>
    if (*p_pin < P0_PIN_NUM)
   2833a:	281f      	cmp	r0, #31
        return NRF_P1;
   2833c:	bf8b      	itete	hi
   2833e:	46be      	movhi	lr, r7
        return NRF_P0;
   28340:	f04f 4ea0 	movls.w	lr, #1342177280	; 0x50000000
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
   28344:	f002 021f 	andhi.w	r2, r2, #31
        return NRF_P1;
   28348:	4602      	movls	r2, r0
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   2834a:	eb0e 0282 	add.w	r2, lr, r2, lsl #2
   2834e:	f81c ec18 	ldrb.w	lr, [ip, #-24]
   28352:	f8d2 c700 	ldr.w	ip, [r2, #1792]	; 0x700
                        if ((pin_state && (sense == NRF_GPIO_PIN_SENSE_HIGH)) ||
   28356:	ea1e 0f03 	tst.w	lr, r3
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
   2835a:	f3cc 4c01 	ubfx	ip, ip, #16, #2
   2835e:	d160      	bne.n	28422 <GPIOTE_IRQHandler+0x386>
                            (!pin_state && (sense == NRF_GPIO_PIN_SENSE_LOW))  )
   28360:	f1bc 0f03 	cmp.w	ip, #3
   28364:	d01c      	beq.n	283a0 <GPIOTE_IRQHandler+0x304>
            if (repeat)
   28366:	2d00      	cmp	r5, #0
   28368:	f43f aecc 	beq.w	28104 <GPIOTE_IRQHandler+0x68>
    return p_reg->IN;
   2836c:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
                    if (new_input[port_idx] != input[port_idx])
   28370:	9b02      	ldr	r3, [sp, #8]
   28372:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
   28376:	f8d7 0510 	ldr.w	r0, [r7, #1296]	; 0x510
   2837a:	428b      	cmp	r3, r1
   2837c:	d103      	bne.n	28386 <GPIOTE_IRQHandler+0x2ea>
   2837e:	9b03      	ldr	r3, [sp, #12]
   28380:	4283      	cmp	r3, r0
   28382:	f43f aebf 	beq.w	28104 <GPIOTE_IRQHandler+0x68>
                        pins_to_check[port_idx] = toggle_mask[port_idx];
   28386:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
                        input[port_idx]         = new_input[port_idx];
   2838a:	e9cd 1002 	strd	r1, r0, [sp, #8]
                uint8_t           pin_and_sense = (uint8_t)m_cb.port_handlers_pins[i];
   2838e:	f994 0060 	ldrsb.w	r0, [r4, #96]	; 0x60
                if ((m_cb.port_handlers_pins[i] != PIN_NOT_USED)
   28392:	1c45      	adds	r5, r0, #1
                        pins_to_check[port_idx] = toggle_mask[port_idx];
   28394:	e9cd 2306 	strd	r2, r3, [sp, #24]
                if ((m_cb.port_handlers_pins[i] != PIN_NOT_USED)
   28398:	f47f af09 	bne.w	281ae <GPIOTE_IRQHandler+0x112>
            repeat = 0;
   2839c:	2500      	movs	r5, #0
   2839e:	e73a      	b.n	28216 <GPIOTE_IRQHandler+0x17a>
                            if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
   283a0:	2903      	cmp	r1, #3
   283a2:	f000 8129 	beq.w	285f8 <GPIOTE_IRQHandler+0x55c>
                            if (handler)
   283a6:	f1b9 0f00 	cmp.w	r9, #0
   283aa:	d0dc      	beq.n	28366 <GPIOTE_IRQHandler+0x2ca>
                                handler(pin, polarity);
   283ac:	47c8      	blx	r9
   283ae:	e7da      	b.n	28366 <GPIOTE_IRQHandler+0x2ca>
                        if ((pin_state && (sense == NRF_GPIO_PIN_SENSE_HIGH)) ||
   283b0:	f1be 0f02 	cmp.w	lr, #2
   283b4:	d1f2      	bne.n	2839c <GPIOTE_IRQHandler+0x300>
                            if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
   283b6:	2903      	cmp	r1, #3
   283b8:	f000 8139 	beq.w	2862e <GPIOTE_IRQHandler+0x592>
            repeat = 0;
   283bc:	2500      	movs	r5, #0
                            if (handler)
   283be:	2a00      	cmp	r2, #0
   283c0:	f43f af29 	beq.w	28216 <GPIOTE_IRQHandler+0x17a>
                                handler(pin, polarity);
   283c4:	4790      	blx	r2
   283c6:	e726      	b.n	28216 <GPIOTE_IRQHandler+0x17a>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
   283c8:	f00c 051f 	and.w	r5, ip, #31
        return NRF_P1;
   283cc:	46bc      	mov	ip, r7
   283ce:	e713      	b.n	281f8 <GPIOTE_IRQHandler+0x15c>
   283d0:	40006100 	.word	0x40006100
   283d4:	40006104 	.word	0x40006104
   283d8:	40006108 	.word	0x40006108
   283dc:	4000610c 	.word	0x4000610c
   283e0:	40006110 	.word	0x40006110
   283e4:	40006114 	.word	0x40006114
   283e8:	40006118 	.word	0x40006118
   283ec:	4000611c 	.word	0x4000611c
   283f0:	4000617c 	.word	0x4000617c
   283f4:	40006000 	.word	0x40006000
   283f8:	50000300 	.word	0x50000300
   283fc:	20002188 	.word	0x20002188
                        if ((pin_state && (sense == NRF_GPIO_PIN_SENSE_HIGH)) ||
   28400:	f1bc 0f02 	cmp.w	ip, #2
   28404:	f47f af77 	bne.w	282f6 <GPIOTE_IRQHandler+0x25a>
                            if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
   28408:	2903      	cmp	r1, #3
   2840a:	f000 810d 	beq.w	28628 <GPIOTE_IRQHandler+0x58c>
                            if (handler)
   2840e:	f1b9 0f00 	cmp.w	r9, #0
   28412:	f43f af70 	beq.w	282f6 <GPIOTE_IRQHandler+0x25a>
                                handler(pin, polarity);
   28416:	47c8      	blx	r9
   28418:	e76d      	b.n	282f6 <GPIOTE_IRQHandler+0x25a>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
   2841a:	f002 0e1f 	and.w	lr, r2, #31
        return NRF_P1;
   2841e:	463a      	mov	r2, r7
   28420:	e759      	b.n	282d6 <GPIOTE_IRQHandler+0x23a>
                        if ((pin_state && (sense == NRF_GPIO_PIN_SENSE_HIGH)) ||
   28422:	f1bc 0f02 	cmp.w	ip, #2
   28426:	d19e      	bne.n	28366 <GPIOTE_IRQHandler+0x2ca>
                            if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
   28428:	2903      	cmp	r1, #3
   2842a:	d1bc      	bne.n	283a6 <GPIOTE_IRQHandler+0x30a>
   2842c:	f44f 3c40 	mov.w	ip, #196608	; 0x30000
   28430:	e0e4      	b.n	285fc <GPIOTE_IRQHandler+0x560>
                        if ((pin_state && (sense == NRF_GPIO_PIN_SENSE_HIGH)) ||
   28432:	f1bc 0f02 	cmp.w	ip, #2
   28436:	f47f af26 	bne.w	28286 <GPIOTE_IRQHandler+0x1ea>
                            if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
   2843a:	2903      	cmp	r1, #3
   2843c:	f000 80f1 	beq.w	28622 <GPIOTE_IRQHandler+0x586>
                            if (handler)
   28440:	f1b9 0f00 	cmp.w	r9, #0
   28444:	f43f af1f 	beq.w	28286 <GPIOTE_IRQHandler+0x1ea>
                                handler(pin, polarity);
   28448:	47c8      	blx	r9
   2844a:	e71c      	b.n	28286 <GPIOTE_IRQHandler+0x1ea>
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
   2844c:	f002 0e1f 	and.w	lr, r2, #31
        return NRF_P1;
   28450:	463a      	mov	r2, r7
   28452:	e708      	b.n	28266 <GPIOTE_IRQHandler+0x1ca>
                    if (handler || (polarity == NRF_GPIOTE_POLARITY_TOGGLE))
   28454:	2903      	cmp	r1, #3
   28456:	d1a1      	bne.n	2839c <GPIOTE_IRQHandler+0x300>
__STATIC_INLINE void nrf_bitmask_bit_set(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] |= (1 << bit);
   28458:	f818 5009 	ldrb.w	r5, [r8, r9]
   2845c:	431d      	orrs	r5, r3
   2845e:	f808 5009 	strb.w	r5, [r8, r9]
   28462:	e6c3      	b.n	281ec <GPIOTE_IRQHandler+0x150>
   28464:	2903      	cmp	r1, #3
   28466:	f47f af46 	bne.w	282f6 <GPIOTE_IRQHandler+0x25a>
   2846a:	f818 a00e 	ldrb.w	sl, [r8, lr]
   2846e:	ea4a 0a03 	orr.w	sl, sl, r3
   28472:	f808 a00e 	strb.w	sl, [r8, lr]
   28476:	e728      	b.n	282ca <GPIOTE_IRQHandler+0x22e>
   28478:	2903      	cmp	r1, #3
   2847a:	f47f af04 	bne.w	28286 <GPIOTE_IRQHandler+0x1ea>
   2847e:	f818 a00e 	ldrb.w	sl, [r8, lr]
   28482:	ea4a 0a03 	orr.w	sl, sl, r3
   28486:	f808 a00e 	strb.w	sl, [r8, lr]
   2848a:	e6e6      	b.n	2825a <GPIOTE_IRQHandler+0x1be>
   2848c:	2903      	cmp	r1, #3
   2848e:	f47f af6a 	bne.w	28366 <GPIOTE_IRQHandler+0x2ca>
   28492:	f818 a00e 	ldrb.w	sl, [r8, lr]
   28496:	ea4a 0a03 	orr.w	sl, sl, r3
   2849a:	f808 a00e 	strb.w	sl, [r8, lr]
}
   2849e:	e74c      	b.n	2833a <GPIOTE_IRQHandler+0x29e>
    return (NRF_GPIOTE->INTENSET & mask);
   284a0:	4a64      	ldr	r2, [pc, #400]	; (28634 <GPIOTE_IRQHandler+0x598>)
   284a2:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
        if (nrf_gpiote_event_is_set(event) && nrf_gpiote_int_is_enabled(mask))
   284a6:	0652      	lsls	r2, r2, #25
   284a8:	f57f ae22 	bpl.w	280f0 <GPIOTE_IRQHandler+0x54>
    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
   284ac:	2200      	movs	r2, #0
   284ae:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
   284b0:	681b      	ldr	r3, [r3, #0]
   284b2:	9300      	str	r3, [sp, #0]
    (void)dummy;
   284b4:	9b00      	ldr	r3, [sp, #0]
            status |= mask;
   284b6:	f046 0640 	orr.w	r6, r6, #64	; 0x40
   284ba:	e619      	b.n	280f0 <GPIOTE_IRQHandler+0x54>
    return (NRF_GPIOTE->INTENSET & mask);
   284bc:	4a5d      	ldr	r2, [pc, #372]	; (28634 <GPIOTE_IRQHandler+0x598>)
   284be:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
        if (nrf_gpiote_event_is_set(event) && nrf_gpiote_int_is_enabled(mask))
   284c2:	0691      	lsls	r1, r2, #26
   284c4:	f57f ae0f 	bpl.w	280e6 <GPIOTE_IRQHandler+0x4a>
    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
   284c8:	2200      	movs	r2, #0
   284ca:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
   284cc:	681b      	ldr	r3, [r3, #0]
   284ce:	9300      	str	r3, [sp, #0]
    (void)dummy;
   284d0:	9b00      	ldr	r3, [sp, #0]
            status |= mask;
   284d2:	f046 0620 	orr.w	r6, r6, #32
   284d6:	e606      	b.n	280e6 <GPIOTE_IRQHandler+0x4a>
    return (NRF_GPIOTE->INTENSET & mask);
   284d8:	4a56      	ldr	r2, [pc, #344]	; (28634 <GPIOTE_IRQHandler+0x598>)
   284da:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
        if (nrf_gpiote_event_is_set(event) && nrf_gpiote_int_is_enabled(mask))
   284de:	06d0      	lsls	r0, r2, #27
   284e0:	f57f adfc 	bpl.w	280dc <GPIOTE_IRQHandler+0x40>
    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
   284e4:	2200      	movs	r2, #0
   284e6:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
   284e8:	681b      	ldr	r3, [r3, #0]
   284ea:	9300      	str	r3, [sp, #0]
    (void)dummy;
   284ec:	9b00      	ldr	r3, [sp, #0]
            status |= mask;
   284ee:	f046 0610 	orr.w	r6, r6, #16
   284f2:	e5f3      	b.n	280dc <GPIOTE_IRQHandler+0x40>
    return (NRF_GPIOTE->INTENSET & mask);
   284f4:	4a4f      	ldr	r2, [pc, #316]	; (28634 <GPIOTE_IRQHandler+0x598>)
   284f6:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
        if (nrf_gpiote_event_is_set(event) && nrf_gpiote_int_is_enabled(mask))
   284fa:	0714      	lsls	r4, r2, #28
   284fc:	f57f ade9 	bpl.w	280d2 <GPIOTE_IRQHandler+0x36>
    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
   28500:	2200      	movs	r2, #0
   28502:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
   28504:	681b      	ldr	r3, [r3, #0]
   28506:	9300      	str	r3, [sp, #0]
    (void)dummy;
   28508:	9b00      	ldr	r3, [sp, #0]
            status |= mask;
   2850a:	f046 0608 	orr.w	r6, r6, #8
   2850e:	e5e0      	b.n	280d2 <GPIOTE_IRQHandler+0x36>
    return (NRF_GPIOTE->INTENSET & mask);
   28510:	4a48      	ldr	r2, [pc, #288]	; (28634 <GPIOTE_IRQHandler+0x598>)
   28512:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
        if (nrf_gpiote_event_is_set(event) && nrf_gpiote_int_is_enabled(mask))
   28516:	0755      	lsls	r5, r2, #29
   28518:	f57f add6 	bpl.w	280c8 <GPIOTE_IRQHandler+0x2c>
    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
   2851c:	2200      	movs	r2, #0
   2851e:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
   28520:	681b      	ldr	r3, [r3, #0]
   28522:	9300      	str	r3, [sp, #0]
    (void)dummy;
   28524:	9b00      	ldr	r3, [sp, #0]
            status |= mask;
   28526:	f046 0604 	orr.w	r6, r6, #4
   2852a:	e5cd      	b.n	280c8 <GPIOTE_IRQHandler+0x2c>
    return (NRF_GPIOTE->INTENSET & mask);
   2852c:	4a41      	ldr	r2, [pc, #260]	; (28634 <GPIOTE_IRQHandler+0x598>)
   2852e:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
        if (nrf_gpiote_event_is_set(event) && nrf_gpiote_int_is_enabled(mask))
   28532:	0797      	lsls	r7, r2, #30
   28534:	f57f adc3 	bpl.w	280be <GPIOTE_IRQHandler+0x22>
    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
   28538:	2200      	movs	r2, #0
   2853a:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
   2853c:	681b      	ldr	r3, [r3, #0]
   2853e:	9300      	str	r3, [sp, #0]
    (void)dummy;
   28540:	9b00      	ldr	r3, [sp, #0]
            status |= mask;
   28542:	f046 0602 	orr.w	r6, r6, #2
   28546:	e5ba      	b.n	280be <GPIOTE_IRQHandler+0x22>
    return (NRF_GPIOTE->INTENSET & mask);
   28548:	493a      	ldr	r1, [pc, #232]	; (28634 <GPIOTE_IRQHandler+0x598>)
   2854a:	f8d1 6304 	ldr.w	r6, [r1, #772]	; 0x304
        if (nrf_gpiote_event_is_set(event) && nrf_gpiote_int_is_enabled(mask))
   2854e:	f016 0601 	ands.w	r6, r6, #1
   28552:	f43f adaf 	beq.w	280b4 <GPIOTE_IRQHandler+0x18>
    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
   28556:	6013      	str	r3, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
   28558:	6813      	ldr	r3, [r2, #0]
   2855a:	9300      	str	r3, [sp, #0]
    (void)dummy;
   2855c:	9b00      	ldr	r3, [sp, #0]
            status |= mask;
   2855e:	e5a9      	b.n	280b4 <GPIOTE_IRQHandler+0x18>
    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
   28560:	2200      	movs	r2, #0
   28562:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
   28564:	681b      	ldr	r3, [r3, #0]
   28566:	9301      	str	r3, [sp, #4]
    return p_reg->IN;
   28568:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    (void)dummy;
   2856c:	9b01      	ldr	r3, [sp, #4]
   2856e:	f8d2 2510 	ldr.w	r2, [r2, #1296]	; 0x510
   28572:	4b31      	ldr	r3, [pc, #196]	; (28638 <GPIOTE_IRQHandler+0x59c>)
        *p_masks = nrf_gpio_port_in_read(gpio_regs[i]);
   28574:	9202      	str	r2, [sp, #8]
    return p_reg->IN;
   28576:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
        *p_masks = nrf_gpio_port_in_read(gpio_regs[i]);
   2857a:	9303      	str	r3, [sp, #12]
    if (status & NRF_GPIOTE_INT_IN_MASK)
   2857c:	2e00      	cmp	r6, #0
   2857e:	f43f ae01 	beq.w	28184 <GPIOTE_IRQHandler+0xe8>
   28582:	e5e0      	b.n	28146 <GPIOTE_IRQHandler+0xaa>
                            if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
   28584:	2903      	cmp	r1, #3
   28586:	f47f af1a 	bne.w	283be <GPIOTE_IRQHandler+0x322>
   2858a:	f44f 3500 	mov.w	r5, #131072	; 0x20000
    reg->PIN_CNF[pin_number] &= ~GPIO_PIN_CNF_SENSE_Msk;
   2858e:	f8dc 3700 	ldr.w	r3, [ip, #1792]	; 0x700
   28592:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
   28596:	f8cc 3700 	str.w	r3, [ip, #1792]	; 0x700
    reg->PIN_CNF[pin_number] |= (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   2859a:	f8dc 3700 	ldr.w	r3, [ip, #1792]	; 0x700
   2859e:	432b      	orrs	r3, r5
   285a0:	f8cc 3700 	str.w	r3, [ip, #1792]	; 0x700
                                ++repeat;
   285a4:	2501      	movs	r5, #1
   285a6:	e70a      	b.n	283be <GPIOTE_IRQHandler+0x322>
                            if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
   285a8:	2903      	cmp	r1, #3
   285aa:	f47f af49 	bne.w	28440 <GPIOTE_IRQHandler+0x3a4>
   285ae:	f44f 3c00 	mov.w	ip, #131072	; 0x20000
    reg->PIN_CNF[pin_number] &= ~GPIO_PIN_CNF_SENSE_Msk;
   285b2:	f8d2 3700 	ldr.w	r3, [r2, #1792]	; 0x700
   285b6:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
   285ba:	f8c2 3700 	str.w	r3, [r2, #1792]	; 0x700
    reg->PIN_CNF[pin_number] |= (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   285be:	f8d2 3700 	ldr.w	r3, [r2, #1792]	; 0x700
                                ++repeat;
   285c2:	3501      	adds	r5, #1
   285c4:	ea4c 0303 	orr.w	r3, ip, r3
   285c8:	b2ed      	uxtb	r5, r5
   285ca:	f8c2 3700 	str.w	r3, [r2, #1792]	; 0x700
   285ce:	e737      	b.n	28440 <GPIOTE_IRQHandler+0x3a4>
                            if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
   285d0:	2903      	cmp	r1, #3
   285d2:	f47f af1c 	bne.w	2840e <GPIOTE_IRQHandler+0x372>
   285d6:	f44f 3c00 	mov.w	ip, #131072	; 0x20000
    reg->PIN_CNF[pin_number] &= ~GPIO_PIN_CNF_SENSE_Msk;
   285da:	f8d2 3700 	ldr.w	r3, [r2, #1792]	; 0x700
   285de:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
   285e2:	f8c2 3700 	str.w	r3, [r2, #1792]	; 0x700
    reg->PIN_CNF[pin_number] |= (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   285e6:	f8d2 3700 	ldr.w	r3, [r2, #1792]	; 0x700
                                ++repeat;
   285ea:	3501      	adds	r5, #1
   285ec:	ea4c 0303 	orr.w	r3, ip, r3
   285f0:	b2ed      	uxtb	r5, r5
   285f2:	f8c2 3700 	str.w	r3, [r2, #1792]	; 0x700
   285f6:	e70a      	b.n	2840e <GPIOTE_IRQHandler+0x372>
   285f8:	f44f 3c00 	mov.w	ip, #131072	; 0x20000
    reg->PIN_CNF[pin_number] &= ~GPIO_PIN_CNF_SENSE_Msk;
   285fc:	f8d2 3700 	ldr.w	r3, [r2, #1792]	; 0x700
   28600:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
   28604:	f8c2 3700 	str.w	r3, [r2, #1792]	; 0x700
    reg->PIN_CNF[pin_number] |= (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   28608:	f8d2 3700 	ldr.w	r3, [r2, #1792]	; 0x700
   2860c:	3501      	adds	r5, #1
   2860e:	ea43 030c 	orr.w	r3, r3, ip
   28612:	b2ed      	uxtb	r5, r5
   28614:	f8c2 3700 	str.w	r3, [r2, #1792]	; 0x700
                            if (handler)
   28618:	f1b9 0f00 	cmp.w	r9, #0
   2861c:	f47f aec6 	bne.w	283ac <GPIOTE_IRQHandler+0x310>
   28620:	e6a4      	b.n	2836c <GPIOTE_IRQHandler+0x2d0>
                            if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
   28622:	f44f 3c40 	mov.w	ip, #196608	; 0x30000
   28626:	e7c4      	b.n	285b2 <GPIOTE_IRQHandler+0x516>
   28628:	f44f 3c40 	mov.w	ip, #196608	; 0x30000
   2862c:	e7d5      	b.n	285da <GPIOTE_IRQHandler+0x53e>
   2862e:	f44f 3540 	mov.w	r5, #196608	; 0x30000
   28632:	e7ac      	b.n	2858e <GPIOTE_IRQHandler+0x4f2>
   28634:	40006000 	.word	0x40006000
   28638:	50000300 	.word	0x50000300

0002863c <UARTE0_UART0_IRQHandler>:
#endif
#if defined(NRFX_PRS_BOX_3_ADDR) && NRFX_CHECK(NRFX_PRS_BOX_3_ENABLED)
PRS_BOX_DEFINE(3)
#endif
#if defined(NRFX_PRS_BOX_4_ADDR) && NRFX_CHECK(NRFX_PRS_BOX_4_ENABLED)
PRS_BOX_DEFINE(4)
   2863c:	4b01      	ldr	r3, [pc, #4]	; (28644 <UARTE0_UART0_IRQHandler+0x8>)
   2863e:	681b      	ldr	r3, [r3, #0]
   28640:	4718      	bx	r3
   28642:	bf00      	nop
   28644:	200021f4 	.word	0x200021f4

00028648 <sd_temp_get>:
 *
 * @param[out] p_temp Result of temperature measurement. Die temperature in 0.25 degrees Celsius.
 *
 * @retval ::NRF_SUCCESS A temperature measurement was done, and the temperature was written to temp
 */
SVCALL(SD_TEMP_GET, uint32_t, sd_temp_get(int32_t * p_temp));
   28648:	df4c      	svc	76	; 0x4c
   2864a:	4770      	bx	lr

0002864c <sd_flash_write>:
* @retval ::NRF_ERROR_BUSY           The previous command has not yet completed.
* @retval ::NRF_ERROR_INVALID_LENGTH Size was 0, or higher than the maximum allowed size.
* @retval ::NRF_ERROR_FORBIDDEN      Tried to write to an address outside the application flash area.
* @retval ::NRF_SUCCESS              The command was accepted.
*/
SVCALL(SD_FLASH_WRITE, uint32_t, sd_flash_write(uint32_t * p_dst, uint32_t const * p_src, uint32_t size));
   2864c:	df29      	svc	41	; 0x29
   2864e:	4770      	bx	lr

00028650 <sd_flash_page_erase>:
* @retval ::NRF_ERROR_INVALID_ADDR  Tried to erase to a non existing flash page.
* @retval ::NRF_ERROR_BUSY          The previous command has not yet completed.
* @retval ::NRF_ERROR_FORBIDDEN     Tried to erase a page outside the application flash area.
* @retval ::NRF_SUCCESS             The command was accepted.
*/
SVCALL(SD_FLASH_PAGE_ERASE, uint32_t, sd_flash_page_erase(uint32_t page_number));
   28650:	df28      	svc	40	; 0x28
   28652:	4770      	bx	lr

00028654 <sd_ble_gap_adv_set_configure>:
 * @retval ::NRF_ERROR_NOT_SUPPORTED                   Unsupported data length or advertising parameter configuration.
 * @retval ::NRF_ERROR_NO_MEM                          Not enough memory to configure a new advertising handle. Update an
 *                                                     existing advertising handle instead.
 * @retval ::BLE_ERROR_GAP_UUID_LIST_MISMATCH Invalid UUID list supplied.
 */
SVCALL(SD_BLE_GAP_ADV_SET_CONFIGURE, uint32_t, sd_ble_gap_adv_set_configure(uint8_t *p_adv_handle, ble_gap_adv_data_t const *p_adv_data, ble_gap_adv_params_t const *p_adv_params));
   28654:	df72      	svc	114	; 0x72
   28656:	4770      	bx	lr

00028658 <sd_ble_gap_adv_start>:
                                            Stop one or more currently active roles (Central, Peripheral, Broadcaster or Observer) and try again.
 *                                        - p_adv_params is configured with connectable advertising, but the event_length parameter
 *                                          associated with conn_cfg_tag is too small to be able to establish a connection on
 *                                          the selected advertising phys. Use @ref sd_ble_cfg_set to increase the event length.
 */
SVCALL(SD_BLE_GAP_ADV_START, uint32_t, sd_ble_gap_adv_start(uint8_t adv_handle, uint8_t conn_cfg_tag));
   28658:	df73      	svc	115	; 0x73
   2865a:	4770      	bx	lr

0002865c <sd_ble_gap_adv_stop>:
 *
 * @retval ::NRF_SUCCESS The BLE stack has stopped advertising.
 * @retval ::BLE_ERROR_INVALID_ADV_HANDLE Invalid advertising handle.
 * @retval ::NRF_ERROR_INVALID_STATE The advertising handle is not advertising.
 */
SVCALL(SD_BLE_GAP_ADV_STOP, uint32_t, sd_ble_gap_adv_stop(uint8_t adv_handle));
   2865c:	df74      	svc	116	; 0x74
   2865e:	4770      	bx	lr

00028660 <sd_ble_gap_tx_power_set>:
 * @retval ::NRF_SUCCESS Successfully changed the transmit power.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
 * @retval ::BLE_ERROR_INVALID_ADV_HANDLE Advertising handle not found.
 * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
 */
SVCALL(SD_BLE_GAP_TX_POWER_SET, uint32_t, sd_ble_gap_tx_power_set(uint8_t role, uint16_t handle, int8_t tx_power));
   28660:	df77      	svc	119	; 0x77
   28662:	4770      	bx	lr

00028664 <sd_ble_gap_ppcp_set>:
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
 * @retval ::NRF_ERROR_NOT_SUPPORTED The characteristic is not included in the Attribute Table,
                                     see @ref ble_gap_cfg_ppcp_incl_cfg_t.
 */
SVCALL(SD_BLE_GAP_PPCP_SET, uint32_t, sd_ble_gap_ppcp_set(ble_gap_conn_params_t const *p_conn_params));
   28664:	df7a      	svc	122	; 0x7a
   28666:	4770      	bx	lr

00028668 <sd_ble_gap_device_name_set>:
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
 * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
 * @retval ::NRF_ERROR_FORBIDDEN Device name is not writable.
 */
SVCALL(SD_BLE_GAP_DEVICE_NAME_SET, uint32_t, sd_ble_gap_device_name_set(ble_gap_conn_sec_mode_t const *p_write_perm, uint8_t const *p_dev_name, uint16_t len));
   28668:	df7c      	svc	124	; 0x7c
   2866a:	4770      	bx	lr

0002866c <sd_ble_gap_device_name_get>:
 *
 * @retval ::NRF_SUCCESS GAP device name retrieved successfully.
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
 * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
 */
SVCALL(SD_BLE_GAP_DEVICE_NAME_GET, uint32_t, sd_ble_gap_device_name_get(uint8_t *p_dev_name, uint16_t *p_len));
   2866c:	df7d      	svc	125	; 0x7d
   2866e:	4770      	bx	lr

00028670 <sd_ble_gap_phy_update>:
 *                               @ref ble_gap_phys_t::tx_phys, @ref ble_gap_phys_t::rx_phys, and @ref ble_gap_data_length_params_t.
 *                               The connection event length is configured with @ref BLE_CONN_CFG_GAP using @ref sd_ble_cfg_set.
 * @retval ::NRF_ERROR_BUSY Procedure is already in progress or not allowed at this time. Process pending events and wait for the pending procedure to complete and retry.
 *
 */
SVCALL(SD_BLE_GAP_PHY_UPDATE, uint32_t, sd_ble_gap_phy_update(uint16_t conn_handle, ble_gap_phys_t const *p_gap_phys));
   28670:	df8f      	svc	143	; 0x8f
   28672:	4770      	bx	lr

00028674 <Flash::evtHandler(unsigned long, void*)>:


                    //sd soc event handler to get success/error from erase/write
SA  evtHandler      (u32 evtId, void* ctx) -> void {
                        Debug( "Flash::handler event : %d\n", evtId );
                        if( evtId == NRF_EVT_FLASH_OPERATION_SUCCESS ){
   28674:	3802      	subs	r0, #2
   28676:	2801      	cmp	r0, #1
   28678:	d802      	bhi.n	28680 <Flash::evtHandler(unsigned long, void*)+0xc>
                            Debug( "    success\n" );
                            dump();
                            busy_ = false;
   2867a:	4b02      	ldr	r3, [pc, #8]	; (28684 <Flash::evtHandler(unsigned long, void*)+0x10>)
   2867c:	2200      	movs	r2, #0
   2867e:	701a      	strb	r2, [r3, #0]
                        }
                        if( evtId == NRF_EVT_FLASH_OPERATION_ERROR ){
                            Debug( "    error\n" );
                            busy_ = false;
                        }
                    }
   28680:	4770      	bx	lr
   28682:	bf00      	nop
   28684:	20002292 	.word	0x20002292

00028688 <ServiceData16::make(unsigned char*, unsigned short, unsigned char*, unsigned char) [clone .constprop.0]>:
    size [4+datlen]
------------------------------------------------------------------------------*/
struct ServiceData16 {

SA  make            (u8* buf, u16 uuid, u8* dat, u8 datlen) {
                        buf[0] = 3 + datlen;
   28688:	4b02      	ldr	r3, [pc, #8]	; (28694 <ServiceData16::make(unsigned char*, unsigned short, unsigned char*, unsigned char) [clone .constprop.0]+0xc>)
   2868a:	6003      	str	r3, [r0, #0]
                        buf[1] = 0x16;
                        buf[2] = uuid;
                        buf[3] = uuid>>8;
                        for( auto i = 4; i < datlen+4; i++ ) buf[i] = *dat++;
   2868c:	780b      	ldrb	r3, [r1, #0]
   2868e:	7103      	strb	r3, [r0, #4]
                        return buf[0] + 1;
                    }
   28690:	2005      	movs	r0, #5
   28692:	4770      	bx	lr
   28694:	180f1604 	.word	0x180f1604

00028698 <Errors::check(short, bool) [clone .constprop.0]>:
struct Errors {

                //if error, show error code 3 times, 
                //reset unless also pass in false
SA  check       (i16 err, bool reboot = true) {
                    if( err == 0 ) return;
   28698:	2800      	cmp	r0, #0
   2869a:	f000 808a 	beq.w	287b2 <Errors::check(short, bool) [clone .constprop.0]+0x11a>
SA  check       (i16 err, bool reboot = true) {
   2869e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   286a2:	4e44      	ldr	r6, [pc, #272]	; (287b4 <Errors::check(short, bool) [clone .constprop.0]+0x11c>)
   286a4:	fa1f f880 	uxth.w	r8, r0
   286a8:	f046 0601 	orr.w	r6, r6, #1
                    if( err == 0 ) return;
   286ac:	f04f 0903 	mov.w	r9, #3
SA  latchOn     ()          { reg.DETECTMODE = 1; }

//------------
//  status
//------------
SA  isOutput    ()          { return reg.DIRP; }
   286b0:	f04f 44a0 	mov.w	r4, #1342177280	; 0x50000000

            //show error code via led's, skip leading 0's
            //show 1-15 blinks for each nibble (0x01-0x0f)
            //a zero will be a short blue blink
SA  error   (u16 hex) {
                bool lz = true;
   286b4:	2501      	movs	r5, #1
                for( auto i = 12; i >= 0; i -= 4 ){
   286b6:	270c      	movs	r7, #12
                    u8 v = (hex>>i) bitand 0xf;
   286b8:	fa48 f307 	asr.w	r3, r8, r7
                    if( v == 0 and lz == true ) continue; //skip leading 0's
   286bc:	f013 030f 	ands.w	r3, r3, #15
   286c0:	d04e      	beq.n	28760 <Errors::check(short, bool) [clone .constprop.0]+0xc8>
   286c2:	f8d4 2720 	ldr.w	r2, [r4, #1824]	; 0x720
                //in places that sets a peripheral pin
                //  PSEL.SCA = board.sca.pinNumber();
SCA pinNumber   ()          { return Pin_; }

SA  blinkN      (uint16_t n, uint32_t mson, uint32_t msoff = 0, uint32_t lastdelayms = 0) {
                    if( not isOutput() ) return;
   286c6:	07d5      	lsls	r5, r2, #31
   286c8:	d529      	bpl.n	2871e <Errors::check(short, bool) [clone .constprop.0]+0x86>
                    if( not msoff ) msoff = mson;
                    while( n-- ){ 
   286ca:	3b01      	subs	r3, #1
   286cc:	b29d      	uxth	r5, r3
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   286ce:	f44f 7a80 	mov.w	sl, #256	; 0x100
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   286d2:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504
   286d6:	05d8      	lsls	r0, r3, #23
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   286d8:	bf4c      	ite	mi
   286da:	f8c4 a50c 	strmi.w	sl, [r4, #1292]	; 0x50c
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   286de:	f8c4 a508 	strpl.w	sl, [r4, #1288]	; 0x508
                for( auto i = 12; i >= 0; i -= 4 ){
   286e2:	f44f 7bfa 	mov.w	fp, #500	; 0x1f4
   286e6:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   286ea:	47b0      	blx	r6
        return;
    }

    do {
        nrf_delay_us(1000);
    } while (--ms_time);
   286ec:	f1bb 0b01 	subs.w	fp, fp, #1
   286f0:	d1f9      	bne.n	286e6 <Errors::check(short, bool) [clone .constprop.0]+0x4e>
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   286f2:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504
   286f6:	05d9      	lsls	r1, r3, #23
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   286f8:	bf4c      	ite	mi
   286fa:	f8c4 a50c 	strmi.w	sl, [r4, #1292]	; 0x50c
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   286fe:	f8c4 a508 	strpl.w	sl, [r4, #1288]	; 0x508
   28702:	f44f 7bfa 	mov.w	fp, #500	; 0x1f4
   28706:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   2870a:	47b0      	blx	r6
   2870c:	f1bb 0b01 	subs.w	fp, fp, #1
   28710:	d1f9      	bne.n	28706 <Errors::check(short, bool) [clone .constprop.0]+0x6e>
                    while( n-- ){ 
   28712:	3d01      	subs	r5, #1
   28714:	b2ad      	uxth	r5, r5
   28716:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2871a:	429d      	cmp	r5, r3
   2871c:	d1d9      	bne.n	286d2 <Errors::check(short, bool) [clone .constprop.0]+0x3a>
   2871e:	f44f 75fa 	mov.w	r5, #500	; 0x1f4
   28722:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   28726:	47b0      	blx	r6
   28728:	3d01      	subs	r5, #1
   2872a:	d1fa      	bne.n	28722 <Errors::check(short, bool) [clone .constprop.0]+0x8a>
   2872c:	3f04      	subs	r7, #4
   2872e:	1d3b      	adds	r3, r7, #4
   28730:	d1c2      	bne.n	286b8 <Errors::check(short, bool) [clone .constprop.0]+0x20>
   28732:	f640 35b8 	movw	r5, #3000	; 0xbb8
   28736:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   2873a:	47b0      	blx	r6
   2873c:	3d01      	subs	r5, #1
   2873e:	d1fa      	bne.n	28736 <Errors::check(short, bool) [clone .constprop.0]+0x9e>
                    Debug( FG RED "Error: %d\n" ANSI_NORMAL, err );
                    for( auto i = 0; i < 3; i++ ){
   28740:	f1b9 0901 	subs.w	r9, r9, #1
   28744:	d1b6      	bne.n	286b4 <Errors::check(short, bool) [clone .constprop.0]+0x1c>
  __ASM volatile ("dsb 0xF":::"memory");
   28746:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   2874a:	491b      	ldr	r1, [pc, #108]	; (287b8 <Errors::check(short, bool) [clone .constprop.0]+0x120>)
   2874c:	4b1b      	ldr	r3, [pc, #108]	; (287bc <Errors::check(short, bool) [clone .constprop.0]+0x124>)
   2874e:	68ca      	ldr	r2, [r1, #12]
   28750:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   28754:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   28756:	60cb      	str	r3, [r1, #12]
   28758:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
   2875c:	bf00      	nop
   2875e:	e7fd      	b.n	2875c <Errors::check(short, bool) [clone .constprop.0]+0xc4>
                    if( v == 0 and lz == true ) continue; //skip leading 0's
   28760:	2d00      	cmp	r5, #0
   28762:	d1e3      	bne.n	2872c <Errors::check(short, bool) [clone .constprop.0]+0x94>
SA  isOutput    ()          { return reg.DIRP; }
   28764:	f8d4 3730 	ldr.w	r3, [r4, #1840]	; 0x730
                    if( not isOutput() ) return;
   28768:	07da      	lsls	r2, r3, #31
   2876a:	d5d8      	bpl.n	2871e <Errors::check(short, bool) [clone .constprop.0]+0x86>
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   2876c:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504
   28770:	f413 5f80 	tst.w	r3, #4096	; 0x1000
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   28774:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   28778:	bf14      	ite	ne
   2877a:	f8c4 350c 	strne.w	r3, [r4, #1292]	; 0x50c
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   2877e:	f8c4 3508 	streq.w	r3, [r4, #1288]	; 0x508
                for( auto i = 12; i >= 0; i -= 4 ){
   28782:	2532      	movs	r5, #50	; 0x32
   28784:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   28788:	47b0      	blx	r6
   2878a:	3d01      	subs	r5, #1
   2878c:	d1fa      	bne.n	28784 <Errors::check(short, bool) [clone .constprop.0]+0xec>
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   2878e:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504
   28792:	f413 5f80 	tst.w	r3, #4096	; 0x1000
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   28796:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   2879a:	bf14      	ite	ne
   2879c:	f8c4 350c 	strne.w	r3, [r4, #1292]	; 0x50c
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   287a0:	f8c4 3508 	streq.w	r3, [r4, #1288]	; 0x508
   287a4:	2532      	movs	r5, #50	; 0x32
   287a6:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   287aa:	47b0      	blx	r6
   287ac:	3d01      	subs	r5, #1
   287ae:	d1fa      	bne.n	287a6 <Errors::check(short, bool) [clone .constprop.0]+0x10e>
   287b0:	e7b5      	b.n	2871e <Errors::check(short, bool) [clone .constprop.0]+0x86>
   287b2:	4770      	bx	lr
   287b4:	0002bd20 	.word	0x0002bd20
   287b8:	e000ed00 	.word	0xe000ed00
   287bc:	05fa0004 	.word	0x05fa0004

000287c0 <Pca10059::init()>:
SA  init    () {
   287c0:	b430      	push	{r4, r5}
   287c2:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   287c6:	490f      	ldr	r1, [pc, #60]	; (28804 <Pca10059::init()+0x44>)
SA  init        (Ts... ts)  { initT it{2}; init_(it, ts...); }
   287c8:	2201      	movs	r2, #1
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   287ca:	2440      	movs	r4, #64	; 0x40
   287cc:	f44f 7000 	mov.w	r0, #512	; 0x200
   287d0:	f8c3 4508 	str.w	r4, [r3, #1288]	; 0x508
   287d4:	f44f 7580 	mov.w	r5, #256	; 0x100
                    reg.PIN_CNF = it.INIT_CNF;
   287d8:	f8c3 2718 	str.w	r2, [r3, #1816]	; 0x718
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   287dc:	f44f 5480 	mov.w	r4, #4096	; 0x1000
   287e0:	f8c1 0508 	str.w	r0, [r1, #1288]	; 0x508
SA  init        (Ts... ts)  { initT it{2}; init_(it, ts...); }
   287e4:	200c      	movs	r0, #12
                    reg.PIN_CNF = it.INIT_CNF;
   287e6:	f8c1 2724 	str.w	r2, [r1, #1828]	; 0x724
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   287ea:	f8c3 5508 	str.w	r5, [r3, #1288]	; 0x508
                    reg.PIN_CNF = it.INIT_CNF;
   287ee:	f8c3 2720 	str.w	r2, [r3, #1824]	; 0x720
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   287f2:	f8c3 4508 	str.w	r4, [r3, #1288]	; 0x508
                    reg.PIN_CNF = it.INIT_CNF;
   287f6:	f8c3 2730 	str.w	r2, [r3, #1840]	; 0x730
   287fa:	f8c1 0718 	str.w	r0, [r1, #1816]	; 0x718
            }
   287fe:	bc30      	pop	{r4, r5}
   28800:	4770      	bx	lr
   28802:	bf00      	nop
   28804:	50000300 	.word	0x50000300

00028808 <Pca10059::alive()>:
SA  alive   () {
   28808:	b538      	push	{r3, r4, r5, lr}
SA  isOutput    ()          { return reg.DIRP; }
   2880a:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   2880e:	f8d3 2718 	ldr.w	r2, [r3, #1816]	; 0x718
                    if( not isOutput() ) return;
   28812:	07d1      	lsls	r1, r2, #31
   28814:	d52c      	bpl.n	28870 <Pca10059::alive()+0x68>
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   28816:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   2881a:	4c65      	ldr	r4, [pc, #404]	; (289b0 <Pca10059::alive()+0x1a8>)
   2881c:	f012 0f40 	tst.w	r2, #64	; 0x40
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   28820:	f04f 0240 	mov.w	r2, #64	; 0x40
   28824:	bf14      	ite	ne
   28826:	f8c3 250c 	strne.w	r2, [r3, #1292]	; 0x50c
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   2882a:	f8c3 2508 	streq.w	r2, [r3, #1288]	; 0x508
   2882e:	2519      	movs	r5, #25
   28830:	f044 0401 	orr.w	r4, r4, #1
   28834:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   28838:	47a0      	blx	r4
   2883a:	3d01      	subs	r5, #1
   2883c:	d1fa      	bne.n	28834 <Pca10059::alive()+0x2c>
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   2883e:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   28842:	2519      	movs	r5, #25
   28844:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   28848:	f012 0f40 	tst.w	r2, #64	; 0x40
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   2884c:	f04f 0240 	mov.w	r2, #64	; 0x40
   28850:	bf14      	ite	ne
   28852:	f8c3 250c 	strne.w	r2, [r3, #1292]	; 0x50c
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   28856:	f8c3 2508 	streq.w	r2, [r3, #1288]	; 0x508
   2885a:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   2885e:	47a0      	blx	r4
   28860:	3d01      	subs	r5, #1
   28862:	d1fa      	bne.n	2885a <Pca10059::alive()+0x52>
   28864:	25c8      	movs	r5, #200	; 0xc8
   28866:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   2886a:	47a0      	blx	r4
   2886c:	3d01      	subs	r5, #1
   2886e:	d1fa      	bne.n	28866 <Pca10059::alive()+0x5e>
SA  isOutput    ()          { return reg.DIRP; }
   28870:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   28874:	f8d3 2720 	ldr.w	r2, [r3, #1824]	; 0x720
                    if( not isOutput() ) return;
   28878:	07d2      	lsls	r2, r2, #31
   2887a:	d52a      	bpl.n	288d2 <Pca10059::alive()+0xca>
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   2887c:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   28880:	05d1      	lsls	r1, r2, #23
   28882:	f140 808a 	bpl.w	2899a <Pca10059::alive()+0x192>
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   28886:	f44f 7280 	mov.w	r2, #256	; 0x100
   2888a:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
   2888e:	4c48      	ldr	r4, [pc, #288]	; (289b0 <Pca10059::alive()+0x1a8>)
   28890:	2519      	movs	r5, #25
   28892:	f044 0401 	orr.w	r4, r4, #1
   28896:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   2889a:	47a0      	blx	r4
   2889c:	3d01      	subs	r5, #1
   2889e:	d1fa      	bne.n	28896 <Pca10059::alive()+0x8e>
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   288a0:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   288a4:	2519      	movs	r5, #25
   288a6:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   288aa:	f412 7f80 	tst.w	r2, #256	; 0x100
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   288ae:	f44f 7280 	mov.w	r2, #256	; 0x100
   288b2:	bf14      	ite	ne
   288b4:	f8c3 250c 	strne.w	r2, [r3, #1292]	; 0x50c
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   288b8:	f8c3 2508 	streq.w	r2, [r3, #1288]	; 0x508
   288bc:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   288c0:	47a0      	blx	r4
   288c2:	3d01      	subs	r5, #1
   288c4:	d1fa      	bne.n	288bc <Pca10059::alive()+0xb4>
   288c6:	25c8      	movs	r5, #200	; 0xc8
   288c8:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   288cc:	47a0      	blx	r4
   288ce:	3d01      	subs	r5, #1
   288d0:	d1fa      	bne.n	288c8 <Pca10059::alive()+0xc0>
SA  isOutput    ()          { return reg.DIRP; }
   288d2:	4b38      	ldr	r3, [pc, #224]	; (289b4 <Pca10059::alive()+0x1ac>)
   288d4:	f8d3 2724 	ldr.w	r2, [r3, #1828]	; 0x724
                    if( not isOutput() ) return;
   288d8:	07d0      	lsls	r0, r2, #31
   288da:	d528      	bpl.n	2892e <Pca10059::alive()+0x126>
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   288dc:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   288e0:	0594      	lsls	r4, r2, #22
   288e2:	d55f      	bpl.n	289a4 <Pca10059::alive()+0x19c>
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   288e4:	f44f 7200 	mov.w	r2, #512	; 0x200
   288e8:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
   288ec:	4c30      	ldr	r4, [pc, #192]	; (289b0 <Pca10059::alive()+0x1a8>)
   288ee:	2519      	movs	r5, #25
   288f0:	f044 0401 	orr.w	r4, r4, #1
   288f4:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   288f8:	47a0      	blx	r4
   288fa:	3d01      	subs	r5, #1
   288fc:	d1fa      	bne.n	288f4 <Pca10059::alive()+0xec>
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   288fe:	4b2d      	ldr	r3, [pc, #180]	; (289b4 <Pca10059::alive()+0x1ac>)
   28900:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   28904:	f412 7f00 	tst.w	r2, #512	; 0x200
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   28908:	f44f 7200 	mov.w	r2, #512	; 0x200
   2890c:	bf14      	ite	ne
   2890e:	f8c3 250c 	strne.w	r2, [r3, #1292]	; 0x50c
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   28912:	f8c3 2508 	streq.w	r2, [r3, #1288]	; 0x508
   28916:	2519      	movs	r5, #25
   28918:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   2891c:	47a0      	blx	r4
   2891e:	3d01      	subs	r5, #1
   28920:	d1fa      	bne.n	28918 <Pca10059::alive()+0x110>
   28922:	25c8      	movs	r5, #200	; 0xc8
   28924:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   28928:	47a0      	blx	r4
   2892a:	3d01      	subs	r5, #1
   2892c:	d1fa      	bne.n	28924 <Pca10059::alive()+0x11c>
SA  isOutput    ()          { return reg.DIRP; }
   2892e:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   28932:	f8d3 2730 	ldr.w	r2, [r3, #1840]	; 0x730
                    if( not isOutput() ) return;
   28936:	07d5      	lsls	r5, r2, #31
   28938:	d529      	bpl.n	2898e <Pca10059::alive()+0x186>
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   2893a:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   2893e:	04d2      	lsls	r2, r2, #19
   28940:	d526      	bpl.n	28990 <Pca10059::alive()+0x188>
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   28942:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   28946:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
   2894a:	4c19      	ldr	r4, [pc, #100]	; (289b0 <Pca10059::alive()+0x1a8>)
   2894c:	2519      	movs	r5, #25
   2894e:	f044 0401 	orr.w	r4, r4, #1
   28952:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   28956:	47a0      	blx	r4
   28958:	3d01      	subs	r5, #1
   2895a:	d1fa      	bne.n	28952 <Pca10059::alive()+0x14a>
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   2895c:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   28960:	2519      	movs	r5, #25
   28962:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   28966:	f412 5f80 	tst.w	r2, #4096	; 0x1000
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   2896a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   2896e:	bf14      	ite	ne
   28970:	f8c3 250c 	strne.w	r2, [r3, #1292]	; 0x50c
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   28974:	f8c3 2508 	streq.w	r2, [r3, #1288]	; 0x508
   28978:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   2897c:	47a0      	blx	r4
   2897e:	3d01      	subs	r5, #1
   28980:	d1fa      	bne.n	28978 <Pca10059::alive()+0x170>
   28982:	25c8      	movs	r5, #200	; 0xc8
   28984:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   28988:	47a0      	blx	r4
   2898a:	3d01      	subs	r5, #1
   2898c:	d1fa      	bne.n	28984 <Pca10059::alive()+0x17c>
            }
   2898e:	bd38      	pop	{r3, r4, r5, pc}
   28990:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   28994:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
   28998:	e7d7      	b.n	2894a <Pca10059::alive()+0x142>
   2899a:	f44f 7280 	mov.w	r2, #256	; 0x100
   2899e:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
   289a2:	e774      	b.n	2888e <Pca10059::alive()+0x86>
   289a4:	f44f 7200 	mov.w	r2, #512	; 0x200
   289a8:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
   289ac:	e79e      	b.n	288ec <Pca10059::alive()+0xe4>
   289ae:	bf00      	nop
   289b0:	0002bd20 	.word	0x0002bd20
   289b4:	50000300 	.word	0x50000300

000289b8 <Saadc::isBusy()>:
    reg { *(reinterpret_cast<Saadc_*>(base_)) };

//--------------------
//  control, status
//--------------------
SA  isBusy          ()          { return reg.STATUS; } //conversion in progress?
   289b8:	4b01      	ldr	r3, [pc, #4]	; (289c0 <Saadc::isBusy()+0x8>)
   289ba:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
   289be:	4770      	bx	lr
   289c0:	40007000 	.word	0x40007000

000289c4 <Saadc::enable()>:
SA  enable          ()          { reg.ENABLE = 1; }
   289c4:	4b02      	ldr	r3, [pc, #8]	; (289d0 <Saadc::enable()+0xc>)
   289c6:	2201      	movs	r2, #1
   289c8:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
   289cc:	4770      	bx	lr
   289ce:	bf00      	nop
   289d0:	40007000 	.word	0x40007000

000289d4 <Saadc::disable()>:
SA  disable         ()          { reg.ENABLE = 0; }
   289d4:	4b02      	ldr	r3, [pc, #8]	; (289e0 <Saadc::disable()+0xc>)
   289d6:	2200      	movs	r2, #0
   289d8:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
   289dc:	4770      	bx	lr
   289de:	bf00      	nop
   289e0:	40007000 	.word	0x40007000

000289e4 <Saadc::clearStarted()>:
SA  isEnabled       ()          { return reg.ENABLE; }

//--------------------
//  events
//--------------------
SA  clearStarted    ()          { reg.EVENTS.STARTED = 0; }
   289e4:	4b02      	ldr	r3, [pc, #8]	; (289f0 <Saadc::clearStarted()+0xc>)
   289e6:	2200      	movs	r2, #0
   289e8:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   289ec:	4770      	bx	lr
   289ee:	bf00      	nop
   289f0:	40007000 	.word	0x40007000

000289f4 <Saadc::clearBufferFull()>:
SA  clearBufferFull ()          { reg.EVENTS.END = 0; }
   289f4:	4b02      	ldr	r3, [pc, #8]	; (28a00 <Saadc::clearBufferFull()+0xc>)
   289f6:	2200      	movs	r2, #0
   289f8:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   289fc:	4770      	bx	lr
   289fe:	bf00      	nop
   28a00:	40007000 	.word	0x40007000

00028a04 <Saadc::clearConversion()>:
SA  clearConversion ()          { reg.EVENTS.DONE = 0; }
   28a04:	4b02      	ldr	r3, [pc, #8]	; (28a10 <Saadc::clearConversion()+0xc>)
   28a06:	2200      	movs	r2, #0
   28a08:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   28a0c:	4770      	bx	lr
   28a0e:	bf00      	nop
   28a10:	40007000 	.word	0x40007000

00028a14 <Saadc::clearResult()>:
SA  clearResult     ()          { reg.EVENTS.RESULTDONE = 0; }
   28a14:	4b02      	ldr	r3, [pc, #8]	; (28a20 <Saadc::clearResult()+0xc>)
   28a16:	2200      	movs	r2, #0
   28a18:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
   28a1c:	4770      	bx	lr
   28a1e:	bf00      	nop
   28a20:	40007000 	.word	0x40007000

00028a24 <Saadc::clearCalibrated()>:
SA  clearCalibrated ()          { reg.EVENTS.CALIBRATEDONE = 0; }
   28a24:	4b02      	ldr	r3, [pc, #8]	; (28a30 <Saadc::clearCalibrated()+0xc>)
   28a26:	2200      	movs	r2, #0
   28a28:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
   28a2c:	4770      	bx	lr
   28a2e:	bf00      	nop
   28a30:	40007000 	.word	0x40007000

00028a34 <Saadc::clearStopped()>:
SA  clearStopped    ()          { reg.EVENTS.STOPPED = 0; }
   28a34:	4b02      	ldr	r3, [pc, #8]	; (28a40 <Saadc::clearStopped()+0xc>)
   28a36:	2200      	movs	r2, #0
   28a38:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
   28a3c:	4770      	bx	lr
   28a3e:	bf00      	nop
   28a40:	40007000 	.word	0x40007000

00028a44 <Saadc::clearEvents()>:
SA  clearLimitHigh  (CH e)      { reg.EVENTS.LIMIT[e].H = 0; }
SA  clearLimitLow   (CH e)      { reg.EVENTS.LIMIT[e].L = 0; }
SA  clearEvents     ()          { 
   28a44:	b508      	push	{r3, lr}
                                    clearStarted();
   28a46:	f7ff ffcd 	bl	289e4 <Saadc::clearStarted()>
                                    clearBufferFull();
   28a4a:	f7ff ffd3 	bl	289f4 <Saadc::clearBufferFull()>
                                    clearConversion();
   28a4e:	f7ff ffd9 	bl	28a04 <Saadc::clearConversion()>
                                    clearResult();
   28a52:	f7ff ffdf 	bl	28a14 <Saadc::clearResult()>
                                    clearStopped();
   28a56:	f7ff ffed 	bl	28a34 <Saadc::clearStopped()>
                                }
   28a5a:	bd08      	pop	{r3, pc}

00028a5c <Saadc::isResult()>:

SA  isStarted       ()          { return reg.EVENTS.STARTED; }
SA  isBufferFull    ()          { return reg.EVENTS.END; } //ram buffer is filled
SA  isConversion    ()          { return reg.EVENTS.DONE; } //a conversion was done
SA  isResult        ()          { return reg.EVENTS.RESULTDONE; } //when conversion(s) stored to ram
   28a5c:	4b01      	ldr	r3, [pc, #4]	; (28a64 <Saadc::isResult()+0x8>)
   28a5e:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
   28a62:	4770      	bx	lr
   28a64:	40007000 	.word	0x40007000

00028a68 <Saadc::isCalibrated()>:
SA  isCalibrated    ()          { return reg.EVENTS.CALIBRATEDONE; }
   28a68:	4b01      	ldr	r3, [pc, #4]	; (28a70 <Saadc::isCalibrated()+0x8>)
   28a6a:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
   28a6e:	4770      	bx	lr
   28a70:	40007000 	.word	0x40007000

00028a74 <Saadc::start()>:
SA  isLimitLow      (CH e)      { return reg.EVENTS.LIMIT[e].L; }

//--------------------
//  tasks
//--------------------
SA  start           ()          { enable(); reg.TASKS.START = 1; } 
   28a74:	b508      	push	{r3, lr}
   28a76:	f7ff ffa5 	bl	289c4 <Saadc::enable()>
   28a7a:	4b02      	ldr	r3, [pc, #8]	; (28a84 <Saadc::start()+0x10>)
   28a7c:	2201      	movs	r2, #1
   28a7e:	601a      	str	r2, [r3, #0]
   28a80:	bd08      	pop	{r3, pc}
   28a82:	bf00      	nop
   28a84:	40007000 	.word	0x40007000

00028a88 <Saadc::sample()>:
SA  sample          ()          { reg.TASKS.SAMPLE = 1; } 
   28a88:	4b01      	ldr	r3, [pc, #4]	; (28a90 <Saadc::sample()+0x8>)
   28a8a:	2201      	movs	r2, #1
   28a8c:	605a      	str	r2, [r3, #4]
   28a8e:	4770      	bx	lr
   28a90:	40007000 	.word	0x40007000

00028a94 <Saadc::calibrate()>:
SA  stop            ()          { reg.TASKS.STOP = 1; } 
SA  calibrate       ()          {   
   28a94:	b508      	push	{r3, lr}
                                    enable();
   28a96:	f7ff ff95 	bl	289c4 <Saadc::enable()>
                                    reg.TASKS.CALIBRATE = 1;
   28a9a:	4b05      	ldr	r3, [pc, #20]	; (28ab0 <Saadc::calibrate()+0x1c>)
   28a9c:	2201      	movs	r2, #1
   28a9e:	60da      	str	r2, [r3, #12]
                                    while( not isCalibrated() );
   28aa0:	f7ff ffe2 	bl	28a68 <Saadc::isCalibrated()>
   28aa4:	2800      	cmp	r0, #0
   28aa6:	d0fb      	beq.n	28aa0 <Saadc::calibrate()+0xc>
                                    clearCalibrated();
   28aa8:	f7ff ffbc 	bl	28a24 <Saadc::clearCalibrated()>
                                    //leave enabled
                                }
   28aac:	bd08      	pop	{r3, pc}
   28aae:	bf00      	nop
   28ab0:	40007000 	.word	0x40007000

00028ab4 <Saadc::channelSetup(Saadc::CH, unsigned long, Saadc::PSEL, Saadc::PSEL)>:

//--------------------
//  channel config
//--------------------
SA  isChannelUsed   (CH e)      { return inuse_ bitand (1<<e); }
SA  channelSetup    (CH e, u32 cfg, PSEL p, PSEL n = NC) { 
   28ab4:	b470      	push	{r4, r5, r6}
                                    if( p or n ) inuse_ or_eq (1<<e);
   28ab6:	ea52 0403 	orrs.w	r4, r2, r3
   28aba:	d005      	beq.n	28ac8 <Saadc::channelSetup(Saadc::CH, unsigned long, Saadc::PSEL, Saadc::PSEL)+0x14>
   28abc:	4d09      	ldr	r5, [pc, #36]	; (28ae4 <Saadc::channelSetup(Saadc::CH, unsigned long, Saadc::PSEL, Saadc::PSEL)+0x30>)
   28abe:	2401      	movs	r4, #1
   28ac0:	782e      	ldrb	r6, [r5, #0]
   28ac2:	4084      	lsls	r4, r0
   28ac4:	4334      	orrs	r4, r6
   28ac6:	702c      	strb	r4, [r5, #0]
                                    reg.CHCONFIG[e].PSELP = p;
   28ac8:	0100      	lsls	r0, r0, #4
   28aca:	f100 4480 	add.w	r4, r0, #1073741824	; 0x40000000
   28ace:	f504 44e0 	add.w	r4, r4, #28672	; 0x7000
   28ad2:	f8c4 2510 	str.w	r2, [r4, #1296]	; 0x510
                                    reg.CHCONFIG[e].PSELN = n; 
   28ad6:	f8c4 3514 	str.w	r3, [r4, #1300]	; 0x514
                                    reg.CHCONFIG[e].CONFIG = cfg;                      
   28ada:	f8c4 1518 	str.w	r1, [r4, #1304]	; 0x518
                                }
   28ade:	bc70      	pop	{r4, r5, r6}
   28ae0:	4770      	bx	lr
   28ae2:	bf00      	nop
   28ae4:	200022bf 	.word	0x200022bf

00028ae8 <Saadc::channelRelease(Saadc::CH)>:
SA  channelRelease  (CH e)      {
   28ae8:	b410      	push	{r4}
                                    inuse_ and_eq compl (1<<e); 
   28aea:	4c0a      	ldr	r4, [pc, #40]	; (28b14 <Saadc::channelRelease(Saadc::CH)+0x2c>)
   28aec:	0103      	lsls	r3, r0, #4
   28aee:	7822      	ldrb	r2, [r4, #0]
   28af0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   28af4:	2101      	movs	r1, #1
   28af6:	f503 43e0 	add.w	r3, r3, #28672	; 0x7000
   28afa:	fa01 f000 	lsl.w	r0, r1, r0
   28afe:	ea22 0000 	bic.w	r0, r2, r0
                                    reg.CHCONFIG[e].PSELP = NC;
   28b02:	2200      	movs	r2, #0
   28b04:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
                                    reg.CHCONFIG[e].PSELN = NC;
   28b08:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
                                    inuse_ and_eq compl (1<<e); 
   28b0c:	7020      	strb	r0, [r4, #0]
                                }
   28b0e:	f85d 4b04 	ldr.w	r4, [sp], #4
   28b12:	4770      	bx	lr
   28b14:	200022bf 	.word	0x200022bf

00028b18 <Saadc::channelOnly(Saadc::CH)>:
SA  channelOnly     (CH e)      {
   28b18:	b510      	push	{r4, lr}
                                    for( int i = CH0; i <= CH7; i++ ){
                                        if( e != i ) channelRelease( (CH)i );
   28b1a:	4604      	mov	r4, r0
   28b1c:	bb08      	cbnz	r0, 28b62 <Saadc::channelOnly(Saadc::CH)+0x4a>
   28b1e:	2001      	movs	r0, #1
   28b20:	f7ff ffe2 	bl	28ae8 <Saadc::channelRelease(Saadc::CH)>
   28b24:	2002      	movs	r0, #2
   28b26:	f7ff ffdf 	bl	28ae8 <Saadc::channelRelease(Saadc::CH)>
   28b2a:	2c03      	cmp	r4, #3
   28b2c:	d10b      	bne.n	28b46 <Saadc::channelOnly(Saadc::CH)+0x2e>
   28b2e:	2004      	movs	r0, #4
   28b30:	f7ff ffda 	bl	28ae8 <Saadc::channelRelease(Saadc::CH)>
   28b34:	2005      	movs	r0, #5
   28b36:	f7ff ffd7 	bl	28ae8 <Saadc::channelRelease(Saadc::CH)>
   28b3a:	2c06      	cmp	r4, #6
   28b3c:	d10b      	bne.n	28b56 <Saadc::channelOnly(Saadc::CH)+0x3e>
   28b3e:	2007      	movs	r0, #7
   28b40:	f7ff ffd2 	bl	28ae8 <Saadc::channelRelease(Saadc::CH)>
                                    }
                                }
   28b44:	bd10      	pop	{r4, pc}
                                        if( e != i ) channelRelease( (CH)i );
   28b46:	2003      	movs	r0, #3
   28b48:	f7ff ffce 	bl	28ae8 <Saadc::channelRelease(Saadc::CH)>
   28b4c:	2c04      	cmp	r4, #4
   28b4e:	d115      	bne.n	28b7c <Saadc::channelOnly(Saadc::CH)+0x64>
   28b50:	2005      	movs	r0, #5
   28b52:	f7ff ffc9 	bl	28ae8 <Saadc::channelRelease(Saadc::CH)>
   28b56:	2006      	movs	r0, #6
   28b58:	f7ff ffc6 	bl	28ae8 <Saadc::channelRelease(Saadc::CH)>
   28b5c:	2c07      	cmp	r4, #7
   28b5e:	d1ee      	bne.n	28b3e <Saadc::channelOnly(Saadc::CH)+0x26>
                                }
   28b60:	bd10      	pop	{r4, pc}
                                        if( e != i ) channelRelease( (CH)i );
   28b62:	2000      	movs	r0, #0
   28b64:	f7ff ffc0 	bl	28ae8 <Saadc::channelRelease(Saadc::CH)>
   28b68:	2c01      	cmp	r4, #1
   28b6a:	d0db      	beq.n	28b24 <Saadc::channelOnly(Saadc::CH)+0xc>
   28b6c:	2001      	movs	r0, #1
   28b6e:	f7ff ffbb 	bl	28ae8 <Saadc::channelRelease(Saadc::CH)>
   28b72:	2c02      	cmp	r4, #2
   28b74:	d1d6      	bne.n	28b24 <Saadc::channelOnly(Saadc::CH)+0xc>
   28b76:	2003      	movs	r0, #3
   28b78:	f7ff ffb6 	bl	28ae8 <Saadc::channelRelease(Saadc::CH)>
   28b7c:	2004      	movs	r0, #4
   28b7e:	f7ff ffb3 	bl	28ae8 <Saadc::channelRelease(Saadc::CH)>
   28b82:	2c05      	cmp	r4, #5
   28b84:	d1d6      	bne.n	28b34 <Saadc::channelOnly(Saadc::CH)+0x1c>
   28b86:	2006      	movs	r0, #6
   28b88:	f7ff ffae 	bl	28ae8 <Saadc::channelRelease(Saadc::CH)>
   28b8c:	e7d7      	b.n	28b3e <Saadc::channelOnly(Saadc::CH)+0x26>
   28b8e:	bf00      	nop

00028b90 <Saadc::resolution(Saadc::RES)>:
SA  limitHL         (CH e, i16 H, i16 L) { limitH(e,H); limitL(e,L); }

//--------------------
//  config
//--------------------
SA  resolution      (RES e)         { reg.RESOLUTION = e; }
   28b90:	4b01      	ldr	r3, [pc, #4]	; (28b98 <Saadc::resolution(Saadc::RES)+0x8>)
   28b92:	f8c3 05f0 	str.w	r0, [r3, #1520]	; 0x5f0
   28b96:	4770      	bx	lr
   28b98:	40007000 	.word	0x40007000

00028b9c <Saadc::resolution()>:
SA  resolution      ()              { return RES(reg.RESOLUTION); }
   28b9c:	4b02      	ldr	r3, [pc, #8]	; (28ba8 <Saadc::resolution()+0xc>)
   28b9e:	f8d3 05f0 	ldr.w	r0, [r3, #1520]	; 0x5f0
   28ba2:	b2c0      	uxtb	r0, r0
   28ba4:	4770      	bx	lr
   28ba6:	bf00      	nop
   28ba8:	40007000 	.word	0x40007000

00028bac <Saadc::overSample(Saadc::OVERSAMP)>:

SA  overSample      (OVERSAMP e)    { reg.OVERSAMPLE = e; }
   28bac:	4b01      	ldr	r3, [pc, #4]	; (28bb4 <Saadc::overSample(Saadc::OVERSAMP)+0x8>)
   28bae:	f8c3 05f4 	str.w	r0, [r3, #1524]	; 0x5f4
   28bb2:	4770      	bx	lr
   28bb4:	40007000 	.word	0x40007000

00028bb8 <Saadc::overSample()>:
SA  overSample      ()              { return OVERSAMP(reg.OVERSAMPLE); }
   28bb8:	4b02      	ldr	r3, [pc, #8]	; (28bc4 <Saadc::overSample()+0xc>)
   28bba:	f8d3 05f4 	ldr.w	r0, [r3, #1524]	; 0x5f4
   28bbe:	b2c0      	uxtb	r0, r0
   28bc0:	4770      	bx	lr
   28bc2:	bf00      	nop
   28bc4:	40007000 	.word	0x40007000

00028bc8 <Saadc::bufferAddr(unsigned long)>:
                                        if( v > 2047 ) v =2047;
                                        reg.SAMPLERATE = v bitor (1<<12);
                                    }
SA  sampleRateTask  ()              { reg.SAMPLERATE = 0; }

SA  bufferAddr      (u32 v)         { reg.RESULTPTR = v; }
   28bc8:	4b01      	ldr	r3, [pc, #4]	; (28bd0 <Saadc::bufferAddr(unsigned long)+0x8>)
   28bca:	f8c3 062c 	str.w	r0, [r3, #1580]	; 0x62c
   28bce:	4770      	bx	lr
   28bd0:	40007000 	.word	0x40007000

00028bd4 <Saadc::bufferSize(unsigned short)>:
SA  bufferAddr      ()              { return reg.RESULTPTR; }
SA  bufferSize      (u16 v)         { reg.RESULTMAXCNT = v; } //15bits (max 32767)
   28bd4:	4b01      	ldr	r3, [pc, #4]	; (28bdc <Saadc::bufferSize(unsigned short)+0x8>)
   28bd6:	f8c3 0630 	str.w	r0, [r3, #1584]	; 0x630
   28bda:	4770      	bx	lr
   28bdc:	40007000 	.word	0x40007000

00028be0 <Saadc::bufferSet(unsigned long, unsigned short)>:
SA  bufferSize      ()              { return reg.RESULTMAXCNT; }
SA  bufferSet       (u32 v, u16 n)  { bufferAddr(v); bufferSize(n); }
   28be0:	b510      	push	{r4, lr}
   28be2:	460c      	mov	r4, r1
   28be4:	f7ff fff0 	bl	28bc8 <Saadc::bufferAddr(unsigned long)>
   28be8:	4620      	mov	r0, r4
   28bea:	f7ff fff3 	bl	28bd4 <Saadc::bufferSize(unsigned short)>
   28bee:	bd10      	pop	{r4, pc}

00028bf0 <SaadcChan::setConfig(short&)>:
    private:
//============

                    //setup our channel config and buffer in Saadc
                    //take exclusive use of Saadc
SA setConfig        (i16& v) {
   28bf0:	b538      	push	{r3, r4, r5, lr}
   28bf2:	4604      	mov	r4, r0
                        if( isBusy() ) return false;        //is in use
   28bf4:	f7ff fee0 	bl	289b8 <Saadc::isBusy()>
   28bf8:	b9b8      	cbnz	r0, 28c2a <SaadcChan::setConfig(short&)+0x3a>
                        if( pselP_ == NC and pselN_ == NC ) return false; //or we are not init
   28bfa:	4a0d      	ldr	r2, [pc, #52]	; (28c30 <SaadcChan::setConfig(short&)+0x40>)
   28bfc:	4b0d      	ldr	r3, [pc, #52]	; (28c34 <SaadcChan::setConfig(short&)+0x44>)
   28bfe:	7812      	ldrb	r2, [r2, #0]
   28c00:	781b      	ldrb	r3, [r3, #0]
   28c02:	ea52 0103 	orrs.w	r1, r2, r3
   28c06:	d00e      	beq.n	28c26 <SaadcChan::setConfig(short&)+0x36>
                        channelSetup( ch_, config_, pselP_, pselN_ );  //set config and inputs
   28c08:	4d0b      	ldr	r5, [pc, #44]	; (28c38 <SaadcChan::setConfig(short&)+0x48>)
   28c0a:	490c      	ldr	r1, [pc, #48]	; (28c3c <SaadcChan::setConfig(short&)+0x4c>)
   28c0c:	7828      	ldrb	r0, [r5, #0]
   28c0e:	6809      	ldr	r1, [r1, #0]
   28c10:	f7ff ff50 	bl	28ab4 <Saadc::channelSetup(Saadc::CH, unsigned long, Saadc::PSEL, Saadc::PSEL)>
                        bufferSet( (u32)&v, 1 );
   28c14:	4620      	mov	r0, r4
   28c16:	2101      	movs	r1, #1
   28c18:	f7ff ffe2 	bl	28be0 <Saadc::bufferSet(unsigned long, unsigned short)>
                        channelOnly( ch_ );                 //disable all other channels
   28c1c:	7828      	ldrb	r0, [r5, #0]
   28c1e:	f7ff ff7b 	bl	28b18 <Saadc::channelOnly(Saadc::CH)>
                        return true;
   28c22:	2001      	movs	r0, #1
                    }
   28c24:	bd38      	pop	{r3, r4, r5, pc}
                        if( isBusy() ) return false;        //is in use
   28c26:	4608      	mov	r0, r1
                    }
   28c28:	bd38      	pop	{r3, r4, r5, pc}
                        if( isBusy() ) return false;        //is in use
   28c2a:	2000      	movs	r0, #0
                    }
   28c2c:	bd38      	pop	{r3, r4, r5, pc}
   28c2e:	bf00      	nop
   28c30:	200022bd 	.word	0x200022bd
   28c34:	200022bc 	.word	0x200022bc
   28c38:	200022be 	.word	0x200022be
   28c3c:	200022b8 	.word	0x200022b8

00028c40 <SaadcChan::result1()>:
                    }

                    //get a single result (blocking) - 
                    //could be >1 sample if oversample is on
                    //TODO, should have timeout here  
SA  result1         () {
   28c40:	b508      	push	{r3, lr}
                        clearResult();
   28c42:	f7ff fee7 	bl	28a14 <Saadc::clearResult()>
   28c46:	e001      	b.n	28c4c <SaadcChan::result1()+0xc>
                        for( ; not isResult(); sample() );  
   28c48:	f7ff ff1e 	bl	28a88 <Saadc::sample()>
   28c4c:	f7ff ff06 	bl	28a5c <Saadc::isResult()>
   28c50:	2800      	cmp	r0, #0
   28c52:	d0f9      	beq.n	28c48 <SaadcChan::result1()+0x8>
                    }
   28c54:	bd08      	pop	{r3, pc}
   28c56:	bf00      	nop

00028c58 <SaadcChan::read(short&, Saadc::RES, Saadc::OVERSAMP)>:
//============
    public:
//============

                    //get with a specific resolution, and number of samples
SA  read            (i16& v, RES r, OVERSAMP s = OVEROFF) {
   28c58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   28c5a:	460e      	mov	r6, r1
   28c5c:	4615      	mov	r5, r2
                        if( not setConfig( v ) ) return false;
   28c5e:	f7ff ffc7 	bl	28bf0 <SaadcChan::setConfig(short&)>
   28c62:	4604      	mov	r4, r0
   28c64:	b1f0      	cbz	r0, 28ca4 <SaadcChan::read(short&, Saadc::RES, Saadc::OVERSAMP)+0x4c>
                        RES rr = resolution();          //save old
   28c66:	f7ff ff99 	bl	28b9c <Saadc::resolution()>
   28c6a:	4607      	mov	r7, r0
                        OVERSAMP ss = overSample();
   28c6c:	f7ff ffa4 	bl	28bb8 <Saadc::overSample()>
   28c70:	4603      	mov	r3, r0
                        resolution( r );                //set new
   28c72:	4630      	mov	r0, r6
                        OVERSAMP ss = overSample();
   28c74:	461e      	mov	r6, r3
                        resolution( r );                //set new
   28c76:	f7ff ff8b 	bl	28b90 <Saadc::resolution(Saadc::RES)>
                        overSample( s );
   28c7a:	4628      	mov	r0, r5
   28c7c:	f7ff ff96 	bl	28bac <Saadc::overSample(Saadc::OVERSAMP)>
                        start();                        //start will also enable
   28c80:	f7ff fef8 	bl	28a74 <Saadc::start()>
                        result1();
   28c84:	f7ff ffdc 	bl	28c40 <SaadcChan::result1()>
                        resolution( rr );               //restore old
   28c88:	4638      	mov	r0, r7
   28c8a:	f7ff ff81 	bl	28b90 <Saadc::resolution(Saadc::RES)>
                        overSample( ss );
   28c8e:	4630      	mov	r0, r6
   28c90:	f7ff ff8c 	bl	28bac <Saadc::overSample(Saadc::OVERSAMP)>
                        disable();
   28c94:	f7ff fe9e 	bl	289d4 <Saadc::disable()>
                        clearEvents();
   28c98:	f7ff fed4 	bl	28a44 <Saadc::clearEvents()>
                        channelRelease( ch_ );
   28c9c:	4b02      	ldr	r3, [pc, #8]	; (28ca8 <SaadcChan::read(short&, Saadc::RES, Saadc::OVERSAMP)+0x50>)
   28c9e:	7818      	ldrb	r0, [r3, #0]
   28ca0:	f7ff ff22 	bl	28ae8 <Saadc::channelRelease(Saadc::CH)>
                        return true;
                    }
   28ca4:	4620      	mov	r0, r4
   28ca6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   28ca8:	200022be 	.word	0x200022be

00028cac <Flash::init()>:
                        saveName_ = not sdFlashWrite32( (const u32*)fullnameRam_, fullnameSiz_/4 );
                    }

    public:
                    //stored flash name to ram, or use default if not set
SA  init            () {
   28cac:	b510      	push	{r4, lr}
                            if( fullnameFlash_[i] == 0 ) return true;
   28cae:	4b10      	ldr	r3, [pc, #64]	; (28cf0 <Flash::init()+0x44>)
   28cb0:	681c      	ldr	r4, [r3, #0]
   28cb2:	1e63      	subs	r3, r4, #1
   28cb4:	f104 001f 	add.w	r0, r4, #31
   28cb8:	e001      	b.n	28cbe <Flash::init()+0x12>
                        for( auto i = 0; i < fullnameSiz_; i++ ){
   28cba:	4283      	cmp	r3, r0
   28cbc:	d00d      	beq.n	28cda <Flash::init()+0x2e>
                            if( fullnameFlash_[i] == 0 ) return true;
   28cbe:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   28cc2:	2a00      	cmp	r2, #0
   28cc4:	d1f9      	bne.n	28cba <Flash::init()+0xe>
                        Debug( "Flash::init...\n" );  
                        if( fullnameValid() ){
                            //copy to ram (include 0 terminator)
                            memcpy( (void*)fullnameRam_, (void*)fullnameFlash_, strlen(fullnameFlash_)+1 );
   28cc6:	4620      	mov	r0, r4
   28cc8:	f000 ffd0 	bl	29c6c <strlen>
   28ccc:	4621      	mov	r1, r4
   28cce:	1c42      	adds	r2, r0, #1
                        } else {
                            memcpy( (void*)fullnameRam_, (void*)"NoName", strlen("NoName")+1 );
                        }
                        Debug( "    name: %s\n", fullnameRam_ );
                    }
   28cd0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
                            memcpy( (void*)fullnameRam_, (void*)fullnameFlash_, strlen(fullnameFlash_)+1 );
   28cd4:	4807      	ldr	r0, [pc, #28]	; (28cf4 <Flash::init()+0x48>)
   28cd6:	f000 bf7f 	b.w	29bd8 <memcpy>
                            memcpy( (void*)fullnameRam_, (void*)"NoName", strlen("NoName")+1 );
   28cda:	4807      	ldr	r0, [pc, #28]	; (28cf8 <Flash::init()+0x4c>)
   28cdc:	f000 ffc6 	bl	29c6c <strlen>
                    }
   28ce0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
                            memcpy( (void*)fullnameRam_, (void*)"NoName", strlen("NoName")+1 );
   28ce4:	1c42      	adds	r2, r0, #1
   28ce6:	4904      	ldr	r1, [pc, #16]	; (28cf8 <Flash::init()+0x4c>)
   28ce8:	4802      	ldr	r0, [pc, #8]	; (28cf4 <Flash::init()+0x48>)
   28cea:	f000 bf75 	b.w	29bd8 <memcpy>
   28cee:	bf00      	nop
   28cf0:	20002034 	.word	0x20002034
   28cf4:	20002294 	.word	0x20002294
   28cf8:	0002bcf4 	.word	0x0002bcf4

00028cfc <Flags01::make(unsigned char*, unsigned char)>:
                        buf[0] = 2;
   28cfc:	2202      	movs	r2, #2
                        buf[1] = 1;
   28cfe:	2301      	movs	r3, #1
                        buf[2] = flags;
   28d00:	7081      	strb	r1, [r0, #2]
                        buf[0] = 2;
   28d02:	7002      	strb	r2, [r0, #0]
                        buf[1] = 1;
   28d04:	7043      	strb	r3, [r0, #1]
                    }
   28d06:	2003      	movs	r0, #3
   28d08:	4770      	bx	lr
   28d0a:	bf00      	nop

00028d0c <CompleteName09::make(unsigned char*, char const*, unsigned char)>:
SA  make            (u8* buf, const char* str, u8 maxlen) {
   28d0c:	b570      	push	{r4, r5, r6, lr}
   28d0e:	b082      	sub	sp, #8
   28d10:	4605      	mov	r5, r0
                        u8 slen = strlen( str );
   28d12:	4608      	mov	r0, r1
SA  make            (u8* buf, const char* str, u8 maxlen) {
   28d14:	4616      	mov	r6, r2
                        u8 slen = strlen( str );
   28d16:	9101      	str	r1, [sp, #4]
   28d18:	f000 ffa8 	bl	29c6c <strlen>
   28d1c:	b2c4      	uxtb	r4, r0
                        if( slen > maxlen ) slen = maxlen;
   28d1e:	42b4      	cmp	r4, r6
   28d20:	bf28      	it	cs
   28d22:	4634      	movcs	r4, r6
                        buf[0] = slen + 1;
   28d24:	1c62      	adds	r2, r4, #1
                        buf[1] = 9;
   28d26:	2309      	movs	r3, #9
                        buf[0] = slen + 1;
   28d28:	702a      	strb	r2, [r5, #0]
                        memcpy( &buf[2], str, slen );
   28d2a:	9901      	ldr	r1, [sp, #4]
                        buf[1] = 9;
   28d2c:	706b      	strb	r3, [r5, #1]
                        memcpy( &buf[2], str, slen );
   28d2e:	1ca8      	adds	r0, r5, #2
   28d30:	4622      	mov	r2, r4
   28d32:	f000 ff51 	bl	29bd8 <memcpy>
                    }
   28d36:	1ca0      	adds	r0, r4, #2
   28d38:	b002      	add	sp, #8
   28d3a:	bd70      	pop	{r4, r5, r6, pc}

00028d3c <BatteryService180F::make(unsigned char*)>:
        uses ServiceData16
    size [4]
------------------------------------------------------------------------------*/
struct BatteryService180F {

SA  make            (u8* buf) {
   28d3c:	b5f0      	push	{r4, r5, r6, r7, lr}
    // adc*3600/1024
    SI i16 voltage_{ 0 }; 

SA  update          () {
                        static u8 count;
                        if( count == 0 ) {
   28d3e:	4e2c      	ldr	r6, [pc, #176]	; (28df0 <BatteryService180F::make(unsigned char*)+0xb4>)
   28d40:	7837      	ldrb	r7, [r6, #0]
   28d42:	b083      	sub	sp, #12
   28d44:	4604      	mov	r4, r0
   28d46:	b32f      	cbz	r7, 28d94 <BatteryService180F::make(unsigned char*)+0x58>
   28d48:	4b2a      	ldr	r3, [pc, #168]	; (28df4 <BatteryService180F::make(unsigned char*)+0xb8>)
   28d4a:	881b      	ldrh	r3, [r3, #0]
   28d4c:	f10d 0506 	add.w	r5, sp, #6
                            //make sure we are in some sane range
                            if( voltage_ < 500 ) voltage_ = 0; // <500mv, show 0000
                            if( voltage_ > 3600 ) voltage_ = 9999; //>3600, show 9999
                            Debug( "Battery::update  %u.%03uV\n", voltage_/1000, voltage_%1000 );
                        }
                        if( ++count >= updateInterval_ ) count = 0;  
   28d50:	3701      	adds	r7, #1
   28d52:	b2ff      	uxtb	r7, r7
   28d54:	2f3b      	cmp	r7, #59	; 0x3b
   28d56:	bf84      	itt	hi
   28d58:	2200      	movhi	r2, #0
   28d5a:	7032      	strbhi	r2, [r6, #0]
                        //2.00v = 0%, 3.00v = 100%
                        //percentage will be mV/10 from 2-3v (77% = 2.77v)
                        u16 bv = battery.read();
                        DebugFuncHeader();
                        Debug( "  battery: %dmV\n", bv );
                        u8 dat = bv > 3000 ? 100 :
   28d5c:	f640 32b8 	movw	r2, #3000	; 0xbb8
   28d60:	bf98      	it	ls
   28d62:	7037      	strbls	r7, [r6, #0]
   28d64:	4293      	cmp	r3, r2
   28d66:	d80a      	bhi.n	28d7e <BatteryService180F::make(unsigned char*)+0x42>
   28d68:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
   28d6c:	d310      	bcc.n	28d90 <BatteryService180F::make(unsigned char*)+0x54>
                                 bv < 2000 ? 0 :
                                 (bv - 2000)/10;
   28d6e:	4a22      	ldr	r2, [pc, #136]	; (28df8 <BatteryService180F::make(unsigned char*)+0xbc>)
   28d70:	f5a3 63fa 	sub.w	r3, r3, #2000	; 0x7d0
   28d74:	fba2 2303 	umull	r2, r3, r2, r3
                        u8 dat = bv > 3000 ? 100 :
   28d78:	f3c3 03c7 	ubfx	r3, r3, #3, #8
   28d7c:	e000      	b.n	28d80 <BatteryService180F::make(unsigned char*)+0x44>
   28d7e:	2364      	movs	r3, #100	; 0x64
                        return ServiceData16::make( buf, 0x180F, &dat, 1 );
   28d80:	4629      	mov	r1, r5
   28d82:	4620      	mov	r0, r4
                        u8 dat = bv > 3000 ? 100 :
   28d84:	f88d 3006 	strb.w	r3, [sp, #6]
                        return ServiceData16::make( buf, 0x180F, &dat, 1 );
   28d88:	f7ff fc7e 	bl	28688 <ServiceData16::make(unsigned char*, unsigned short, unsigned char*, unsigned char) [clone .constprop.0]>
                    }
   28d8c:	b003      	add	sp, #12
   28d8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        u8 dat = bv > 3000 ? 100 :
   28d90:	2300      	movs	r3, #0
   28d92:	e7f5      	b.n	28d80 <BatteryService180F::make(unsigned char*)+0x44>
                            vdd_.read(v, vdd_.RES10, vdd_.OVER8X);
   28d94:	f10d 0506 	add.w	r5, sp, #6
                            vdd_.calibrate();
   28d98:	f7ff fe7c 	bl	28a94 <Saadc::calibrate()>
                            vdd_.read(v, vdd_.RES10, vdd_.OVER8X);
   28d9c:	2203      	movs	r2, #3
   28d9e:	4628      	mov	r0, r5
   28da0:	2101      	movs	r1, #1
                            i16 v = 0;
   28da2:	f8ad 7006 	strh.w	r7, [sp, #6]
                            vdd_.read(v, vdd_.RES10, vdd_.OVER8X);
   28da6:	f7ff ff57 	bl	28c58 <SaadcChan::read(short&, Saadc::RES, Saadc::OVERSAMP)>
                            voltage_ = (i32)v * 3600 / 1024;
   28daa:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
   28dae:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
   28db2:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
   28db6:	011b      	lsls	r3, r3, #4
   28db8:	bf48      	it	mi
   28dba:	f203 33ff 	addwmi	r3, r3, #1023	; 0x3ff
   28dbe:	f343 228f 	sbfx	r2, r3, #10, #16
                            if( voltage_ < 500 ) voltage_ = 0; // <500mv, show 0000
   28dc2:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
                            voltage_ = (i32)v * 3600 / 1024;
   28dc6:	ea4f 23a3 	mov.w	r3, r3, asr #10
                            if( voltage_ < 500 ) voltage_ = 0; // <500mv, show 0000
   28dca:	db08      	blt.n	28dde <BatteryService180F::make(unsigned char*)+0xa2>
                            if( voltage_ > 3600 ) voltage_ = 9999; //>3600, show 9999
   28dcc:	f5b2 6f61 	cmp.w	r2, #3600	; 0xe10
   28dd0:	dd09      	ble.n	28de6 <BatteryService180F::make(unsigned char*)+0xaa>
   28dd2:	4a08      	ldr	r2, [pc, #32]	; (28df4 <BatteryService180F::make(unsigned char*)+0xb8>)
   28dd4:	f242 730f 	movw	r3, #9999	; 0x270f
   28dd8:	8013      	strh	r3, [r2, #0]
                            Debug( "Battery::update  %u.%03uV\n", voltage_/1000, voltage_%1000 );
   28dda:	7837      	ldrb	r7, [r6, #0]
   28ddc:	e7b8      	b.n	28d50 <BatteryService180F::make(unsigned char*)+0x14>
                            if( voltage_ < 500 ) voltage_ = 0; // <500mv, show 0000
   28dde:	4a05      	ldr	r2, [pc, #20]	; (28df4 <BatteryService180F::make(unsigned char*)+0xb8>)
   28de0:	2300      	movs	r3, #0
   28de2:	8013      	strh	r3, [r2, #0]
                            if( voltage_ > 3600 ) voltage_ = 9999; //>3600, show 9999
   28de4:	e7f9      	b.n	28dda <BatteryService180F::make(unsigned char*)+0x9e>
                            voltage_ = (i32)v * 3600 / 1024;
   28de6:	4903      	ldr	r1, [pc, #12]	; (28df4 <BatteryService180F::make(unsigned char*)+0xb8>)
   28de8:	b29b      	uxth	r3, r3
   28dea:	800a      	strh	r2, [r1, #0]
   28dec:	e7f5      	b.n	28dda <BatteryService180F::make(unsigned char*)+0x9e>
   28dee:	bf00      	nop
   28df0:	200022b4 	.word	0x200022b4
   28df4:	200022b6 	.word	0x200022b6
   28df8:	cccccccd 	.word	0xcccccccd

00028dfc <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::timerOff()>:

SA  timerOn         () {
                        timerAdvUpdate_.init( timerInterval_, update, timerAdvUpdate_.REPEATED );
                    }

SA  timerOff        () {
   28dfc:	b508      	push	{r3, lr}
                                APP_TIMER_MODE_REPEATED, cb) 
                        );
                        error.check( app_timer_start(ptimerId_, appTimerTicks(ms), NULL) );
                    }

auto stop           (){ error.check( app_timer_stop(ptimerId_) ); }
   28dfe:	4b04      	ldr	r3, [pc, #16]	; (28e10 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::timerOff()+0x14>)
   28e00:	6a18      	ldr	r0, [r3, #32]
   28e02:	f7fe fcc5 	bl	27790 <app_timer_stop>
                        timerAdvUpdate_.stop();
                    }
   28e06:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   28e0a:	b200      	sxth	r0, r0
   28e0c:	f7ff bc44 	b.w	28698 <Errors::check(short, bool) [clone .constprop.0]>
   28e10:	20002220 	.word	0x20002220

00028e14 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::isStopped()>:
                        isActive_ = false; 
   28e14:	4b01      	ldr	r3, [pc, #4]	; (28e1c <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::isStopped()+0x8>)
   28e16:	2200      	movs	r2, #0
   28e18:	701a      	strb	r2, [r3, #0]
                    }
   28e1a:	4770      	bx	lr
   28e1c:	20002248 	.word	0x20002248

00028e20 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::connectable(bool)>:
                        isConnectable_ = tf; 
   28e20:	4b01      	ldr	r3, [pc, #4]	; (28e28 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::connectable(bool)+0x8>)
   28e22:	7018      	strb	r0, [r3, #0]
                    }
   28e24:	4770      	bx	lr
   28e26:	bf00      	nop
   28e28:	20002011 	.word	0x20002011
   28e2c:	00000000 	.word	0x00000000

00028e30 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::timerOn()>:
SA  timerOn         () {
   28e30:	b538      	push	{r3, r4, r5, lr}
                        if( isTimerModuleInit_ ) return;
   28e32:	4c19      	ldr	r4, [pc, #100]	; (28e98 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::timerOn()+0x68>)
                        timerAdvUpdate_.init( timerInterval_, update, timerAdvUpdate_.REPEATED );
   28e34:	4a19      	ldr	r2, [pc, #100]	; (28e9c <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::timerOn()+0x6c>)
   28e36:	7823      	ldrb	r3, [r4, #0]
   28e38:	6815      	ldr	r5, [r2, #0]
   28e3a:	b91b      	cbnz	r3, 28e44 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::timerOn()+0x14>
                        app_timer_init(); //always success
   28e3c:	f7fe fc1e 	bl	2767c <app_timer_init>
                        isTimerModuleInit_ = true;
   28e40:	2301      	movs	r3, #1
   28e42:	7023      	strb	r3, [r4, #0]
                        error.check( app_timer_create(&ptimerId_, 
   28e44:	4a16      	ldr	r2, [pc, #88]	; (28ea0 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::timerOn()+0x70>)
   28e46:	4817      	ldr	r0, [pc, #92]	; (28ea4 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::timerOn()+0x74>)
   28e48:	2101      	movs	r1, #1
   28e4a:	f7fe fc4d 	bl	276e8 <app_timer_create>
   28e4e:	b200      	sxth	r0, r0
   28e50:	f7ff fc22 	bl	28698 <Errors::check(short, bool) [clone .constprop.0]>
                        return __builtin_ceil( ms*(RTC_HZ/1000.0) );
   28e54:	4814      	ldr	r0, [pc, #80]	; (28ea8 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::timerOn()+0x78>)
   28e56:	42a8      	cmp	r0, r5
   28e58:	bf28      	it	cs
   28e5a:	4628      	movcs	r0, r5
   28e5c:	f001 fe5c 	bl	2ab18 <__aeabi_ui2d>
   28e60:	a30b      	add	r3, pc, #44	; (adr r3, 28e90 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::timerOn()+0x60>)
   28e62:	e9d3 2300 	ldrd	r2, r3, [r3]
   28e66:	f001 fbeb 	bl	2a640 <__aeabi_dmul>
   28e6a:	ec41 0b10 	vmov	d0, r0, r1
   28e6e:	f001 fb67 	bl	2a540 <ceil>
   28e72:	ec51 0b10 	vmov	r0, r1, d0
                        error.check( app_timer_start(ptimerId_, appTimerTicks(ms), NULL) );
   28e76:	f001 ff51 	bl	2ad1c <__aeabi_d2uiz>
   28e7a:	4b0c      	ldr	r3, [pc, #48]	; (28eac <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::timerOn()+0x7c>)
   28e7c:	4601      	mov	r1, r0
   28e7e:	2200      	movs	r2, #0
   28e80:	6a18      	ldr	r0, [r3, #32]
   28e82:	f7fe fc3f 	bl	27704 <app_timer_start>
                    }
   28e86:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   28e8a:	b200      	sxth	r0, r0
   28e8c:	f7ff bc04 	b.w	28698 <Errors::check(short, bool) [clone .constprop.0]>
   28e90:	d2f1a9fc 	.word	0xd2f1a9fc
   28e94:	4030624d 	.word	0x4030624d
   28e98:	200022c0 	.word	0x200022c0
   28e9c:	2000200c 	.word	0x2000200c
   28ea0:	000292f1 	.word	0x000292f1
   28ea4:	20002240 	.word	0x20002240
   28ea8:	05265c00 	.word	0x05265c00
   28eac:	20002220 	.word	0x20002220

00028eb0 <Gap::init()>:
/*------------------------------------------------------------------------------
    Gap
------------------------------------------------------------------------------*/
struct Gap {

SA  init        () {
   28eb0:	b570      	push	{r4, r5, r6, lr}
                        saveName_ = true;
                    }

SA  readName        () {
                        //was updated?, need to save in flash
                        if( saveName_ ) saveName();                        
   28eb2:	4c40      	ldr	r4, [pc, #256]	; (28fb4 <Gap::init()+0x104>)
   28eb4:	b084      	sub	sp, #16
   28eb6:	7823      	ldrb	r3, [r4, #0]
                    Debug( "Gap::init...\n" );                    

                    ble_gap_conn_params_t   gap_conn_params;
                    ble_gap_conn_sec_mode_t sec_mode;

                    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&sec_mode);
   28eb8:	2211      	movs	r2, #17
   28eba:	f88d 2004 	strb.w	r2, [sp, #4]
   28ebe:	b9eb      	cbnz	r3, 28efc <Gap::init()+0x4c>

                    error.check( 
                        sd_ble_gap_device_name_set( &sec_mode, (const uint8_t*)flash.readName(), strlen( flash.readName() ) )
   28ec0:	483d      	ldr	r0, [pc, #244]	; (28fb8 <Gap::init()+0x108>)
   28ec2:	f000 fed3 	bl	29c6c <strlen>
   28ec6:	493c      	ldr	r1, [pc, #240]	; (28fb8 <Gap::init()+0x108>)
   28ec8:	b282      	uxth	r2, r0
   28eca:	a801      	add	r0, sp, #4
   28ecc:	f7ff fbcc 	bl	28668 <sd_ble_gap_device_name_set>
                    error.check( 
   28ed0:	b200      	sxth	r0, r0
   28ed2:	f7ff fbe1 	bl	28698 <Errors::check(short, bool) [clone .constprop.0]>
                     );

                    memset(&gap_conn_params, 0, sizeof(gap_conn_params));
   28ed6:	2208      	movs	r2, #8
   28ed8:	2100      	movs	r1, #0
   28eda:	a802      	add	r0, sp, #8
   28edc:	f000 fe8a 	bl	29bf4 <memset>

                    gap_conn_params.min_conn_interval = MSEC_TO_UNITS(100, UNIT_1_25_MS);
   28ee0:	4b36      	ldr	r3, [pc, #216]	; (28fbc <Gap::init()+0x10c>)
   28ee2:	9302      	str	r3, [sp, #8]
                    gap_conn_params.max_conn_interval = MSEC_TO_UNITS(200, UNIT_1_25_MS);
                    gap_conn_params.conn_sup_timeout  = MSEC_TO_UNITS(4000, UNIT_10_MS);

                    error.check( sd_ble_gap_ppcp_set(&gap_conn_params) );
   28ee4:	a802      	add	r0, sp, #8
                    gap_conn_params.conn_sup_timeout  = MSEC_TO_UNITS(4000, UNIT_10_MS);
   28ee6:	f44f 73c8 	mov.w	r3, #400	; 0x190
   28eea:	f8ad 300e 	strh.w	r3, [sp, #14]
                    error.check( sd_ble_gap_ppcp_set(&gap_conn_params) );
   28eee:	f7ff fbb9 	bl	28664 <sd_ble_gap_ppcp_set>
   28ef2:	b200      	sxth	r0, r0
   28ef4:	f7ff fbd0 	bl	28698 <Errors::check(short, bool) [clone .constprop.0]>
                }
   28ef8:	b004      	add	sp, #16
   28efa:	bd70      	pop	{r4, r5, r6, pc}
                        if( not nrf_sdh_is_enabled() ) return; //these functions use sd
   28efc:	f000 fbe0 	bl	296c0 <nrf_sdh_is_enabled>
   28f00:	bb00      	cbnz	r0, 28f44 <Gap::init()+0x94>
                        if( saveName_ ) saveName();                        
   28f02:	7823      	ldrb	r3, [r4, #0]
   28f04:	2b00      	cmp	r3, #0
   28f06:	d0db      	beq.n	28ec0 <Gap::init()+0x10>
                        if( not nrf_sdh_is_enabled() ) return; //these functions use sd
   28f08:	f000 fbda 	bl	296c0 <nrf_sdh_is_enabled>
   28f0c:	4605      	mov	r5, r0
   28f0e:	2800      	cmp	r0, #0
   28f10:	d0d6      	beq.n	28ec0 <Gap::init()+0x10>
                            if( fullnameFlash_[i] != 0xFF ) return false;
   28f12:	4b2b      	ldr	r3, [pc, #172]	; (28fc0 <Gap::init()+0x110>)
   28f14:	6818      	ldr	r0, [r3, #0]
   28f16:	1e43      	subs	r3, r0, #1
   28f18:	f100 011f 	add.w	r1, r0, #31
   28f1c:	e001      	b.n	28f22 <Gap::init()+0x72>
                        for( auto i = 0; i < fullnameSiz_; i++ ){
   28f1e:	428b      	cmp	r3, r1
   28f20:	d035      	beq.n	28f8e <Gap::init()+0xde>
                            if( fullnameFlash_[i] != 0xFF ) return false;
   28f22:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   28f26:	2aff      	cmp	r2, #255	; 0xff
   28f28:	d0f9      	beq.n	28f1e <Gap::init()+0x6e>
                        if( busy_ ){
   28f2a:	4e26      	ldr	r6, [pc, #152]	; (28fc4 <Gap::init()+0x114>)
   28f2c:	7833      	ldrb	r3, [r6, #0]
   28f2e:	2b00      	cmp	r3, #0
   28f30:	d1c6      	bne.n	28ec0 <Gap::init()+0x10>
                        u32 err = sd_flash_page_erase(lastPageFlash_);
   28f32:	20df      	movs	r0, #223	; 0xdf
   28f34:	f7ff fb8c 	bl	28650 <sd_flash_page_erase>
                        if( err != NRF_SUCCESS ) return false;
   28f38:	2800      	cmp	r0, #0
   28f3a:	d1c1      	bne.n	28ec0 <Gap::init()+0x10>
                        busy_ = true;
   28f3c:	2301      	movs	r3, #1
   28f3e:	7033      	strb	r3, [r6, #0]
                        saveName_ = not sdFlashWrite32( (const u32*)fullnameRam_, fullnameSiz_/4 );
   28f40:	7025      	strb	r5, [r4, #0]
   28f42:	e7bd      	b.n	28ec0 <Gap::init()+0x10>
                            if( fullnameFlash_[i] != 0xFF ) return false;
   28f44:	4b1e      	ldr	r3, [pc, #120]	; (28fc0 <Gap::init()+0x110>)
   28f46:	6818      	ldr	r0, [r3, #0]
   28f48:	1e43      	subs	r3, r0, #1
   28f4a:	f100 011f 	add.w	r1, r0, #31
   28f4e:	e001      	b.n	28f54 <Gap::init()+0xa4>
                        for( auto i = 0; i < fullnameSiz_; i++ ){
   28f50:	428b      	cmp	r3, r1
   28f52:	d010      	beq.n	28f76 <Gap::init()+0xc6>
                            if( fullnameFlash_[i] != 0xFF ) return false;
   28f54:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   28f58:	2aff      	cmp	r2, #255	; 0xff
   28f5a:	d0f9      	beq.n	28f50 <Gap::init()+0xa0>
                        if( busy_ ){
   28f5c:	4d19      	ldr	r5, [pc, #100]	; (28fc4 <Gap::init()+0x114>)
   28f5e:	782b      	ldrb	r3, [r5, #0]
   28f60:	2b00      	cmp	r3, #0
   28f62:	d1ce      	bne.n	28f02 <Gap::init()+0x52>
                        u32 err = sd_flash_page_erase(lastPageFlash_);
   28f64:	20df      	movs	r0, #223	; 0xdf
   28f66:	f7ff fb73 	bl	28650 <sd_flash_page_erase>
                        if( err != NRF_SUCCESS ) return false;
   28f6a:	2800      	cmp	r0, #0
   28f6c:	d1c9      	bne.n	28f02 <Gap::init()+0x52>
                        busy_ = true;
   28f6e:	2301      	movs	r3, #1
   28f70:	702b      	strb	r3, [r5, #0]
                        saveName_ = not sdFlashWrite32( (const u32*)fullnameRam_, fullnameSiz_/4 );
   28f72:	7023      	strb	r3, [r4, #0]
                        if( saveName_ ) saveName();                        
   28f74:	e7c8      	b.n	28f08 <Gap::init()+0x58>
                        if( busy_ ){
   28f76:	4d13      	ldr	r5, [pc, #76]	; (28fc4 <Gap::init()+0x114>)
   28f78:	782b      	ldrb	r3, [r5, #0]
   28f7a:	b9bb      	cbnz	r3, 28fac <Gap::init()+0xfc>
                        u32 err = sd_flash_write((u32*)fullnameFlash_, vals, valsN );
   28f7c:	490e      	ldr	r1, [pc, #56]	; (28fb8 <Gap::init()+0x108>)
   28f7e:	2208      	movs	r2, #8
   28f80:	f7ff fb64 	bl	2864c <sd_flash_write>
                        if( err != NRF_SUCCESS ) return false;
   28f84:	b990      	cbnz	r0, 28fac <Gap::init()+0xfc>
                        busy_ = true;
   28f86:	2301      	movs	r3, #1
                        saveName_ = not sdFlashWrite32( (const u32*)fullnameRam_, fullnameSiz_/4 );
   28f88:	7020      	strb	r0, [r4, #0]
                        busy_ = true;
   28f8a:	702b      	strb	r3, [r5, #0]
                        if( saveName_ ) saveName();                        
   28f8c:	e798      	b.n	28ec0 <Gap::init()+0x10>
                        if( busy_ ){
   28f8e:	4e0d      	ldr	r6, [pc, #52]	; (28fc4 <Gap::init()+0x114>)
   28f90:	7833      	ldrb	r3, [r6, #0]
   28f92:	2b00      	cmp	r3, #0
   28f94:	d1d4      	bne.n	28f40 <Gap::init()+0x90>
                        u32 err = sd_flash_write((u32*)fullnameFlash_, vals, valsN );
   28f96:	4908      	ldr	r1, [pc, #32]	; (28fb8 <Gap::init()+0x108>)
   28f98:	2208      	movs	r2, #8
   28f9a:	f7ff fb57 	bl	2864c <sd_flash_write>
                        if( err != NRF_SUCCESS ) return false;
   28f9e:	2800      	cmp	r0, #0
   28fa0:	d1ce      	bne.n	28f40 <Gap::init()+0x90>
                        busy_ = true;
   28fa2:	2301      	movs	r3, #1
                        return true;                       
   28fa4:	4605      	mov	r5, r0
                        busy_ = true;
   28fa6:	7033      	strb	r3, [r6, #0]
                        saveName_ = not sdFlashWrite32( (const u32*)fullnameRam_, fullnameSiz_/4 );
   28fa8:	7025      	strb	r5, [r4, #0]
   28faa:	e789      	b.n	28ec0 <Gap::init()+0x10>
   28fac:	2301      	movs	r3, #1
   28fae:	7023      	strb	r3, [r4, #0]
                        if( saveName_ ) saveName();                        
   28fb0:	e7aa      	b.n	28f08 <Gap::init()+0x58>
   28fb2:	bf00      	nop
   28fb4:	20002293 	.word	0x20002293
   28fb8:	20002294 	.word	0x20002294
   28fbc:	00a00050 	.word	0x00a00050
   28fc0:	20002034 	.word	0x20002034
   28fc4:	20002292 	.word	0x20002292

00028fc8 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::stop()>:
                        power( txPower_ );
                        if( battery.isOk() ) board.ok(); else board.caution();

                    }

SA  stop            () -> void {
   28fc8:	b510      	push	{r4, lr}
                        if( not isActive_ ) return;
   28fca:	4c07      	ldr	r4, [pc, #28]	; (28fe8 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::stop()+0x20>)
   28fcc:	7823      	ldrb	r3, [r4, #0]
   28fce:	b903      	cbnz	r3, 28fd2 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::stop()+0xa>
                        error.check( sd_ble_gap_adv_stop(handle_) );
                        isActive_ = false;
                    }
   28fd0:	bd10      	pop	{r4, pc}
                        error.check( sd_ble_gap_adv_stop(handle_) );
   28fd2:	4b06      	ldr	r3, [pc, #24]	; (28fec <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::stop()+0x24>)
   28fd4:	7818      	ldrb	r0, [r3, #0]
   28fd6:	f7ff fb41 	bl	2865c <sd_ble_gap_adv_stop>
   28fda:	b200      	sxth	r0, r0
   28fdc:	f7ff fb5c 	bl	28698 <Errors::check(short, bool) [clone .constprop.0]>
                        isActive_ = false;
   28fe0:	2300      	movs	r3, #0
   28fe2:	7023      	strb	r3, [r4, #0]
                    }
   28fe4:	bd10      	pop	{r4, pc}
   28fe6:	bf00      	nop
   28fe8:	20002248 	.word	0x20002248
   28fec:	20002030 	.word	0x20002030

00028ff0 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])>:
SA  update          ( u8 (&buf)[31] ) -> void {
   28ff0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   28ff4:	b08a      	sub	sp, #40	; 0x28
   28ff6:	4606      	mov	r6, r0
SA  histSize        () { return HistSiz_; }

SA  read            () {
                        i16 f = -999; //-99.9 = failed to get
                        int32_t t;
                        if( sd_temp_get(&t) ) return f;
   28ff8:	a804      	add	r0, sp, #16
   28ffa:	f7ff fb25 	bl	28648 <sd_temp_get>
   28ffe:	2800      	cmp	r0, #0
   29000:	f040 80b1 	bne.w	29166 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x176>
                        f = (t*10*9/5+320*4)/4; // Fx10
   29004:	9b04      	ldr	r3, [sp, #16]
                        if( not isInit ){ //first time, populate all with same value
   29006:	4a5a      	ldr	r2, [pc, #360]	; (29170 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x180>)
                        f = (t*10*9/5+320*4)/4; // Fx10
   29008:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
   2900c:	005b      	lsls	r3, r3, #1
   2900e:	f513 60a0 	adds.w	r0, r3, #1280	; 0x500
   29012:	bf48      	it	mi
   29014:	f203 5003 	addwmi	r0, r3, #1283	; 0x503
                        if( not isInit ){ //first time, populate all with same value
   29018:	7813      	ldrb	r3, [r2, #0]
                        f = (t*10*9/5+320*4)/4; // Fx10
   2901a:	f340 008f 	sbfx	r0, r0, #2, #16
                        if( not isInit ){ //first time, populate all with same value
   2901e:	2b00      	cmp	r3, #0
   29020:	d151      	bne.n	290c6 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0xd6>
                            for( auto& i : tempHistory_ ) i = v;
   29022:	4954      	ldr	r1, [pc, #336]	; (29174 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x184>)
   29024:	f360 030f 	bfi	r3, r0, #0, #16
   29028:	f360 431f 	bfi	r3, r0, #16, #16
                            isInit = true;
   2902c:	2401      	movs	r4, #1
                            for( auto& i : tempHistory_ ) i = v;
   2902e:	600b      	str	r3, [r1, #0]
   29030:	604b      	str	r3, [r1, #4]
   29032:	8108      	strh	r0, [r1, #8]
                            isInit = true;
   29034:	7014      	strb	r4, [r2, #0]
                        tempHistory_[idx++] = v;
   29036:	4c50      	ldr	r4, [pc, #320]	; (29178 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x188>)
   29038:	4f50      	ldr	r7, [pc, #320]	; (2917c <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x18c>)
   2903a:	7825      	ldrb	r5, [r4, #0]
   2903c:	f5b0 6fe1 	cmp.w	r0, #1800	; 0x708
   29040:	4602      	mov	r2, r0
   29042:	bfa8      	it	ge
   29044:	f44f 62e1 	movge.w	r2, #1800	; 0x708
   29048:	b212      	sxth	r2, r2
   2904a:	1c6b      	adds	r3, r5, #1
   2904c:	b2db      	uxtb	r3, r3
   2904e:	42ba      	cmp	r2, r7
   29050:	bfb8      	it	lt
   29052:	463a      	movlt	r2, r7
                        if( idx >= HistSiz_ ) idx = 0;
   29054:	2b04      	cmp	r3, #4
                        tempHistory_[idx++] = v;
   29056:	7023      	strb	r3, [r4, #0]
                        if( idx >= HistSiz_ ) idx = 0;
   29058:	bf84      	itt	hi
   2905a:	2300      	movhi	r3, #0
   2905c:	7023      	strbhi	r3, [r4, #0]
                        u8 f10 = (f < 0) ? -f%10 : f%10;
   2905e:	2800      	cmp	r0, #0
                        tempHistory_[idx++] = v;
   29060:	f821 2015 	strh.w	r2, [r1, r5, lsl #1]
   29064:	db31      	blt.n	290ca <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0xda>
   29066:	4946      	ldr	r1, [pc, #280]	; (29180 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x190>)
   29068:	17d3      	asrs	r3, r2, #31
   2906a:	fb81 0102 	smull	r0, r1, r1, r2
   2906e:	ebc3 03a1 	rsb	r3, r3, r1, asr #2
   29072:	eb03 0483 	add.w	r4, r3, r3, lsl #2
   29076:	eba2 0244 	sub.w	r2, r2, r4, lsl #1
   2907a:	b214      	sxth	r4, r2
   2907c:	b21b      	sxth	r3, r3
   2907e:	4d41      	ldr	r5, [pc, #260]	; (29184 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x194>)
   29080:	782a      	ldrb	r2, [r5, #0]
   29082:	2a00      	cmp	r2, #0
   29084:	d136      	bne.n	290f4 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x104>
                        snprintf( nambuf, 23, "%d.%uF %s", f, f10, flash.readName() );
   29086:	4a40      	ldr	r2, [pc, #256]	; (29188 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x198>)
   29088:	2117      	movs	r1, #23
   2908a:	e9cd 4200 	strd	r4, r2, [sp]
   2908e:	a804      	add	r0, sp, #16
   29090:	4a3e      	ldr	r2, [pc, #248]	; (2918c <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x19c>)
   29092:	f000 fdb7 	bl	29c04 <sniprintf>
                        u8 idx = Flags01::make( buf, BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED ); //3
   29096:	2104      	movs	r1, #4
   29098:	4630      	mov	r0, r6
   2909a:	f7ff fe2f 	bl	28cfc <Flags01::make(unsigned char*, unsigned char)>
   2909e:	b2c4      	uxtb	r4, r0
                        idx += BatteryService180F::make( &buf[idx] ); //4
   290a0:	1930      	adds	r0, r6, r4
   290a2:	f7ff fe4b 	bl	28d3c <BatteryService180F::make(unsigned char*)>
   290a6:	4404      	add	r4, r0
   290a8:	b2e4      	uxtb	r4, r4
                        idx += CompleteName09::make( &buf[idx], nambuf, 31-7-2 ); // up to 22 chars
   290aa:	1930      	adds	r0, r6, r4
   290ac:	a904      	add	r1, sp, #16
   290ae:	2216      	movs	r2, #22
   290b0:	f7ff fe2c 	bl	28d0c <CompleteName09::make(unsigned char*, char const*, unsigned char)>
   290b4:	4404      	add	r4, r0
   290b6:	b2e4      	uxtb	r4, r4
                        if( idx < 31 ) buf[idx] = 0;
   290b8:	2c1e      	cmp	r4, #30
   290ba:	d801      	bhi.n	290c0 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0xd0>
   290bc:	2300      	movs	r3, #0
   290be:	5533      	strb	r3, [r6, r4]
                    }
   290c0:	b00a      	add	sp, #40	; 0x28
   290c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   290c6:	492b      	ldr	r1, [pc, #172]	; (29174 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x184>)
   290c8:	e7b5      	b.n	29036 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x46>
   290ca:	4b2d      	ldr	r3, [pc, #180]	; (29180 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x190>)
   290cc:	4251      	negs	r1, r2
   290ce:	fb83 4001 	smull	r4, r0, r3, r1
   290d2:	fb83 5302 	smull	r5, r3, r3, r2
   290d6:	4d2b      	ldr	r5, [pc, #172]	; (29184 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x194>)
   290d8:	17d2      	asrs	r2, r2, #31
   290da:	17cc      	asrs	r4, r1, #31
   290dc:	ebc2 03a3 	rsb	r3, r2, r3, asr #2
   290e0:	ebc4 04a0 	rsb	r4, r4, r0, asr #2
   290e4:	782a      	ldrb	r2, [r5, #0]
   290e6:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   290ea:	b21b      	sxth	r3, r3
   290ec:	eba1 0444 	sub.w	r4, r1, r4, lsl #1
   290f0:	2a00      	cmp	r2, #0
   290f2:	d0c8      	beq.n	29086 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x96>
                        if( not nrf_sdh_is_enabled() ) return; //these functions use sd
   290f4:	9303      	str	r3, [sp, #12]
   290f6:	f000 fae3 	bl	296c0 <nrf_sdh_is_enabled>
   290fa:	9b03      	ldr	r3, [sp, #12]
   290fc:	4607      	mov	r7, r0
   290fe:	2800      	cmp	r0, #0
   29100:	d0c1      	beq.n	29086 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x96>
                            if( fullnameFlash_[i] != 0xFF ) return false;
   29102:	4a23      	ldr	r2, [pc, #140]	; (29190 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x1a0>)
   29104:	6810      	ldr	r0, [r2, #0]
   29106:	1e42      	subs	r2, r0, #1
   29108:	f100 0c1f 	add.w	ip, r0, #31
   2910c:	e001      	b.n	29112 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x122>
                        for( auto i = 0; i < fullnameSiz_; i++ ){
   2910e:	4594      	cmp	ip, r2
   29110:	d015      	beq.n	2913e <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x14e>
                            if( fullnameFlash_[i] != 0xFF ) return false;
   29112:	f812 1f01 	ldrb.w	r1, [r2, #1]!
   29116:	29ff      	cmp	r1, #255	; 0xff
   29118:	d0f9      	beq.n	2910e <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x11e>
                        if( busy_ ){
   2911a:	f8df 8078 	ldr.w	r8, [pc, #120]	; 29194 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x1a4>
   2911e:	f898 2000 	ldrb.w	r2, [r8]
   29122:	2a00      	cmp	r2, #0
   29124:	d1af      	bne.n	29086 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x96>
                        u32 err = sd_flash_page_erase(lastPageFlash_);
   29126:	20df      	movs	r0, #223	; 0xdf
   29128:	9303      	str	r3, [sp, #12]
   2912a:	f7ff fa91 	bl	28650 <sd_flash_page_erase>
                        if( err != NRF_SUCCESS ) return false;
   2912e:	9b03      	ldr	r3, [sp, #12]
   29130:	2800      	cmp	r0, #0
   29132:	d1a8      	bne.n	29086 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x96>
                        busy_ = true;
   29134:	2201      	movs	r2, #1
   29136:	f888 2000 	strb.w	r2, [r8]
                        saveName_ = not sdFlashWrite32( (const u32*)fullnameRam_, fullnameSiz_/4 );
   2913a:	702f      	strb	r7, [r5, #0]
   2913c:	e7a3      	b.n	29086 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x96>
                        if( busy_ ){
   2913e:	f8df 8054 	ldr.w	r8, [pc, #84]	; 29194 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x1a4>
   29142:	f898 2000 	ldrb.w	r2, [r8]
   29146:	2a00      	cmp	r2, #0
   29148:	d1f7      	bne.n	2913a <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x14a>
                        u32 err = sd_flash_write((u32*)fullnameFlash_, vals, valsN );
   2914a:	490f      	ldr	r1, [pc, #60]	; (29188 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x198>)
   2914c:	9303      	str	r3, [sp, #12]
   2914e:	2208      	movs	r2, #8
   29150:	f7ff fa7c 	bl	2864c <sd_flash_write>
                        if( err != NRF_SUCCESS ) return false;
   29154:	9b03      	ldr	r3, [sp, #12]
   29156:	2800      	cmp	r0, #0
   29158:	d1ef      	bne.n	2913a <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x14a>
                        busy_ = true;
   2915a:	2201      	movs	r2, #1
                        return true;                       
   2915c:	4607      	mov	r7, r0
                        busy_ = true;
   2915e:	f888 2000 	strb.w	r2, [r8]
                        saveName_ = not sdFlashWrite32( (const u32*)fullnameRam_, fullnameSiz_/4 );
   29162:	702f      	strb	r7, [r5, #0]
   29164:	e78f      	b.n	29086 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x96>
   29166:	f06f 0362 	mvn.w	r3, #98	; 0x62
   2916a:	2409      	movs	r4, #9
   2916c:	e787      	b.n	2907e <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])+0x8e>
   2916e:	bf00      	nop
   29170:	20002219 	.word	0x20002219
   29174:	20002288 	.word	0x20002288
   29178:	20002218 	.word	0x20002218
   2917c:	fffffe70 	.word	0xfffffe70
   29180:	66666667 	.word	0x66666667
   29184:	20002293 	.word	0x20002293
   29188:	20002294 	.word	0x20002294
   2918c:	0002bcfc 	.word	0x0002bcfc
   29190:	20002034 	.word	0x20002034
   29194:	20002292 	.word	0x20002292

00029198 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::power(unsigned char)>:
SA  power           (u8 v) {
   29198:	b508      	push	{r3, lr}
                        error.check( sd_ble_gap_tx_power_set(BLE_GAP_TX_POWER_ROLE_ADV, handle_, SD_TX_LEVELS[v] ) );
   2919a:	280e      	cmp	r0, #14
   2919c:	4b06      	ldr	r3, [pc, #24]	; (291b8 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::power(unsigned char)+0x20>)
   2919e:	4a07      	ldr	r2, [pc, #28]	; (291bc <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::power(unsigned char)+0x24>)
   291a0:	7819      	ldrb	r1, [r3, #0]
   291a2:	bf28      	it	cs
   291a4:	200e      	movcs	r0, #14
   291a6:	5612      	ldrsb	r2, [r2, r0]
   291a8:	2001      	movs	r0, #1
   291aa:	f7ff fa59 	bl	28660 <sd_ble_gap_tx_power_set>
                    }
   291ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
                        error.check( sd_ble_gap_tx_power_set(BLE_GAP_TX_POWER_ROLE_ADV, handle_, SD_TX_LEVELS[v] ) );
   291b2:	b200      	sxth	r0, r0
   291b4:	f7ff ba70 	b.w	28698 <Errors::check(short, bool) [clone .constprop.0]>
   291b8:	20002030 	.word	0x20002030
   291bc:	0002bd08 	.word	0x0002bd08

000291c0 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()>:
SA  start           () -> void {
   291c0:	b570      	push	{r4, r5, r6, lr}
                        if( isActive_ ) return;
   291c2:	4c41      	ldr	r4, [pc, #260]	; (292c8 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x108>)
   291c4:	7823      	ldrb	r3, [r4, #0]
   291c6:	2b00      	cmp	r3, #0
   291c8:	d17c      	bne.n	292c4 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x104>
                        if( connectableTimeout_ and not --connectableTimeout_ ) connectable( false );
   291ca:	4b40      	ldr	r3, [pc, #256]	; (292cc <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x10c>)
   291cc:	7818      	ldrb	r0, [r3, #0]
   291ce:	b120      	cbz	r0, 291da <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x1a>
   291d0:	3801      	subs	r0, #1
   291d2:	b2c0      	uxtb	r0, r0
   291d4:	7018      	strb	r0, [r3, #0]
   291d6:	2800      	cmp	r0, #0
   291d8:	d071      	beq.n	292be <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0xfe>
                        params_.properties.type = isConnectable_ ?
   291da:	4b3d      	ldr	r3, [pc, #244]	; (292d0 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x110>)
                        error.check( sd_ble_gap_adv_set_configure(&handle_, &pdata_, &params_) );
   291dc:	4d3d      	ldr	r5, [pc, #244]	; (292d4 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x114>)
                        params_.properties.type = isConnectable_ ?
   291de:	781b      	ldrb	r3, [r3, #0]
   291e0:	4a3d      	ldr	r2, [pc, #244]	; (292d8 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x118>)
                        error.check( sd_ble_gap_adv_set_configure(&handle_, &pdata_, &params_) );
   291e2:	493e      	ldr	r1, [pc, #248]	; (292dc <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x11c>)
                        params_.properties.type = isConnectable_ ?
   291e4:	2b00      	cmp	r3, #0
   291e6:	bf14      	ite	ne
   291e8:	2301      	movne	r3, #1
   291ea:	2305      	moveq	r3, #5
                        error.check( sd_ble_gap_adv_set_configure(&handle_, &pdata_, &params_) );
   291ec:	4628      	mov	r0, r5
                        params_.properties.type = isConnectable_ ?
   291ee:	7013      	strb	r3, [r2, #0]
                        error.check( sd_ble_gap_adv_set_configure(&handle_, &pdata_, &params_) );
   291f0:	f7ff fa30 	bl	28654 <sd_ble_gap_adv_set_configure>
   291f4:	b200      	sxth	r0, r0
   291f6:	f7ff fa4f 	bl	28698 <Errors::check(short, bool) [clone .constprop.0]>
                        error.check( sd_ble_gap_adv_start(handle_, BLE_CONN_CFG_TAG_DEFAULT) );
   291fa:	2100      	movs	r1, #0
   291fc:	7828      	ldrb	r0, [r5, #0]
   291fe:	f7ff fa2b 	bl	28658 <sd_ble_gap_adv_start>
   29202:	b200      	sxth	r0, r0
   29204:	f7ff fa48 	bl	28698 <Errors::check(short, bool) [clone .constprop.0]>
                        power( txPower_ );
   29208:	4a35      	ldr	r2, [pc, #212]	; (292e0 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x120>)
                        isActive_ = true;
   2920a:	2301      	movs	r3, #1
                        power( txPower_ );
   2920c:	7810      	ldrb	r0, [r2, #0]
                        isActive_ = true;
   2920e:	7023      	strb	r3, [r4, #0]
                        power( txPower_ );
   29210:	f7ff ffc2 	bl	29198 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::power(unsigned char)>
    public:
//============

SA  read            () { return update(); }

SA  isOk            () { return voltage_ > 2100 ; }
   29214:	4b33      	ldr	r3, [pc, #204]	; (292e4 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x124>)
                        if( battery.isOk() ) board.ok(); else board.caution();
   29216:	f9b3 2000 	ldrsh.w	r2, [r3]
   2921a:	f640 0334 	movw	r3, #2100	; 0x834
   2921e:	429a      	cmp	r2, r3
   29220:	dc27      	bgt.n	29272 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0xb2>
SA  isOutput    ()          { return reg.DIRP; }
   29222:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   29226:	f8d3 2720 	ldr.w	r2, [r3, #1824]	; 0x720
                    if( not isOutput() ) return;
   2922a:	07d2      	lsls	r2, r2, #31
   2922c:	d54a      	bpl.n	292c4 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x104>
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   2922e:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   29232:	4c2d      	ldr	r4, [pc, #180]	; (292e8 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x128>)
   29234:	f412 7f80 	tst.w	r2, #256	; 0x100
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   29238:	f44f 7280 	mov.w	r2, #256	; 0x100
   2923c:	bf14      	ite	ne
   2923e:	f8c3 250c 	strne.w	r2, [r3, #1292]	; 0x50c
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   29242:	f8c3 2508 	streq.w	r2, [r3, #1288]	; 0x508
    delay_cycles(cycles);
   29246:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   2924a:	f044 0401 	orr.w	r4, r4, #1
    delay_cycles(cycles);
   2924e:	47a0      	blx	r4
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   29250:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   29254:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   29258:	f412 7f80 	tst.w	r2, #256	; 0x100
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   2925c:	f44f 7280 	mov.w	r2, #256	; 0x100
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   29260:	d025      	beq.n	292ae <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0xee>
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   29262:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
   29266:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   2926a:	4623      	mov	r3, r4
                    }
   2926c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   29270:	4718      	bx	r3
SA  isOutput    ()          { return reg.DIRP; }
   29272:	4b1e      	ldr	r3, [pc, #120]	; (292ec <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x12c>)
   29274:	f8d3 2724 	ldr.w	r2, [r3, #1828]	; 0x724
                    if( not isOutput() ) return;
   29278:	07d1      	lsls	r1, r2, #31
   2927a:	d523      	bpl.n	292c4 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x104>
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   2927c:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   29280:	4c19      	ldr	r4, [pc, #100]	; (292e8 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x128>)
   29282:	f412 7f00 	tst.w	r2, #512	; 0x200
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   29286:	f44f 7200 	mov.w	r2, #512	; 0x200
   2928a:	bf14      	ite	ne
   2928c:	f8c3 250c 	strne.w	r2, [r3, #1292]	; 0x50c
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   29290:	f8c3 2508 	streq.w	r2, [r3, #1288]	; 0x508
    delay_cycles(cycles);
   29294:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   29298:	f044 0401 	orr.w	r4, r4, #1
    delay_cycles(cycles);
   2929c:	47a0      	blx	r4
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   2929e:	4b13      	ldr	r3, [pc, #76]	; (292ec <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x12c>)
   292a0:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   292a4:	f412 7f00 	tst.w	r2, #512	; 0x200
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   292a8:	f44f 7200 	mov.w	r2, #512	; 0x200
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   292ac:	d1d9      	bne.n	29262 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0xa2>
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   292ae:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
   292b2:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   292b6:	4623      	mov	r3, r4
   292b8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   292bc:	4718      	bx	r3
                        if( connectableTimeout_ and not --connectableTimeout_ ) connectable( false );
   292be:	f7ff fdaf 	bl	28e20 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::connectable(bool)>
   292c2:	e78a      	b.n	291da <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()+0x1a>
                    }
   292c4:	bd70      	pop	{r4, r5, r6, pc}
   292c6:	bf00      	nop
   292c8:	20002248 	.word	0x20002248
   292cc:	20002010 	.word	0x20002010
   292d0:	20002011 	.word	0x20002011
   292d4:	20002030 	.word	0x20002030
   292d8:	2000226c 	.word	0x2000226c
   292dc:	20002020 	.word	0x20002020
   292e0:	20002284 	.word	0x20002284
   292e4:	200022b6 	.word	0x200022b6
   292e8:	0002bd20 	.word	0x0002bd20
   292ec:	50000300 	.word	0x50000300

000292f0 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::update(void*)>:
SA  update          (void* pcontext = nullptr) -> void {
   292f0:	b510      	push	{r4, lr}
                        ADdata_.update(buffer_);
   292f2:	4c08      	ldr	r4, [pc, #32]	; (29314 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::update(void*)+0x24>)
                        stop();
   292f4:	f7ff fe68 	bl	28fc8 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::stop()>
                        ADdata_.update(buffer_);
   292f8:	4620      	mov	r0, r4
   292fa:	f7ff fe79 	bl	28ff0 <MyTemperatureAD<TemperatureInternal<(unsigned char)5> >::update(unsigned char (&) [31])>
                        while( buffer_[i] ){
   292fe:	7822      	ldrb	r2, [r4, #0]
   29300:	b12a      	cbz	r2, 2930e <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::update(void*)+0x1e>
                        auto i = 0;
   29302:	2300      	movs	r3, #0
                            auto typ = buffer_[i++];
   29304:	3302      	adds	r3, #2
                            i += len;
   29306:	4413      	add	r3, r2
                        while( buffer_[i] ){
   29308:	5ce2      	ldrb	r2, [r4, r3]
   2930a:	2a00      	cmp	r2, #0
   2930c:	d1fa      	bne.n	29304 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::update(void*)+0x14>
                        start();
   2930e:	f7ff ff57 	bl	291c0 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::start()>
                    }
   29312:	bd10      	pop	{r4, pc}
   29314:	2000224c 	.word	0x2000224c

00029318 <Ble::eventHandler(ble_evt_t const*, void*)>:
------------------------------------------------------------------------------*/
struct Ble {

    private:

SA  eventHandler    (ble_evt_t const * p_ble_evt, void * p_context) {
   29318:	b5b0      	push	{r4, r5, r7, lr}
   2931a:	b082      	sub	sp, #8
                        DebugFuncHeader();
                        Debug( ANSI_NORMAL "header.event_id: %d\n", p_ble_evt->header.evt_id );
                        switch (p_ble_evt->header.evt_id){
   2931c:	8803      	ldrh	r3, [r0, #0]
   2931e:	2b21      	cmp	r3, #33	; 0x21
SA  eventHandler    (ble_evt_t const * p_ble_evt, void * p_context) {
   29320:	af00      	add	r7, sp, #0
                        switch (p_ble_evt->header.evt_id){
   29322:	d044      	beq.n	293ae <Ble::eventHandler(ble_evt_t const*, void*)+0x96>
   29324:	d813      	bhi.n	2934e <Ble::eventHandler(ble_evt_t const*, void*)+0x36>
   29326:	2b10      	cmp	r3, #16
   29328:	d04d      	beq.n	293c6 <Ble::eventHandler(ble_evt_t const*, void*)+0xae>
   2932a:	2b11      	cmp	r3, #17
   2932c:	d152      	bne.n	293d4 <Ble::eventHandler(ble_evt_t const*, void*)+0xbc>
                    cp_init.disconnect_on_fail             = true;

                    error.check( ble_conn_params_init(&cp_init) );
                }

SA  stop        () { error.check( ble_conn_params_stop() ); }
   2932e:	f000 fc0b 	bl	29b48 <ble_conn_params_stop>
   29332:	b200      	sxth	r0, r0
   29334:	f7ff f9b0 	bl	28698 <Errors::check(short, bool) [clone .constprop.0]>
                                break;

                            case BLE_GAP_EVT_DISCONNECTED:
                                Debug( "disconnected\n" );
                                conn.stop(); //no longer need, so stop (?)
                                adv.connectable( false ); //no longer need to be connectable
   29338:	2000      	movs	r0, #0
   2933a:	f7ff fd71 	bl	28e20 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::connectable(bool)>
                                adv.update(); //restart advertising
   2933e:	2000      	movs	r0, #0
   29340:	f7ff ffd6 	bl	292f0 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::update(void*)>
                                adv.timerOn(); //restart adv update timer
   29344:	f7ff fd74 	bl	28e30 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::timerOn()>
                            default:
                                Debug( FG RED "unhandled event\n" ANSI_NORMAL );
                                board.caution(); //red blink
                                break;
                        }
                    }
   29348:	3708      	adds	r7, #8
   2934a:	46bd      	mov	sp, r7
   2934c:	bdb0      	pop	{r4, r5, r7, pc}
                        switch (p_ble_evt->header.evt_id){
   2934e:	2b50      	cmp	r3, #80	; 0x50
   29350:	d140      	bne.n	293d4 <Ble::eventHandler(ble_evt_t const*, void*)+0xbc>
                                if( p_ble_evt->evt.gatts_evt.params.write.uuid.uuid == BLE_UUID_GAP_CHARACTERISTIC_DEVICE_NAME ){
   29352:	8903      	ldrh	r3, [r0, #8]
   29354:	f5b3 5f28 	cmp.w	r3, #10752	; 0x2a00
   29358:	d1f6      	bne.n	29348 <Ble::eventHandler(ble_evt_t const*, void*)+0x30>
                                    uint16_t len = 0;
   2935a:	2400      	movs	r4, #0
                                    sd_ble_gap_device_name_get( NULL, &len );
   2935c:	4620      	mov	r0, r4
   2935e:	1d39      	adds	r1, r7, #4
                                    uint16_t len = 0;
   29360:	80bc      	strh	r4, [r7, #4]
                                    sd_ble_gap_device_name_get( NULL, &len );
   29362:	f7ff f983 	bl	2866c <sd_ble_gap_device_name_get>
                                    uint8_t buf[len+1];
   29366:	88bb      	ldrh	r3, [r7, #4]
   29368:	3308      	adds	r3, #8
                                    Debug("%s\n", buf);
   2936a:	466d      	mov	r5, sp
                                    uint8_t buf[len+1];
   2936c:	08db      	lsrs	r3, r3, #3
   2936e:	eba5 03c3 	sub.w	r3, r5, r3, lsl #3
   29372:	469d      	mov	sp, r3
                                    sd_ble_gap_device_name_get( buf, &len );
   29374:	1d39      	adds	r1, r7, #4
   29376:	4668      	mov	r0, sp
   29378:	f7ff f978 	bl	2866c <sd_ble_gap_device_name_get>
                                    buf[len] = 0; //0 terminate string
   2937c:	88bb      	ldrh	r3, [r7, #4]
                        auto len = strlen(str);
   2937e:	4668      	mov	r0, sp
   29380:	f80d 4003 	strb.w	r4, [sp, r3]
   29384:	f000 fc72 	bl	29c6c <strlen>
                        memset( (void*)fullnameRam_, 0, fullnameSiz_ ); //clear all
   29388:	4621      	mov	r1, r4
   2938a:	2220      	movs	r2, #32
                        auto len = strlen(str);
   2938c:	4604      	mov	r4, r0
                        memset( (void*)fullnameRam_, 0, fullnameSiz_ ); //clear all
   2938e:	4826      	ldr	r0, [pc, #152]	; (29428 <Ble::eventHandler(ble_evt_t const*, void*)+0x110>)
   29390:	f000 fc30 	bl	29bf4 <memset>
                        memcpy( (void*)fullnameRam_, (void*)str, len );
   29394:	2c1f      	cmp	r4, #31
   29396:	4622      	mov	r2, r4
   29398:	4669      	mov	r1, sp
   2939a:	bf28      	it	cs
   2939c:	221f      	movcs	r2, #31
   2939e:	4822      	ldr	r0, [pc, #136]	; (29428 <Ble::eventHandler(ble_evt_t const*, void*)+0x110>)
   293a0:	f000 fc1a 	bl	29bd8 <memcpy>
                        saveName_ = true;
   293a4:	4b21      	ldr	r3, [pc, #132]	; (2942c <Ble::eventHandler(ble_evt_t const*, void*)+0x114>)
   293a6:	2201      	movs	r2, #1
   293a8:	701a      	strb	r2, [r3, #0]
                                    Debug("%s\n", buf);
   293aa:	46ad      	mov	sp, r5
   293ac:	e7cc      	b.n	29348 <Ble::eventHandler(ble_evt_t const*, void*)+0x30>
                                ble_gap_phys_t const phys{ BLE_GAP_PHY_AUTO, BLE_GAP_PHY_AUTO, };
   293ae:	2300      	movs	r3, #0
                                error.check( sd_ble_gap_phy_update(p_ble_evt->evt.gap_evt.conn_handle, &phys) );
   293b0:	1d39      	adds	r1, r7, #4
   293b2:	8880      	ldrh	r0, [r0, #4]
                                ble_gap_phys_t const phys{ BLE_GAP_PHY_AUTO, BLE_GAP_PHY_AUTO, };
   293b4:	80bb      	strh	r3, [r7, #4]
                                error.check( sd_ble_gap_phy_update(p_ble_evt->evt.gap_evt.conn_handle, &phys) );
   293b6:	f7ff f95b 	bl	28670 <sd_ble_gap_phy_update>
   293ba:	b200      	sxth	r0, r0
   293bc:	f7ff f96c 	bl	28698 <Errors::check(short, bool) [clone .constprop.0]>
                    }
   293c0:	3708      	adds	r7, #8
   293c2:	46bd      	mov	sp, r7
   293c4:	bdb0      	pop	{r4, r5, r7, pc}
                                adv.timerOff(); //stop the adv update timer
   293c6:	f7ff fd19 	bl	28dfc <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::timerOff()>
                                adv.isStopped(); //and let adv know it is stopped
   293ca:	f7ff fd23 	bl	28e14 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::isStopped()>
                    }
   293ce:	3708      	adds	r7, #8
   293d0:	46bd      	mov	sp, r7
   293d2:	bdb0      	pop	{r4, r5, r7, pc}
SA  isOutput    ()          { return reg.DIRP; }
   293d4:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   293d8:	f8d3 2720 	ldr.w	r2, [r3, #1824]	; 0x720
                    if( not isOutput() ) return;
   293dc:	07d2      	lsls	r2, r2, #31
   293de:	d5b3      	bpl.n	29348 <Ble::eventHandler(ble_evt_t const*, void*)+0x30>
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   293e0:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   293e4:	4c12      	ldr	r4, [pc, #72]	; (29430 <Ble::eventHandler(ble_evt_t const*, void*)+0x118>)
   293e6:	f412 7f80 	tst.w	r2, #256	; 0x100
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   293ea:	f44f 7280 	mov.w	r2, #256	; 0x100
   293ee:	bf14      	ite	ne
   293f0:	f8c3 250c 	strne.w	r2, [r3, #1292]	; 0x50c
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   293f4:	f8c3 2508 	streq.w	r2, [r3, #1288]	; 0x508
   293f8:	f044 0401 	orr.w	r4, r4, #1
    delay_cycles(cycles);
   293fc:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   29400:	47a0      	blx	r4
SA  toggle      ()          { if( reg.OUT ) low(); else high(); }
   29402:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   29406:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
   2940a:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   2940e:	f412 7f80 	tst.w	r2, #256	; 0x100
SA  low         ()          { reg.OUTCLR = bm_; } //register wide write
   29412:	f44f 7280 	mov.w	r2, #256	; 0x100
   29416:	bf14      	ite	ne
   29418:	f8c3 250c 	strne.w	r2, [r3, #1292]	; 0x50c
SA  high        ()          { reg.OUTSET = bm_; } //register wide write
   2941c:	f8c3 2508 	streq.w	r2, [r3, #1288]	; 0x508
   29420:	47a0      	blx	r4
   29422:	3708      	adds	r7, #8
   29424:	46bd      	mov	sp, r7
   29426:	bdb0      	pop	{r4, r5, r7, pc}
   29428:	20002294 	.word	0x20002294
   2942c:	20002293 	.word	0x20002293
   29430:	0002bd20 	.word	0x0002bd20

00029434 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::init()>:
SA  init            () {
   29434:	b510      	push	{r4, lr}
                        params_.interval = paramInterval_;
   29436:	4b07      	ldr	r3, [pc, #28]	; (29454 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::init()+0x20>)
   29438:	4c07      	ldr	r4, [pc, #28]	; (29458 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::init()+0x24>)
   2943a:	e9d3 0100 	ldrd	r0, r1, [r3]
   2943e:	f001 fc6d 	bl	2ad1c <__aeabi_d2uiz>
   29442:	4603      	mov	r3, r0
                        update();
   29444:	2000      	movs	r0, #0
                        params_.interval = paramInterval_;
   29446:	60a3      	str	r3, [r4, #8]
                        update();
   29448:	f7ff ff52 	bl	292f0 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::update(void*)>
                        timerOn();
   2944c:	f7ff fcf0 	bl	28e30 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::timerOn()>
                    }
   29450:	bd10      	pop	{r4, pc}
   29452:	bf00      	nop
   29454:	20002018 	.word	0x20002018
   29458:	2000226c 	.word	0x2000226c

0002945c <main>:


/*-----------------------------------------------------------------------------
    functions
-----------------------------------------------------------------------------*/
int main() {
   2945c:	b530      	push	{r4, r5, lr}
   2945e:	b089      	sub	sp, #36	; 0x24

    Debug( ANSI_NORMAL FG HOT_PINK "\nBoot start...\n\n" ANSI_NORMAL );

    board.init();           //init board pins
   29460:	f7ff f9ae 	bl	287c0 <Pca10059::init()>
    board.alive();          //blink led's to show boot
   29464:	f7ff f9d0 	bl	28808 <Pca10059::alive()>
------------------------------------------------------------------------------*/
struct Power {

SA  init        () {
                    Debug( "Power::init...\n" );                    
                    error.check( nrf_pwr_mgmt_init() );
   29468:	f7fe fbca 	bl	27c00 <nrf_pwr_mgmt_init>
   2946c:	b200      	sxth	r0, r0
   2946e:	f7ff f913 	bl	28698 <Errors::check(short, bool) [clone .constprop.0]>
#endif

#if NRF_POWER_HAS_DCDCEN
__STATIC_INLINE void nrf_power_dcdcen_set(bool enable)
{
    NRF_POWER->DCDCEN = (enable ?
   29472:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   29476:	2501      	movs	r5, #1
   29478:	f8c3 5578 	str.w	r5, [r3, #1400]	; 0x578
    public:
//===========

SA  init            () {
                        Debug( "Ble::init...\n" );
                        uint32_t ram_start = 0;
   2947c:	2400      	movs	r4, #0
    power.init();           //start power management
    flash.init();           //get name from flash
   2947e:	f7ff fc15 	bl	28cac <Flash::init()>
   29482:	9401      	str	r4, [sp, #4]
                        error.check( nrf_sdh_enable_request() );
   29484:	f000 f890 	bl	295a8 <nrf_sdh_enable_request>
   29488:	b200      	sxth	r0, r0
   2948a:	f7ff f905 	bl	28698 <Errors::check(short, bool) [clone .constprop.0]>
                        error.check( nrf_sdh_ble_default_cfg_set(BLE_CONN_CFG_TAG_DEFAULT, &ram_start) );
   2948e:	a901      	add	r1, sp, #4
   29490:	4620      	mov	r0, r4
   29492:	f000 f965 	bl	29760 <nrf_sdh_ble_default_cfg_set>
   29496:	b200      	sxth	r0, r0
   29498:	f7ff f8fe 	bl	28698 <Errors::check(short, bool) [clone .constprop.0]>
                        error.check( nrf_sdh_ble_enable(&ram_start) );
   2949c:	a801      	add	r0, sp, #4
   2949e:	f000 f9b7 	bl	29810 <nrf_sdh_ble_enable>
   294a2:	b200      	sxth	r0, r0
   294a4:	f7ff f8f8 	bl	28698 <Errors::check(short, bool) [clone .constprop.0]>
    ble.init();             //ble stack init
    ////// now can use sd_* functions //////
    gap.init();             //gap init
   294a8:	f7ff fd02 	bl	28eb0 <Gap::init()>
                    memset(&cp_init, 0, sizeof(cp_init));
   294ac:	4621      	mov	r1, r4
   294ae:	221c      	movs	r2, #28
   294b0:	a801      	add	r0, sp, #4
   294b2:	f000 fb9f 	bl	29bf4 <memset>
                    cp_init.first_conn_params_update_delay = APP_TIMER_TICKS(20000);
   294b6:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
                    cp_init.next_conn_params_update_delay  = APP_TIMER_TICKS(5000);
   294ba:	f44f 32a0 	mov.w	r2, #81920	; 0x14000
                    cp_init.max_conn_params_update_count   = 3;
   294be:	2303      	movs	r3, #3
                    error.check( ble_conn_params_init(&cp_init) );
   294c0:	a801      	add	r0, sp, #4
                    cp_init.next_conn_params_update_delay  = APP_TIMER_TICKS(5000);
   294c2:	e9cd 1202 	strd	r1, r2, [sp, #8]
                    cp_init.max_conn_params_update_count   = 3;
   294c6:	f88d 3010 	strb.w	r3, [sp, #16]
                    cp_init.disconnect_on_fail             = true;
   294ca:	f88d 5014 	strb.w	r5, [sp, #20]
                    error.check( ble_conn_params_init(&cp_init) );
   294ce:	f000 faff 	bl	29ad0 <ble_conn_params_init>
   294d2:	b200      	sxth	r0, r0
   294d4:	f7ff f8e0 	bl	28698 <Errors::check(short, bool) [clone .constprop.0]>
    conn.init();            //connection init
    adv.init();             //advertising init
   294d8:	f7ff ffac 	bl	29434 <Advertising<MyTemperatureAD<TemperatureInternal<(unsigned char)5> >, (unsigned short)3000, 20000ul>::init()>
                    //enable REG1 Dc-Dc (instead of LDO, for 1.8v system)
                    nrf_power_dcdcen_set( true );
                }
SA  sleep       () { 
                    DebugFuncHeader();
                    nrf_pwr_mgmt_run(); 
   294dc:	f7fe fba6 	bl	27c2c <nrf_pwr_mgmt_run>
   294e0:	e7fc      	b.n	294dc <main+0x80>
   294e2:	bf00      	nop

000294e4 <_GLOBAL__sub_I_main>:
    SI Gpio<P0_6, LOWISON>  led1G;
   294e4:	4b21      	ldr	r3, [pc, #132]	; (2956c <_GLOBAL__sub_I_main+0x88>)
   294e6:	681a      	ldr	r2, [r3, #0]
   294e8:	07d2      	lsls	r2, r2, #31
   294ea:	bf5c      	itt	pl
   294ec:	2201      	movpl	r2, #1
   294ee:	601a      	strpl	r2, [r3, #0]
    SI Gpio<P1_9, LOWISON>  led2G;
   294f0:	4b1f      	ldr	r3, [pc, #124]	; (29570 <_GLOBAL__sub_I_main+0x8c>)
   294f2:	681a      	ldr	r2, [r3, #0]
   294f4:	07d0      	lsls	r0, r2, #31
   294f6:	bf5c      	itt	pl
   294f8:	2201      	movpl	r2, #1
   294fa:	601a      	strpl	r2, [r3, #0]
    SI Gpio<P0_12, LOWISON> led2B;
   294fc:	4b1d      	ldr	r3, [pc, #116]	; (29574 <_GLOBAL__sub_I_main+0x90>)
   294fe:	681a      	ldr	r2, [r3, #0]
   29500:	07d1      	lsls	r1, r2, #31
   29502:	bf5c      	itt	pl
   29504:	2201      	movpl	r2, #1
   29506:	601a      	strpl	r2, [r3, #0]
    SI Gpio<P0_8, LOWISON>  led2R;
   29508:	4b1b      	ldr	r3, [pc, #108]	; (29578 <_GLOBAL__sub_I_main+0x94>)
   2950a:	681a      	ldr	r2, [r3, #0]
   2950c:	07d2      	lsls	r2, r2, #31
   2950e:	bf5c      	itt	pl
   29510:	2201      	movpl	r2, #1
   29512:	601a      	strpl	r2, [r3, #0]
    SI Gpio<P1_6, LOWISON>  sw1;
   29514:	4b19      	ldr	r3, [pc, #100]	; (2957c <_GLOBAL__sub_I_main+0x98>)
   29516:	681a      	ldr	r2, [r3, #0]
   29518:	07d0      	lsls	r0, r2, #31
   2951a:	bf5c      	itt	pl
   2951c:	2201      	movpl	r2, #1
   2951e:	601a      	strpl	r2, [r3, #0]
    SI SaadcChan vdd_{ SaadcChan::VDD };
   29520:	4a17      	ldr	r2, [pc, #92]	; (29580 <_GLOBAL__sub_I_main+0x9c>)
   29522:	6813      	ldr	r3, [r2, #0]
   29524:	f013 0301 	ands.w	r3, r3, #1
   29528:	d117      	bne.n	2955a <_GLOBAL__sub_I_main+0x76>

    power.loop();           //power.sleep() loop

    //power.loop will not return

}
   2952a:	b430      	push	{r4, r5}
                        ch_ = ch;
   2952c:	4c15      	ldr	r4, [pc, #84]	; (29584 <_GLOBAL__sub_I_main+0xa0>)
                        pselN_ = (PSEL)it.PSELN;
   2952e:	4d16      	ldr	r5, [pc, #88]	; (29588 <_GLOBAL__sub_I_main+0xa4>)
                        pselP_ = (PSEL)it.PSELP;
   29530:	4916      	ldr	r1, [pc, #88]	; (2958c <_GLOBAL__sub_I_main+0xa8>)
                        ch_ = ch;
   29532:	7023      	strb	r3, [r4, #0]
                        pselN_ = (PSEL)it.PSELN;
   29534:	702b      	strb	r3, [r5, #0]
                        pselP_ = (PSEL)it.PSELP;
   29536:	2409      	movs	r4, #9
    SI Timer timerAdvUpdate_;
   29538:	4b15      	ldr	r3, [pc, #84]	; (29590 <_GLOBAL__sub_I_main+0xac>)
   2953a:	700c      	strb	r4, [r1, #0]
   2953c:	2101      	movs	r1, #1
   2953e:	6011      	str	r1, [r2, #0]
   29540:	681a      	ldr	r2, [r3, #0]
                        config_ = it.CONFIG;
   29542:	4814      	ldr	r0, [pc, #80]	; (29594 <_GLOBAL__sub_I_main+0xb0>)
   29544:	f44f 3400 	mov.w	r4, #131072	; 0x20000
   29548:	07d1      	lsls	r1, r2, #31
   2954a:	6004      	str	r4, [r0, #0]
   2954c:	d403      	bmi.n	29556 <_GLOBAL__sub_I_main+0x72>
    Timer           (){}
   2954e:	4a12      	ldr	r2, [pc, #72]	; (29598 <_GLOBAL__sub_I_main+0xb4>)
   29550:	2101      	movs	r1, #1
   29552:	6212      	str	r2, [r2, #32]
   29554:	6019      	str	r1, [r3, #0]
   29556:	bc30      	pop	{r4, r5}
   29558:	4770      	bx	lr
   2955a:	4b0d      	ldr	r3, [pc, #52]	; (29590 <_GLOBAL__sub_I_main+0xac>)
   2955c:	681a      	ldr	r2, [r3, #0]
   2955e:	07d2      	lsls	r2, r2, #31
   29560:	bf5f      	itttt	pl
   29562:	4a0d      	ldrpl	r2, [pc, #52]	; (29598 <_GLOBAL__sub_I_main+0xb4>)
   29564:	2101      	movpl	r1, #1
   29566:	6212      	strpl	r2, [r2, #32]
   29568:	6019      	strpl	r1, [r3, #0]
   2956a:	4770      	bx	lr
   2956c:	20002214 	.word	0x20002214
   29570:	20002210 	.word	0x20002210
   29574:	2000220c 	.word	0x2000220c
   29578:	20002208 	.word	0x20002208
   2957c:	20002204 	.word	0x20002204
   29580:	20002200 	.word	0x20002200
   29584:	200022be 	.word	0x200022be
   29588:	200022bc 	.word	0x200022bc
   2958c:	200022bd 	.word	0x200022bd
   29590:	200021fc 	.word	0x200021fc
   29594:	200022b8 	.word	0x200022b8
   29598:	20002220 	.word	0x20002220

0002959c <ble_srv_is_notification_enabled>:
 *
 * @return      Decoded value.
 */
static __INLINE uint16_t uint16_decode(const uint8_t * p_encoded_data)
{
        return ( (((uint16_t)((uint8_t *)p_encoded_data)[0])) |
   2959c:	7800      	ldrb	r0, [r0, #0]

bool ble_srv_is_notification_enabled(uint8_t const * p_encoded_data)
{
    uint16_t cccd_value = uint16_decode(p_encoded_data);
    return ((cccd_value & BLE_GATT_HVX_NOTIFICATION) != 0);
}
   2959e:	f000 0001 	and.w	r0, r0, #1
   295a2:	4770      	bx	lr

000295a4 <sd_softdevice_enable>:
 * @retval ::NRF_ERROR_INVALID_STATE SoftDevice is already enabled, and the clock source and fault handler cannot be updated.
 * @retval ::NRF_ERROR_SDM_INCORRECT_INTERRUPT_CONFIGURATION SoftDevice interrupt is already enabled, or an enabled interrupt has an illegal priority level.
 * @retval ::NRF_ERROR_SDM_LFCLK_SOURCE_UNKNOWN Unknown low frequency clock source selected.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid clock source configuration supplied in p_clock_lf_cfg.
 */
SVCALL(SD_SOFTDEVICE_ENABLE, uint32_t, sd_softdevice_enable(nrf_clock_lf_cfg_t const * p_clock_lf_cfg, nrf_fault_handler_t fault_handler));
   295a4:	df10      	svc	16
   295a6:	4770      	bx	lr

000295a8 <nrf_sdh_enable_request>:
#endif
}


ret_code_t nrf_sdh_enable_request(void)
{
   295a8:	b570      	push	{r4, r5, r6, lr}
    ret_code_t ret_code;

    if (m_nrf_sdh_enabled)
   295aa:	4d3c      	ldr	r5, [pc, #240]	; (2969c <nrf_sdh_enable_request+0xf4>)
   295ac:	782b      	ldrb	r3, [r5, #0]
{
   295ae:	b084      	sub	sp, #16
    if (m_nrf_sdh_enabled)
   295b0:	2b00      	cmp	r3, #0
   295b2:	d166      	bne.n	29682 <nrf_sdh_enable_request+0xda>
    {
        return NRF_ERROR_INVALID_STATE;
    }

    m_nrf_sdh_continue = true;
   295b4:	4e3a      	ldr	r6, [pc, #232]	; (296a0 <nrf_sdh_enable_request+0xf8>)
    for (nrf_section_iter_init(&iter, &sdh_req_observers);
   295b6:	493b      	ldr	r1, [pc, #236]	; (296a4 <nrf_sdh_enable_request+0xfc>)
    m_nrf_sdh_continue = true;
   295b8:	2301      	movs	r3, #1
    for (nrf_section_iter_init(&iter, &sdh_req_observers);
   295ba:	a802      	add	r0, sp, #8
    m_nrf_sdh_continue = true;
   295bc:	7033      	strb	r3, [r6, #0]
    for (nrf_section_iter_init(&iter, &sdh_req_observers);
   295be:	f7fe fb5f 	bl	27c80 <nrf_section_iter_init>
         nrf_section_iter_get(&iter) != NULL;
   295c2:	9b03      	ldr	r3, [sp, #12]
    for (nrf_section_iter_init(&iter, &sdh_req_observers);
   295c4:	b923      	cbnz	r3, 295d0 <nrf_sdh_enable_request+0x28>
   295c6:	e00e      	b.n	295e6 <nrf_sdh_enable_request+0x3e>
         nrf_section_iter_next(&iter))
   295c8:	f7fe fb64 	bl	27c94 <nrf_section_iter_next>
         nrf_section_iter_get(&iter) != NULL;
   295cc:	9b03      	ldr	r3, [sp, #12]
    for (nrf_section_iter_init(&iter, &sdh_req_observers);
   295ce:	b153      	cbz	r3, 295e6 <nrf_sdh_enable_request+0x3e>
        if (handler(req, p_observer->p_context))
   295d0:	e9d3 2100 	ldrd	r2, r1, [r3]
   295d4:	2000      	movs	r0, #0
   295d6:	4790      	blx	r2
   295d8:	4604      	mov	r4, r0
         nrf_section_iter_next(&iter))
   295da:	a802      	add	r0, sp, #8
        if (handler(req, p_observer->p_context))
   295dc:	2c00      	cmp	r4, #0
   295de:	d1f3      	bne.n	295c8 <nrf_sdh_enable_request+0x20>

    // Notify observers about a finished SoftDevice enable process.
    sdh_state_observer_notify(NRF_SDH_EVT_STATE_ENABLED);

    return NRF_SUCCESS;
}
   295e0:	4620      	mov	r0, r4
   295e2:	b004      	add	sp, #16
   295e4:	bd70      	pop	{r4, r5, r6, pc}
    for (nrf_section_iter_init(&iter, &sdh_state_observers);
   295e6:	4930      	ldr	r1, [pc, #192]	; (296a8 <nrf_sdh_enable_request+0x100>)
   295e8:	a802      	add	r0, sp, #8
   295ea:	f7fe fb49 	bl	27c80 <nrf_section_iter_init>
         nrf_section_iter_get(&iter) != NULL;
   295ee:	9b03      	ldr	r3, [sp, #12]
    for (nrf_section_iter_init(&iter, &sdh_state_observers);
   295f0:	b14b      	cbz	r3, 29606 <nrf_sdh_enable_request+0x5e>
        handler(evt, p_observer->p_context);
   295f2:	e9d3 2100 	ldrd	r2, r1, [r3]
   295f6:	2000      	movs	r0, #0
   295f8:	4790      	blx	r2
         nrf_section_iter_next(&iter))
   295fa:	a802      	add	r0, sp, #8
   295fc:	f7fe fb4a 	bl	27c94 <nrf_section_iter_next>
         nrf_section_iter_get(&iter) != NULL;
   29600:	9b03      	ldr	r3, [sp, #12]
    for (nrf_section_iter_init(&iter, &sdh_state_observers);
   29602:	2b00      	cmp	r3, #0
   29604:	d1f5      	bne.n	295f2 <nrf_sdh_enable_request+0x4a>
    nrf_clock_lf_cfg_t const clock_lf_cfg =
   29606:	4a29      	ldr	r2, [pc, #164]	; (296ac <nrf_sdh_enable_request+0x104>)
    CRITICAL_REGION_ENTER();
   29608:	2300      	movs	r3, #0
    nrf_clock_lf_cfg_t const clock_lf_cfg =
   2960a:	6812      	ldr	r2, [r2, #0]
    CRITICAL_REGION_ENTER();
   2960c:	f88d 3008 	strb.w	r3, [sp, #8]
   29610:	a802      	add	r0, sp, #8
    nrf_clock_lf_cfg_t const clock_lf_cfg =
   29612:	9201      	str	r2, [sp, #4]
    CRITICAL_REGION_ENTER();
   29614:	f7fe f8de 	bl	277d4 <app_util_critical_region_enter>
    ret_code = sd_softdevice_enable(&clock_lf_cfg, app_error_fault_handler);
   29618:	4925      	ldr	r1, [pc, #148]	; (296b0 <nrf_sdh_enable_request+0x108>)
   2961a:	a801      	add	r0, sp, #4
   2961c:	f7ff ffc2 	bl	295a4 <sd_softdevice_enable>
    m_nrf_sdh_enabled = (ret_code == NRF_SUCCESS);
   29620:	fab0 f380 	clz	r3, r0
   29624:	4604      	mov	r4, r0
   29626:	095b      	lsrs	r3, r3, #5
    CRITICAL_REGION_EXIT();
   29628:	f89d 0008 	ldrb.w	r0, [sp, #8]
    m_nrf_sdh_enabled = (ret_code == NRF_SUCCESS);
   2962c:	702b      	strb	r3, [r5, #0]
    CRITICAL_REGION_EXIT();
   2962e:	f7fe f8f7 	bl	27820 <app_util_critical_region_exit>
    if (ret_code != NRF_SUCCESS)
   29632:	2c00      	cmp	r4, #0
   29634:	d1d4      	bne.n	295e0 <nrf_sdh_enable_request+0x38>
    m_nrf_sdh_suspended = false;
   29636:	4b1f      	ldr	r3, [pc, #124]	; (296b4 <nrf_sdh_enable_request+0x10c>)
    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
   29638:	491f      	ldr	r1, [pc, #124]	; (296b8 <nrf_sdh_enable_request+0x110>)
   2963a:	701c      	strb	r4, [r3, #0]
    m_nrf_sdh_continue  = false;
   2963c:	7034      	strb	r4, [r6, #0]
   2963e:	f891 2316 	ldrb.w	r2, [r1, #790]	; 0x316
   || (((1 << priority) & __NRF_NVIC_APP_IRQ_PRIOS) == 0)
   29642:	23ec      	movs	r3, #236	; 0xec
   29644:	0952      	lsrs	r2, r2, #5
   29646:	4113      	asrs	r3, r2
   29648:	07db      	lsls	r3, r3, #31
   2964a:	d51e      	bpl.n	2968a <nrf_sdh_enable_request+0xe2>
  if (nrf_nvic_state.__cr_flag)
   2964c:	4b1b      	ldr	r3, [pc, #108]	; (296bc <nrf_sdh_enable_request+0x114>)
   2964e:	689a      	ldr	r2, [r3, #8]
   29650:	b302      	cbz	r2, 29694 <nrf_sdh_enable_request+0xec>
    nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] |= (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));
   29652:	681a      	ldr	r2, [r3, #0]
   29654:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
   29658:	601a      	str	r2, [r3, #0]
    for (nrf_section_iter_init(&iter, &sdh_state_observers);
   2965a:	4913      	ldr	r1, [pc, #76]	; (296a8 <nrf_sdh_enable_request+0x100>)
   2965c:	a802      	add	r0, sp, #8
   2965e:	f7fe fb0f 	bl	27c80 <nrf_section_iter_init>
         nrf_section_iter_get(&iter) != NULL;
   29662:	9b03      	ldr	r3, [sp, #12]
    for (nrf_section_iter_init(&iter, &sdh_state_observers);
   29664:	2b00      	cmp	r3, #0
   29666:	d0bb      	beq.n	295e0 <nrf_sdh_enable_request+0x38>
        handler(evt, p_observer->p_context);
   29668:	e9d3 2100 	ldrd	r2, r1, [r3]
   2966c:	2001      	movs	r0, #1
   2966e:	4790      	blx	r2
         nrf_section_iter_next(&iter))
   29670:	a802      	add	r0, sp, #8
   29672:	f7fe fb0f 	bl	27c94 <nrf_section_iter_next>
         nrf_section_iter_get(&iter) != NULL;
   29676:	9b03      	ldr	r3, [sp, #12]
    for (nrf_section_iter_init(&iter, &sdh_state_observers);
   29678:	2b00      	cmp	r3, #0
   2967a:	d1f5      	bne.n	29668 <nrf_sdh_enable_request+0xc0>
}
   2967c:	4620      	mov	r0, r4
   2967e:	b004      	add	sp, #16
   29680:	bd70      	pop	{r4, r5, r6, pc}
        return NRF_ERROR_INVALID_STATE;
   29682:	2408      	movs	r4, #8
}
   29684:	4620      	mov	r0, r4
   29686:	b004      	add	sp, #16
   29688:	bd70      	pop	{r4, r5, r6, pc}
    APP_ERROR_CHECK(ret_code);
   2968a:	f242 0002 	movw	r0, #8194	; 0x2002
   2968e:	f7fd fe33 	bl	272f8 <app_error_handler_bare>
   29692:	e7e2      	b.n	2965a <nrf_sdh_enable_request+0xb2>
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   29694:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   29698:	600b      	str	r3, [r1, #0]
   2969a:	e7de      	b.n	2965a <nrf_sdh_enable_request+0xb2>
   2969c:	200022c2 	.word	0x200022c2
   296a0:	200022c1 	.word	0x200022c1
   296a4:	0002bd2c 	.word	0x0002bd2c
   296a8:	0002bd44 	.word	0x0002bd44
   296ac:	0002bd28 	.word	0x0002bd28
   296b0:	00027319 	.word	0x00027319
   296b4:	200022c3 	.word	0x200022c3
   296b8:	e000e100 	.word	0xe000e100
   296bc:	2000232c 	.word	0x2000232c

000296c0 <nrf_sdh_is_enabled>:
}


bool nrf_sdh_is_enabled(void)
{
    return m_nrf_sdh_enabled;
   296c0:	4b01      	ldr	r3, [pc, #4]	; (296c8 <nrf_sdh_is_enabled+0x8>)
}
   296c2:	7818      	ldrb	r0, [r3, #0]
   296c4:	4770      	bx	lr
   296c6:	bf00      	nop
   296c8:	200022c2 	.word	0x200022c2

000296cc <SWI2_EGU2_IRQHandler>:


#if (NRF_SDH_DISPATCH_MODEL == NRF_SDH_DISPATCH_MODEL_INTERRUPT)

void SD_EVT_IRQHandler(void)
{
   296cc:	b500      	push	{lr}
   296ce:	b083      	sub	sp, #12
    for (nrf_section_iter_init(&iter, &sdh_stack_observers);
   296d0:	4908      	ldr	r1, [pc, #32]	; (296f4 <SWI2_EGU2_IRQHandler+0x28>)
   296d2:	4668      	mov	r0, sp
   296d4:	f7fe fad4 	bl	27c80 <nrf_section_iter_init>
         nrf_section_iter_get(&iter) != NULL;
   296d8:	9b01      	ldr	r3, [sp, #4]
    for (nrf_section_iter_init(&iter, &sdh_stack_observers);
   296da:	b143      	cbz	r3, 296ee <SWI2_EGU2_IRQHandler+0x22>
        handler(p_observer->p_context);
   296dc:	e9d3 2000 	ldrd	r2, r0, [r3]
   296e0:	4790      	blx	r2
         nrf_section_iter_next(&iter))
   296e2:	4668      	mov	r0, sp
   296e4:	f7fe fad6 	bl	27c94 <nrf_section_iter_next>
         nrf_section_iter_get(&iter) != NULL;
   296e8:	9b01      	ldr	r3, [sp, #4]
    for (nrf_section_iter_init(&iter, &sdh_stack_observers);
   296ea:	2b00      	cmp	r3, #0
   296ec:	d1f6      	bne.n	296dc <SWI2_EGU2_IRQHandler+0x10>
    nrf_sdh_evts_poll();
}
   296ee:	b003      	add	sp, #12
   296f0:	f85d fb04 	ldr.w	pc, [sp], #4
   296f4:	0002bd38 	.word	0x0002bd38

000296f8 <sd_ble_enable>:
 *                                      and set the start address of the application RAM region accordingly.
 *                                    - Dynamic part of the SoftDevice RAM region is larger then 64 kB which
 *                                      is currently not supported.
 * @retval ::NRF_ERROR_RESOURCES      The total number of L2CAP Channels configured using @ref sd_ble_cfg_set is too large.
 */
SVCALL(SD_BLE_ENABLE, uint32_t, sd_ble_enable(uint32_t * p_app_ram_base));
   296f8:	df60      	svc	96	; 0x60
   296fa:	4770      	bx	lr

000296fc <sd_ble_cfg_set>:
 * @retval ::NRF_ERROR_INVALID_ADDR   Invalid or not sufficiently aligned pointer supplied.
 * @retval ::NRF_ERROR_INVALID_PARAM  Invalid cfg_id supplied.
 * @retval ::NRF_ERROR_NO_MEM         The amount of memory assigned to the SoftDevice by app_ram_base is not
 *                                    large enough to fit this configuration's memory requirement.
 */
SVCALL(SD_BLE_CFG_SET, uint32_t, sd_ble_cfg_set(uint32_t cfg_id, ble_cfg_t const * p_cfg, uint32_t app_ram_base));
   296fc:	df69      	svc	105	; 0x69
   296fe:	4770      	bx	lr

00029700 <sd_ble_evt_get>:
 * @retval ::NRF_SUCCESS Event pulled and stored into the supplied buffer.
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid or not sufficiently aligned pointer supplied.
 * @retval ::NRF_ERROR_NOT_FOUND No events ready to be pulled.
 * @retval ::NRF_ERROR_DATA_SIZE Event ready but could not fit into the supplied buffer.
 */
SVCALL(SD_BLE_EVT_GET, uint32_t, sd_ble_evt_get(uint8_t *p_dest, uint16_t *p_len));
   29700:	df61      	svc	97	; 0x61
   29702:	4770      	bx	lr

00029704 <nrf_sdh_ble_evts_poll>:
{
    UNUSED_VARIABLE(p_context);

    ret_code_t ret_code;

    if (!m_stack_is_enabled)
   29704:	4b14      	ldr	r3, [pc, #80]	; (29758 <nrf_sdh_ble_evts_poll+0x54>)
   29706:	781b      	ldrb	r3, [r3, #0]
   29708:	b32b      	cbz	r3, 29756 <nrf_sdh_ble_evts_poll+0x52>
{
   2970a:	b530      	push	{r4, r5, lr}

        NRF_LOG_DEBUG("BLE event: 0x%x.", p_ble_evt->header.evt_id);

        // Forward the event to BLE observers.
        nrf_section_iter_t  iter;
        for (nrf_section_iter_init(&iter, &sdh_ble_observers);
   2970c:	4d13      	ldr	r5, [pc, #76]	; (2975c <nrf_sdh_ble_evts_poll+0x58>)
{
   2970e:	b091      	sub	sp, #68	; 0x44
        uint16_t    evt_len = (uint16_t)sizeof(evt_buffer);
   29710:	2434      	movs	r4, #52	; 0x34
        ret_code = sd_ble_evt_get(evt_buffer, &evt_len);
   29712:	f10d 0102 	add.w	r1, sp, #2
   29716:	a803      	add	r0, sp, #12
        uint16_t    evt_len = (uint16_t)sizeof(evt_buffer);
   29718:	f8ad 4002 	strh.w	r4, [sp, #2]
        ret_code = sd_ble_evt_get(evt_buffer, &evt_len);
   2971c:	f7ff fff0 	bl	29700 <sd_ble_evt_get>
        if (ret_code != NRF_SUCCESS)
   29720:	b988      	cbnz	r0, 29746 <nrf_sdh_ble_evts_poll+0x42>
        for (nrf_section_iter_init(&iter, &sdh_ble_observers);
   29722:	4629      	mov	r1, r5
   29724:	a801      	add	r0, sp, #4
   29726:	f7fe faab 	bl	27c80 <nrf_section_iter_init>
             nrf_section_iter_get(&iter) != NULL;
   2972a:	9b02      	ldr	r3, [sp, #8]
        for (nrf_section_iter_init(&iter, &sdh_ble_observers);
   2972c:	2b00      	cmp	r3, #0
   2972e:	d0f0      	beq.n	29712 <nrf_sdh_ble_evts_poll+0xe>
            nrf_sdh_ble_evt_handler_t    handler;

            p_observer = (nrf_sdh_ble_evt_observer_t *)nrf_section_iter_get(&iter);
            handler    = p_observer->handler;

            handler(p_ble_evt, p_observer->p_context);
   29730:	e9d3 2100 	ldrd	r2, r1, [r3]
   29734:	a803      	add	r0, sp, #12
   29736:	4790      	blx	r2
             nrf_section_iter_next(&iter))
   29738:	a801      	add	r0, sp, #4
   2973a:	f7fe faab 	bl	27c94 <nrf_section_iter_next>
             nrf_section_iter_get(&iter) != NULL;
   2973e:	9b02      	ldr	r3, [sp, #8]
        for (nrf_section_iter_init(&iter, &sdh_ble_observers);
   29740:	2b00      	cmp	r3, #0
   29742:	d1f5      	bne.n	29730 <nrf_sdh_ble_evts_poll+0x2c>
   29744:	e7e5      	b.n	29712 <nrf_sdh_ble_evts_poll+0xe>
        }
    }

    if (ret_code != NRF_ERROR_NOT_FOUND)
   29746:	2805      	cmp	r0, #5
   29748:	d101      	bne.n	2974e <nrf_sdh_ble_evts_poll+0x4a>
    {
        APP_ERROR_HANDLER(ret_code);
    }
}
   2974a:	b011      	add	sp, #68	; 0x44
   2974c:	bd30      	pop	{r4, r5, pc}
        APP_ERROR_HANDLER(ret_code);
   2974e:	f7fd fdd3 	bl	272f8 <app_error_handler_bare>
}
   29752:	b011      	add	sp, #68	; 0x44
   29754:	bd30      	pop	{r4, r5, pc}
   29756:	4770      	bx	lr
   29758:	200022c4 	.word	0x200022c4
   2975c:	0002bd50 	.word	0x0002bd50

00029760 <nrf_sdh_ble_default_cfg_set>:
    if (p_app_ram_start == NULL)
   29760:	2900      	cmp	r1, #0
   29762:	d051      	beq.n	29808 <nrf_sdh_ble_default_cfg_set+0xa8>
{
   29764:	b570      	push	{r4, r5, r6, lr}
    *p_app_ram_start = APP_RAM_START;
   29766:	4b29      	ldr	r3, [pc, #164]	; (2980c <nrf_sdh_ble_default_cfg_set+0xac>)
   29768:	600b      	str	r3, [r1, #0]
{
   2976a:	b084      	sub	sp, #16
   2976c:	460c      	mov	r4, r1
   2976e:	4605      	mov	r5, r0
    memset(&ble_cfg, 0, sizeof(ble_cfg));
   29770:	220c      	movs	r2, #12
   29772:	a801      	add	r0, sp, #4
   29774:	2100      	movs	r1, #0
   29776:	f000 fa3d 	bl	29bf4 <memset>
    ble_cfg.conn_cfg.params.gap_conn_cfg.conn_count   = NRF_SDH_BLE_TOTAL_LINK_COUNT;
   2977a:	2601      	movs	r6, #1
    ble_cfg.conn_cfg.params.gap_conn_cfg.event_length = NRF_SDH_BLE_GAP_EVENT_LENGTH;
   2977c:	2306      	movs	r3, #6
    ret_code = sd_ble_cfg_set(BLE_CONN_CFG_GAP, &ble_cfg, *p_ram_start);
   2977e:	6822      	ldr	r2, [r4, #0]
    ble_cfg.conn_cfg.params.gap_conn_cfg.event_length = NRF_SDH_BLE_GAP_EVENT_LENGTH;
   29780:	f8ad 3008 	strh.w	r3, [sp, #8]
    ret_code = sd_ble_cfg_set(BLE_CONN_CFG_GAP, &ble_cfg, *p_ram_start);
   29784:	a901      	add	r1, sp, #4
   29786:	2020      	movs	r0, #32
    ble_cfg.conn_cfg.conn_cfg_tag                     = conn_cfg_tag;
   29788:	f88d 5004 	strb.w	r5, [sp, #4]
    ble_cfg.conn_cfg.params.gap_conn_cfg.conn_count   = NRF_SDH_BLE_TOTAL_LINK_COUNT;
   2978c:	f88d 6006 	strb.w	r6, [sp, #6]
    ret_code = sd_ble_cfg_set(BLE_CONN_CFG_GAP, &ble_cfg, *p_ram_start);
   29790:	f7ff ffb4 	bl	296fc <sd_ble_cfg_set>
    memset(&ble_cfg, 0, sizeof(ble_cfg));
   29794:	a801      	add	r0, sp, #4
   29796:	220c      	movs	r2, #12
   29798:	2100      	movs	r1, #0
   2979a:	f000 fa2b 	bl	29bf4 <memset>
    ble_cfg.gap_cfg.role_count_cfg.central_role_count = NRF_SDH_BLE_CENTRAL_LINK_COUNT;
   2979e:	2500      	movs	r5, #0
    ret_code = sd_ble_cfg_set(BLE_GAP_CFG_ROLE_COUNT, &ble_cfg, *p_ram_start);
   297a0:	6822      	ldr	r2, [r4, #0]
    ble_cfg.gap_cfg.role_count_cfg.periph_role_count  = NRF_SDH_BLE_PERIPHERAL_LINK_COUNT;
   297a2:	f88d 6005 	strb.w	r6, [sp, #5]
    ret_code = sd_ble_cfg_set(BLE_GAP_CFG_ROLE_COUNT, &ble_cfg, *p_ram_start);
   297a6:	a901      	add	r1, sp, #4
   297a8:	2040      	movs	r0, #64	; 0x40
    ble_cfg.gap_cfg.role_count_cfg.central_role_count = NRF_SDH_BLE_CENTRAL_LINK_COUNT;
   297aa:	f8ad 5006 	strh.w	r5, [sp, #6]
    ret_code = sd_ble_cfg_set(BLE_GAP_CFG_ROLE_COUNT, &ble_cfg, *p_ram_start);
   297ae:	f7ff ffa5 	bl	296fc <sd_ble_cfg_set>
    memset(&ble_cfg, 0, sizeof(ble_cfg));
   297b2:	4629      	mov	r1, r5
   297b4:	a801      	add	r0, sp, #4
   297b6:	220c      	movs	r2, #12
   297b8:	f000 fa1c 	bl	29bf4 <memset>
    ret_code = sd_ble_cfg_set(BLE_COMMON_CFG_VS_UUID, &ble_cfg, *p_ram_start);
   297bc:	6822      	ldr	r2, [r4, #0]
    ble_cfg.common_cfg.vs_uuid_cfg.vs_uuid_count = NRF_SDH_BLE_VS_UUID_COUNT;
   297be:	f88d 5004 	strb.w	r5, [sp, #4]
    ret_code = sd_ble_cfg_set(BLE_COMMON_CFG_VS_UUID, &ble_cfg, *p_ram_start);
   297c2:	a901      	add	r1, sp, #4
   297c4:	4630      	mov	r0, r6
   297c6:	f7ff ff99 	bl	296fc <sd_ble_cfg_set>
    memset(&ble_cfg, 0x00, sizeof(ble_cfg));
   297ca:	4629      	mov	r1, r5
   297cc:	a801      	add	r0, sp, #4
   297ce:	220c      	movs	r2, #12
   297d0:	f000 fa10 	bl	29bf4 <memset>
    ble_cfg.gatts_cfg.attr_tab_size.attr_tab_size = NRF_SDH_BLE_GATTS_ATTR_TAB_SIZE;
   297d4:	23f8      	movs	r3, #248	; 0xf8
    ret_code = sd_ble_cfg_set(BLE_GATTS_CFG_ATTR_TAB_SIZE, &ble_cfg, *p_ram_start);
   297d6:	6822      	ldr	r2, [r4, #0]
    ble_cfg.gatts_cfg.attr_tab_size.attr_tab_size = NRF_SDH_BLE_GATTS_ATTR_TAB_SIZE;
   297d8:	9301      	str	r3, [sp, #4]
    ret_code = sd_ble_cfg_set(BLE_GATTS_CFG_ATTR_TAB_SIZE, &ble_cfg, *p_ram_start);
   297da:	a901      	add	r1, sp, #4
   297dc:	20a1      	movs	r0, #161	; 0xa1
   297de:	f7ff ff8d 	bl	296fc <sd_ble_cfg_set>
    memset(&ble_cfg, 0x00, sizeof(ble_cfg));
   297e2:	4629      	mov	r1, r5
   297e4:	a801      	add	r0, sp, #4
   297e6:	220c      	movs	r2, #12
   297e8:	f000 fa04 	bl	29bf4 <memset>
    ble_cfg.gatts_cfg.service_changed.service_changed = NRF_SDH_BLE_SERVICE_CHANGED;
   297ec:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret_code = sd_ble_cfg_set(BLE_GATTS_CFG_SERVICE_CHANGED, &ble_cfg, *p_ram_start);
   297f0:	6822      	ldr	r2, [r4, #0]
    ble_cfg.gatts_cfg.service_changed.service_changed = NRF_SDH_BLE_SERVICE_CHANGED;
   297f2:	f365 0300 	bfi	r3, r5, #0, #1
    ret_code = sd_ble_cfg_set(BLE_GATTS_CFG_SERVICE_CHANGED, &ble_cfg, *p_ram_start);
   297f6:	a901      	add	r1, sp, #4
   297f8:	20a0      	movs	r0, #160	; 0xa0
    ble_cfg.gatts_cfg.service_changed.service_changed = NRF_SDH_BLE_SERVICE_CHANGED;
   297fa:	f88d 3004 	strb.w	r3, [sp, #4]
    ret_code = sd_ble_cfg_set(BLE_GATTS_CFG_SERVICE_CHANGED, &ble_cfg, *p_ram_start);
   297fe:	f7ff ff7d 	bl	296fc <sd_ble_cfg_set>
    return NRF_SUCCESS;
   29802:	4628      	mov	r0, r5
}
   29804:	b004      	add	sp, #16
   29806:	bd70      	pop	{r4, r5, r6, pc}
        return NRF_ERROR_NULL;
   29808:	200e      	movs	r0, #14
}
   2980a:	4770      	bx	lr
   2980c:	20002000 	.word	0x20002000

00029810 <nrf_sdh_ble_enable>:
{
   29810:	b508      	push	{r3, lr}
    ret_code_t ret_code = sd_ble_enable(p_app_ram_start);
   29812:	f7ff ff71 	bl	296f8 <sd_ble_enable>
    if (ret_code == NRF_SUCCESS)
   29816:	b910      	cbnz	r0, 2981e <nrf_sdh_ble_enable+0xe>
        m_stack_is_enabled = true;
   29818:	4b01      	ldr	r3, [pc, #4]	; (29820 <nrf_sdh_ble_enable+0x10>)
   2981a:	2201      	movs	r2, #1
   2981c:	701a      	strb	r2, [r3, #0]
}
   2981e:	bd08      	pop	{r3, pc}
   29820:	200022c4 	.word	0x200022c4

00029824 <sd_evt_get>:
SVCALL(SD_EVT_GET, uint32_t, sd_evt_get(uint32_t * p_evt_id));
   29824:	df4b      	svc	75	; 0x4b
   29826:	4770      	bx	lr

00029828 <nrf_sdh_soc_evts_poll>:
/**@brief   Function for polling SoC events.
 *
 * @param[in]   p_context   Context of the observer.
 */
static void nrf_sdh_soc_evts_poll(void * p_context)
{
   29828:	b510      	push	{r4, lr}

        NRF_LOG_DEBUG("SoC event: 0x%x.", evt_id);

        // Forward the event to SoC observers.
        nrf_section_iter_t  iter;
        for (nrf_section_iter_init(&iter, &sdh_soc_observers);
   2982a:	4c11      	ldr	r4, [pc, #68]	; (29870 <nrf_sdh_soc_evts_poll+0x48>)
{
   2982c:	b084      	sub	sp, #16
        ret_code = sd_evt_get(&evt_id);
   2982e:	a801      	add	r0, sp, #4
   29830:	f7ff fff8 	bl	29824 <sd_evt_get>
        if (ret_code != NRF_SUCCESS)
   29834:	b9a8      	cbnz	r0, 29862 <nrf_sdh_soc_evts_poll+0x3a>
        for (nrf_section_iter_init(&iter, &sdh_soc_observers);
   29836:	4621      	mov	r1, r4
   29838:	a802      	add	r0, sp, #8
   2983a:	f7fe fa21 	bl	27c80 <nrf_section_iter_init>
             nrf_section_iter_get(&iter) != NULL;
   2983e:	9b03      	ldr	r3, [sp, #12]
        for (nrf_section_iter_init(&iter, &sdh_soc_observers);
   29840:	2b00      	cmp	r3, #0
   29842:	d0f4      	beq.n	2982e <nrf_sdh_soc_evts_poll+0x6>
            nrf_sdh_soc_evt_handler_t    handler;

            p_observer = (nrf_sdh_soc_evt_observer_t *) nrf_section_iter_get(&iter);
            handler    = p_observer->handler;

            handler(evt_id, p_observer->p_context);
   29844:	e9d3 2100 	ldrd	r2, r1, [r3]
   29848:	9801      	ldr	r0, [sp, #4]
   2984a:	4790      	blx	r2
             nrf_section_iter_next(&iter))
   2984c:	a802      	add	r0, sp, #8
   2984e:	f7fe fa21 	bl	27c94 <nrf_section_iter_next>
             nrf_section_iter_get(&iter) != NULL;
   29852:	9b03      	ldr	r3, [sp, #12]
        for (nrf_section_iter_init(&iter, &sdh_soc_observers);
   29854:	2b00      	cmp	r3, #0
   29856:	d1f5      	bne.n	29844 <nrf_sdh_soc_evts_poll+0x1c>
        ret_code = sd_evt_get(&evt_id);
   29858:	a801      	add	r0, sp, #4
   2985a:	f7ff ffe3 	bl	29824 <sd_evt_get>
        if (ret_code != NRF_SUCCESS)
   2985e:	2800      	cmp	r0, #0
   29860:	d0e9      	beq.n	29836 <nrf_sdh_soc_evts_poll+0xe>
        }
    }

    if (ret_code != NRF_ERROR_NOT_FOUND)
   29862:	2805      	cmp	r0, #5
   29864:	d001      	beq.n	2986a <nrf_sdh_soc_evts_poll+0x42>
    {
        APP_ERROR_HANDLER(ret_code);
   29866:	f7fd fd47 	bl	272f8 <app_error_handler_bare>
    }
}
   2986a:	b004      	add	sp, #16
   2986c:	bd10      	pop	{r4, pc}
   2986e:	bf00      	nop
   29870:	0002bd5c 	.word	0x0002bd5c

00029874 <sd_ble_gap_conn_param_update>:
SVCALL(SD_BLE_GAP_CONN_PARAM_UPDATE, uint32_t, sd_ble_gap_conn_param_update(uint16_t conn_handle, ble_gap_conn_params_t const *p_conn_params));
   29874:	df75      	svc	117	; 0x75
   29876:	4770      	bx	lr

00029878 <sd_ble_gap_disconnect>:
SVCALL(SD_BLE_GAP_DISCONNECT, uint32_t, sd_ble_gap_disconnect(uint16_t conn_handle, uint8_t hci_status_code));
   29878:	df76      	svc	118	; 0x76
   2987a:	4770      	bx	lr

0002987c <sd_ble_gap_ppcp_set>:
SVCALL(SD_BLE_GAP_PPCP_SET, uint32_t, sd_ble_gap_ppcp_set(ble_gap_conn_params_t const *p_conn_params));
   2987c:	df7a      	svc	122	; 0x7a
   2987e:	4770      	bx	lr

00029880 <sd_ble_gap_ppcp_get>:
SVCALL(SD_BLE_GAP_PPCP_GET, uint32_t, sd_ble_gap_ppcp_get(ble_gap_conn_params_t *p_conn_params));
   29880:	df7b      	svc	123	; 0x7b
   29882:	4770      	bx	lr

00029884 <update_timeout_handler>:
/**@brief Function called after conn_params_update_delay has happened. This is triggered by app_timer.
 *
 * @param[in]  p_context  Context identifying which connection this is for.
 */
static void update_timeout_handler(void * p_context)
{
   29884:	b570      	push	{r4, r5, r6, lr}
        if (m_conn_params_instances[i].conn_handle == conn_handle)
   29886:	4d1b      	ldr	r5, [pc, #108]	; (298f4 <update_timeout_handler+0x70>)
   29888:	882b      	ldrh	r3, [r5, #0]
    uint32_t                     conn_handle = (uint32_t)p_context;
    ble_conn_params_instance_t * p_instance  = instance_get(conn_handle);
   2988a:	b284      	uxth	r4, r0
        if (m_conn_params_instances[i].conn_handle == conn_handle)
   2988c:	42a3      	cmp	r3, r4
{
   2988e:	b082      	sub	sp, #8
        if (m_conn_params_instances[i].conn_handle == conn_handle)
   29890:	d111      	bne.n	298b6 <update_timeout_handler+0x32>

    if (p_instance != NULL)
    {
        // Check if we have reached the maximum number of attempts
        if (p_instance->update_count < m_conn_params_config.max_conn_params_update_count)
   29892:	4e19      	ldr	r6, [pc, #100]	; (298f8 <update_timeout_handler+0x74>)
   29894:	7a29      	ldrb	r1, [r5, #8]
   29896:	7b32      	ldrb	r2, [r6, #12]
   29898:	4291      	cmp	r1, r2
   2989a:	d30e      	bcc.n	298ba <update_timeout_handler+0x36>
        else
        {
            p_instance->update_count = 0;

            // Negotiation failed, disconnect automatically if this has been configured
            if (m_conn_params_config.disconnect_on_fail)
   2989c:	7c33      	ldrb	r3, [r6, #16]
            p_instance->update_count = 0;
   2989e:	2200      	movs	r2, #0
   298a0:	722a      	strb	r2, [r5, #8]
            if (m_conn_params_config.disconnect_on_fail)
   298a2:	b9db      	cbnz	r3, 298dc <update_timeout_handler+0x58>
                    send_error_evt(err_code);
                }
            }

            // Notify the application that the procedure has failed
            if (m_conn_params_config.evt_handler != NULL)
   298a4:	6973      	ldr	r3, [r6, #20]
   298a6:	b133      	cbz	r3, 298b6 <update_timeout_handler+0x32>
            {
                ble_conn_params_evt_t evt;

                evt.evt_type = BLE_CONN_PARAMS_EVT_FAILED;
   298a8:	2200      	movs	r2, #0
                evt.conn_handle = conn_handle;
   298aa:	f8ad 4006 	strh.w	r4, [sp, #6]
                evt.evt_type = BLE_CONN_PARAMS_EVT_FAILED;
   298ae:	f88d 2004 	strb.w	r2, [sp, #4]
                m_conn_params_config.evt_handler(&evt);
   298b2:	a801      	add	r0, sp, #4
   298b4:	4798      	blx	r3
            }
        }
    }
}
   298b6:	b002      	add	sp, #8
   298b8:	bd70      	pop	{r4, r5, r6, pc}
    err_code = sd_ble_gap_conn_param_update(conn_handle, p_new_conn_params);
   298ba:	4618      	mov	r0, r3
   298bc:	f105 010a 	add.w	r1, r5, #10
   298c0:	f7ff ffd8 	bl	29874 <sd_ble_gap_conn_param_update>
    if ((err_code != NRF_SUCCESS) && (err_code != NRF_ERROR_BUSY)) // NRF_ERROR_BUSY means another conn_param_update request is pending.
   298c4:	b128      	cbz	r0, 298d2 <update_timeout_handler+0x4e>
   298c6:	2811      	cmp	r0, #17
   298c8:	d0f5      	beq.n	298b6 <update_timeout_handler+0x32>
    if (m_conn_params_config.error_handler != NULL)
   298ca:	69b3      	ldr	r3, [r6, #24]
   298cc:	2b00      	cmp	r3, #0
   298ce:	d1f1      	bne.n	298b4 <update_timeout_handler+0x30>
   298d0:	e7f1      	b.n	298b6 <update_timeout_handler+0x32>
                p_instance->update_count++;
   298d2:	7a2b      	ldrb	r3, [r5, #8]
   298d4:	3301      	adds	r3, #1
   298d6:	722b      	strb	r3, [r5, #8]
}
   298d8:	b002      	add	sp, #8
   298da:	bd70      	pop	{r4, r5, r6, pc}
                err_code = sd_ble_gap_disconnect(conn_handle, BLE_HCI_CONN_INTERVAL_UNACCEPTABLE);
   298dc:	213b      	movs	r1, #59	; 0x3b
   298de:	4620      	mov	r0, r4
   298e0:	f7ff ffca 	bl	29878 <sd_ble_gap_disconnect>
                if ((err_code != NRF_SUCCESS) && (err_code != NRF_ERROR_INVALID_STATE)) // NRF_ERROR_INVALID_STATE means disconnect is already in progress.
   298e4:	f030 0308 	bics.w	r3, r0, #8
   298e8:	d0dc      	beq.n	298a4 <update_timeout_handler+0x20>
    if (m_conn_params_config.error_handler != NULL)
   298ea:	69b3      	ldr	r3, [r6, #24]
   298ec:	2b00      	cmp	r3, #0
   298ee:	d0d9      	beq.n	298a4 <update_timeout_handler+0x20>
        m_conn_params_config.error_handler(err_code);
   298f0:	4798      	blx	r3
   298f2:	e7d7      	b.n	298a4 <update_timeout_handler+0x20>
   298f4:	200022e4 	.word	0x200022e4
   298f8:	200022c8 	.word	0x200022c8

000298fc <ble_evt_handler>:
 *
 * @param[in]   p_ble_evt       Event received from the BLE stack.
 * @param[in]   p_context       Context.
 */
static void ble_evt_handler(ble_evt_t const * p_ble_evt, void * p_context)
{
   298fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    switch (p_ble_evt->header.evt_id)
   298fe:	8802      	ldrh	r2, [r0, #0]
   29900:	2a12      	cmp	r2, #18
{
   29902:	b083      	sub	sp, #12
   29904:	4603      	mov	r3, r0
    switch (p_ble_evt->header.evt_id)
   29906:	d03e      	beq.n	29986 <ble_evt_handler+0x8a>
   29908:	d815      	bhi.n	29936 <ble_evt_handler+0x3a>
   2990a:	2a10      	cmp	r2, #16
   2990c:	d073      	beq.n	299f6 <ble_evt_handler+0xfa>
   2990e:	2a11      	cmp	r2, #17
   29910:	d10f      	bne.n	29932 <ble_evt_handler+0x36>
        if (m_conn_params_instances[i].conn_handle == conn_handle)
   29912:	4c6c      	ldr	r4, [pc, #432]	; (29ac4 <ble_evt_handler+0x1c8>)
   29914:	8882      	ldrh	r2, [r0, #4]
   29916:	8823      	ldrh	r3, [r4, #0]
   29918:	429a      	cmp	r2, r3
   2991a:	d10a      	bne.n	29932 <ble_evt_handler+0x36>
        err_code = app_timer_stop(p_instance->timer_id);
   2991c:	6860      	ldr	r0, [r4, #4]
   2991e:	f7fd ff37 	bl	27790 <app_timer_stop>
        if (err_code != NRF_SUCCESS)
   29922:	b118      	cbz	r0, 2992c <ble_evt_handler+0x30>
    if (m_conn_params_config.error_handler != NULL)
   29924:	4b68      	ldr	r3, [pc, #416]	; (29ac8 <ble_evt_handler+0x1cc>)
   29926:	699b      	ldr	r3, [r3, #24]
   29928:	b103      	cbz	r3, 2992c <ble_evt_handler+0x30>
        m_conn_params_config.error_handler(err_code);
   2992a:	4798      	blx	r3
    p_instance->conn_handle = BLE_CONN_HANDLE_INVALID;
   2992c:	f64f 73ff 	movw	r3, #65535	; 0xffff
   29930:	8023      	strh	r3, [r4, #0]

        default:
            // No implementation needed.
            break;
    }
}
   29932:	b003      	add	sp, #12
   29934:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch (p_ble_evt->header.evt_id)
   29936:	2a50      	cmp	r2, #80	; 0x50
   29938:	d1fb      	bne.n	29932 <ble_evt_handler+0x36>
        (p_evt_write->handle == m_conn_params_config.start_on_notify_cccd_handle)
   2993a:	4d63      	ldr	r5, [pc, #396]	; (29ac8 <ble_evt_handler+0x1cc>)
    if (
   2993c:	88c1      	ldrh	r1, [r0, #6]
   2993e:	89ea      	ldrh	r2, [r5, #14]
   29940:	4291      	cmp	r1, r2
   29942:	d1f6      	bne.n	29932 <ble_evt_handler+0x36>
        &&
   29944:	8a02      	ldrh	r2, [r0, #16]
   29946:	2a02      	cmp	r2, #2
   29948:	d1f3      	bne.n	29932 <ble_evt_handler+0x36>
        if (m_conn_params_instances[i].conn_handle == conn_handle)
   2994a:	4c5e      	ldr	r4, [pc, #376]	; (29ac4 <ble_evt_handler+0x1c8>)
        uint16_t                     conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
   2994c:	8882      	ldrh	r2, [r0, #4]
        if (m_conn_params_instances[i].conn_handle == conn_handle)
   2994e:	8826      	ldrh	r6, [r4, #0]
   29950:	4296      	cmp	r6, r2
   29952:	d1ee      	bne.n	29932 <ble_evt_handler+0x36>
            if (ble_srv_is_notification_enabled(p_evt_write->data))
   29954:	3012      	adds	r0, #18
   29956:	f7ff fe21 	bl	2959c <ble_srv_is_notification_enabled>
   2995a:	2800      	cmp	r0, #0
   2995c:	f000 809c 	beq.w	29a98 <ble_evt_handler+0x19c>
    if (!p_instance->params_ok)
   29960:	7a63      	ldrb	r3, [r4, #9]
   29962:	2b00      	cmp	r3, #0
   29964:	f040 809f 	bne.w	29aa6 <ble_evt_handler+0x1aa>
                timeout_ticks = m_conn_params_config.next_conn_params_update_delay;
   29968:	e9d5 1301 	ldrd	r1, r3, [r5, #4]
        if (p_instance->update_count == 0)
   2996c:	7a27      	ldrb	r7, [r4, #8]
        err_code = app_timer_start(p_instance->timer_id, timeout_ticks, (void *)(uint32_t)conn_handle);
   2996e:	6860      	ldr	r0, [r4, #4]
   29970:	4632      	mov	r2, r6
   29972:	2f00      	cmp	r7, #0
   29974:	bf18      	it	ne
   29976:	4619      	movne	r1, r3
   29978:	f7fd fec4 	bl	27704 <app_timer_start>
        if (err_code != NRF_SUCCESS)
   2997c:	2800      	cmp	r0, #0
   2997e:	d0d8      	beq.n	29932 <ble_evt_handler+0x36>
    if (m_conn_params_config.error_handler != NULL)
   29980:	69ab      	ldr	r3, [r5, #24]
   29982:	bb3b      	cbnz	r3, 299d4 <ble_evt_handler+0xd8>
   29984:	e7d5      	b.n	29932 <ble_evt_handler+0x36>
        if (m_conn_params_instances[i].conn_handle == conn_handle)
   29986:	4c4f      	ldr	r4, [pc, #316]	; (29ac4 <ble_evt_handler+0x1c8>)
    uint16_t                     conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
   29988:	8882      	ldrh	r2, [r0, #4]
        if (m_conn_params_instances[i].conn_handle == conn_handle)
   2998a:	8821      	ldrh	r1, [r4, #0]
   2998c:	4291      	cmp	r1, r2
   2998e:	d1d0      	bne.n	29932 <ble_evt_handler+0x36>
    if   ((p_actual_conn_params->max_conn_interval < p_preferred_conn_params->min_conn_interval)
   29990:	8940      	ldrh	r0, [r0, #10]
   29992:	8965      	ldrh	r5, [r4, #10]
   29994:	4285      	cmp	r5, r0
   29996:	d81f      	bhi.n	299d8 <ble_evt_handler+0xdc>
       || (p_actual_conn_params->max_conn_interval > p_preferred_conn_params->max_conn_interval))
   29998:	89a5      	ldrh	r5, [r4, #12]
   2999a:	4285      	cmp	r5, r0
   2999c:	d31c      	bcc.n	299d8 <ble_evt_handler+0xdc>
    uint32_t max_allowed_sl = p_preferred_conn_params->slave_latency + max_slave_latency_err;
   2999e:	89e0      	ldrh	r0, [r4, #14]
    if   ((p_actual_conn_params->slave_latency < min_allowed_sl)
   299a0:	899d      	ldrh	r5, [r3, #12]
                              - MIN(max_slave_latency_err, p_preferred_conn_params->slave_latency);
   299a2:	f240 13f3 	movw	r3, #499	; 0x1f3
   299a6:	4298      	cmp	r0, r3
   299a8:	bf94      	ite	ls
   299aa:	1a03      	subls	r3, r0, r0
   299ac:	1ac3      	subhi	r3, r0, r3
    if   ((p_actual_conn_params->slave_latency < min_allowed_sl)
   299ae:	42ab      	cmp	r3, r5
   299b0:	d812      	bhi.n	299d8 <ble_evt_handler+0xdc>
    uint32_t max_allowed_sl = p_preferred_conn_params->slave_latency + max_slave_latency_err;
   299b2:	f200 10f3 	addw	r0, r0, #499	; 0x1f3
       || (p_actual_conn_params->slave_latency > max_allowed_sl))
   299b6:	42a8      	cmp	r0, r5
   299b8:	d30e      	bcc.n	299d8 <ble_evt_handler+0xdc>
        if (m_conn_params_config.evt_handler != NULL)
   299ba:	4b43      	ldr	r3, [pc, #268]	; (29ac8 <ble_evt_handler+0x1cc>)
   299bc:	695b      	ldr	r3, [r3, #20]
        p_instance->update_count = 0;
   299be:	f44f 7280 	mov.w	r2, #256	; 0x100
   299c2:	8122      	strh	r2, [r4, #8]
        if (m_conn_params_config.evt_handler != NULL)
   299c4:	2b00      	cmp	r3, #0
   299c6:	d0b4      	beq.n	29932 <ble_evt_handler+0x36>
            evt.evt_type = BLE_CONN_PARAMS_EVT_SUCCEEDED;
   299c8:	2201      	movs	r2, #1
            evt.conn_handle = conn_handle;
   299ca:	f8ad 1006 	strh.w	r1, [sp, #6]
            evt.evt_type = BLE_CONN_PARAMS_EVT_SUCCEEDED;
   299ce:	f88d 2004 	strb.w	r2, [sp, #4]
            m_conn_params_config.evt_handler(&evt);
   299d2:	a801      	add	r0, sp, #4
   299d4:	4798      	blx	r3
}
   299d6:	e7ac      	b.n	29932 <ble_evt_handler+0x36>
                timeout_ticks = m_conn_params_config.first_conn_params_update_delay;
   299d8:	4d3b      	ldr	r5, [pc, #236]	; (29ac8 <ble_evt_handler+0x1cc>)
        if (p_instance->update_count == 0)
   299da:	7a26      	ldrb	r6, [r4, #8]
        err_code = app_timer_start(p_instance->timer_id, timeout_ticks, (void *)(uint32_t)conn_handle);
   299dc:	6860      	ldr	r0, [r4, #4]
                timeout_ticks = m_conn_params_config.next_conn_params_update_delay;
   299de:	e9d5 1301 	ldrd	r1, r3, [r5, #4]
        err_code = app_timer_start(p_instance->timer_id, timeout_ticks, (void *)(uint32_t)conn_handle);
   299e2:	2e00      	cmp	r6, #0
   299e4:	bf18      	it	ne
   299e6:	4619      	movne	r1, r3
        p_instance->params_ok = is_conn_params_ok(
   299e8:	2300      	movs	r3, #0
   299ea:	7263      	strb	r3, [r4, #9]
        err_code = app_timer_start(p_instance->timer_id, timeout_ticks, (void *)(uint32_t)conn_handle);
   299ec:	f7fd fe8a 	bl	27704 <app_timer_start>
        if (err_code != NRF_SUCCESS)
   299f0:	2800      	cmp	r0, #0
   299f2:	d1c5      	bne.n	29980 <ble_evt_handler+0x84>
   299f4:	e79d      	b.n	29932 <ble_evt_handler+0x36>
    if (role != BLE_GAP_ROLE_PERIPH)
   299f6:	7bc6      	ldrb	r6, [r0, #15]
   299f8:	2e01      	cmp	r6, #1
   299fa:	d19a      	bne.n	29932 <ble_evt_handler+0x36>
        if (m_conn_params_instances[i].conn_handle == conn_handle)
   299fc:	4c31      	ldr	r4, [pc, #196]	; (29ac4 <ble_evt_handler+0x1c8>)
   299fe:	8821      	ldrh	r1, [r4, #0]
   29a00:	f64f 72ff 	movw	r2, #65535	; 0xffff
   29a04:	4291      	cmp	r1, r2
   29a06:	d13f      	bne.n	29a88 <ble_evt_handler+0x18c>
    p_instance->preferred_conn_params = m_preferred_conn_params;
   29a08:	4d30      	ldr	r5, [pc, #192]	; (29acc <ble_evt_handler+0x1d0>)
    uint16_t conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
   29a0a:	8882      	ldrh	r2, [r0, #4]
    p_instance->conn_handle           = conn_handle;
   29a0c:	8022      	strh	r2, [r4, #0]
    p_instance->preferred_conn_params = m_preferred_conn_params;
   29a0e:	cd03      	ldmia	r5!, {r0, r1}
   29a10:	f8c4 000a 	str.w	r0, [r4, #10]
   29a14:	f8c4 100e 	str.w	r1, [r4, #14]
    if   ((p_actual_conn_params->max_conn_interval < p_preferred_conn_params->min_conn_interval)
   29a18:	8a59      	ldrh	r1, [r3, #18]
   29a1a:	8960      	ldrh	r0, [r4, #10]
    p_instance->update_count          = 0;
   29a1c:	2500      	movs	r5, #0
    if   ((p_actual_conn_params->max_conn_interval < p_preferred_conn_params->min_conn_interval)
   29a1e:	4288      	cmp	r0, r1
    p_instance->update_count          = 0;
   29a20:	7225      	strb	r5, [r4, #8]
    if   ((p_actual_conn_params->max_conn_interval < p_preferred_conn_params->min_conn_interval)
   29a22:	d822      	bhi.n	29a6a <ble_evt_handler+0x16e>
       || (p_actual_conn_params->max_conn_interval > p_preferred_conn_params->max_conn_interval))
   29a24:	89a0      	ldrh	r0, [r4, #12]
   29a26:	4288      	cmp	r0, r1
   29a28:	d31f      	bcc.n	29a6a <ble_evt_handler+0x16e>
    uint32_t max_allowed_sl = p_preferred_conn_params->slave_latency + max_slave_latency_err;
   29a2a:	89e1      	ldrh	r1, [r4, #14]
    if   ((p_actual_conn_params->slave_latency < min_allowed_sl)
   29a2c:	8a98      	ldrh	r0, [r3, #20]
                              - MIN(max_slave_latency_err, p_preferred_conn_params->slave_latency);
   29a2e:	f240 13f3 	movw	r3, #499	; 0x1f3
   29a32:	4299      	cmp	r1, r3
   29a34:	bf94      	ite	ls
   29a36:	1a4b      	subls	r3, r1, r1
   29a38:	1acb      	subhi	r3, r1, r3
    if   ((p_actual_conn_params->slave_latency < min_allowed_sl)
   29a3a:	4283      	cmp	r3, r0
   29a3c:	d815      	bhi.n	29a6a <ble_evt_handler+0x16e>
    uint32_t max_allowed_sl = p_preferred_conn_params->slave_latency + max_slave_latency_err;
   29a3e:	f201 11f3 	addw	r1, r1, #499	; 0x1f3
       || (p_actual_conn_params->slave_latency > max_allowed_sl))
   29a42:	4281      	cmp	r1, r0
   29a44:	d311      	bcc.n	29a6a <ble_evt_handler+0x16e>
    if (m_conn_params_config.start_on_notify_cccd_handle == BLE_GATT_HANDLE_INVALID)
   29a46:	4d20      	ldr	r5, [pc, #128]	; (29ac8 <ble_evt_handler+0x1cc>)
    p_instance->params_ok = is_conn_params_ok(&p_instance->preferred_conn_params,
   29a48:	7266      	strb	r6, [r4, #9]
    if (m_conn_params_config.start_on_notify_cccd_handle == BLE_GATT_HANDLE_INVALID)
   29a4a:	89eb      	ldrh	r3, [r5, #14]
   29a4c:	2b00      	cmp	r3, #0
   29a4e:	f47f af70 	bne.w	29932 <ble_evt_handler+0x36>
        if (m_conn_params_config.evt_handler != NULL)
   29a52:	696b      	ldr	r3, [r5, #20]
   29a54:	2b00      	cmp	r3, #0
   29a56:	f43f af6c 	beq.w	29932 <ble_evt_handler+0x36>
            evt.evt_type = BLE_CONN_PARAMS_EVT_SUCCEEDED;
   29a5a:	2101      	movs	r1, #1
            evt.conn_handle = conn_handle;
   29a5c:	f8ad 2006 	strh.w	r2, [sp, #6]
            evt.evt_type = BLE_CONN_PARAMS_EVT_SUCCEEDED;
   29a60:	f88d 1004 	strb.w	r1, [sp, #4]
            m_conn_params_config.evt_handler(&evt);
   29a64:	a801      	add	r0, sp, #4
   29a66:	4798      	blx	r3
   29a68:	e763      	b.n	29932 <ble_evt_handler+0x36>
    if (m_conn_params_config.start_on_notify_cccd_handle == BLE_GATT_HANDLE_INVALID)
   29a6a:	4d17      	ldr	r5, [pc, #92]	; (29ac8 <ble_evt_handler+0x1cc>)
   29a6c:	89eb      	ldrh	r3, [r5, #14]
    p_instance->params_ok = is_conn_params_ok(&p_instance->preferred_conn_params,
   29a6e:	2100      	movs	r1, #0
   29a70:	7261      	strb	r1, [r4, #9]
    if (m_conn_params_config.start_on_notify_cccd_handle == BLE_GATT_HANDLE_INVALID)
   29a72:	2b00      	cmp	r3, #0
   29a74:	f47f af5d 	bne.w	29932 <ble_evt_handler+0x36>
        err_code = app_timer_start(p_instance->timer_id, timeout_ticks, (void *)(uint32_t)conn_handle);
   29a78:	6860      	ldr	r0, [r4, #4]
   29a7a:	6869      	ldr	r1, [r5, #4]
   29a7c:	f7fd fe42 	bl	27704 <app_timer_start>
        if (err_code != NRF_SUCCESS)
   29a80:	2800      	cmp	r0, #0
   29a82:	f43f af56 	beq.w	29932 <ble_evt_handler+0x36>
   29a86:	e77b      	b.n	29980 <ble_evt_handler+0x84>
    if (m_conn_params_config.error_handler != NULL)
   29a88:	4b0f      	ldr	r3, [pc, #60]	; (29ac8 <ble_evt_handler+0x1cc>)
   29a8a:	699b      	ldr	r3, [r3, #24]
   29a8c:	2b00      	cmp	r3, #0
   29a8e:	f43f af50 	beq.w	29932 <ble_evt_handler+0x36>
        m_conn_params_config.error_handler(err_code);
   29a92:	2004      	movs	r0, #4
   29a94:	4798      	blx	r3
   29a96:	e74c      	b.n	29932 <ble_evt_handler+0x36>
                err_code = app_timer_stop(p_instance->timer_id);
   29a98:	6860      	ldr	r0, [r4, #4]
   29a9a:	f7fd fe79 	bl	27790 <app_timer_stop>
                if (err_code != NRF_SUCCESS)
   29a9e:	2800      	cmp	r0, #0
   29aa0:	f43f af47 	beq.w	29932 <ble_evt_handler+0x36>
   29aa4:	e76c      	b.n	29980 <ble_evt_handler+0x84>
        if (m_conn_params_config.evt_handler != NULL)
   29aa6:	696b      	ldr	r3, [r5, #20]
        p_instance->update_count = 0;
   29aa8:	2200      	movs	r2, #0
   29aaa:	7222      	strb	r2, [r4, #8]
        if (m_conn_params_config.evt_handler != NULL)
   29aac:	2b00      	cmp	r3, #0
   29aae:	f43f af40 	beq.w	29932 <ble_evt_handler+0x36>
            evt.evt_type = BLE_CONN_PARAMS_EVT_SUCCEEDED;
   29ab2:	2201      	movs	r2, #1
            evt.conn_handle = conn_handle;
   29ab4:	f8ad 6006 	strh.w	r6, [sp, #6]
            evt.evt_type = BLE_CONN_PARAMS_EVT_SUCCEEDED;
   29ab8:	f88d 2004 	strb.w	r2, [sp, #4]
            m_conn_params_config.evt_handler(&evt);
   29abc:	a801      	add	r0, sp, #4
   29abe:	4798      	blx	r3
   29ac0:	e737      	b.n	29932 <ble_evt_handler+0x36>
   29ac2:	bf00      	nop
   29ac4:	200022e4 	.word	0x200022e4
   29ac8:	200022c8 	.word	0x200022c8
   29acc:	200022f8 	.word	0x200022f8

00029ad0 <ble_conn_params_init>:
    VERIFY_PARAM_NOT_NULL(p_init);
   29ad0:	b370      	cbz	r0, 29b30 <ble_conn_params_init+0x60>
{
   29ad2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    m_conn_params_config = *p_init;
   29ad4:	4605      	mov	r5, r0
   29ad6:	4606      	mov	r6, r0
   29ad8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   29ada:	4f16      	ldr	r7, [pc, #88]	; (29b34 <ble_conn_params_init+0x64>)
   29adc:	463c      	mov	r4, r7
   29ade:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    if (p_init->p_conn_params != NULL)
   29ae0:	4684      	mov	ip, r0
    m_conn_params_config = *p_init;
   29ae2:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
    m_conn_params_config.p_conn_params = &m_preferred_conn_params;
   29ae6:	4d14      	ldr	r5, [pc, #80]	; (29b38 <ble_conn_params_init+0x68>)
   29ae8:	603d      	str	r5, [r7, #0]
    m_conn_params_config = *p_init;
   29aea:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    if (p_init->p_conn_params != NULL)
   29aee:	f1bc 0f00 	cmp.w	ip, #0
   29af2:	d017      	beq.n	29b24 <ble_conn_params_init+0x54>
        err_code = sd_ble_gap_ppcp_set(p_init->p_conn_params);
   29af4:	4660      	mov	r0, ip
   29af6:	f7ff fec1 	bl	2987c <sd_ble_gap_ppcp_set>
        if (err_code != NRF_SUCCESS)
   29afa:	b990      	cbnz	r0, 29b22 <ble_conn_params_init+0x52>
        m_preferred_conn_params = *p_init->p_conn_params;
   29afc:	6833      	ldr	r3, [r6, #0]
   29afe:	6818      	ldr	r0, [r3, #0]
   29b00:	6859      	ldr	r1, [r3, #4]
   29b02:	c503      	stmia	r5!, {r0, r1}
    p_instance->conn_handle = BLE_CONN_HANDLE_INVALID;
   29b04:	4b0d      	ldr	r3, [pc, #52]	; (29b3c <ble_conn_params_init+0x6c>)
        p_instance->timer_id = &m_timer_data[i];
   29b06:	490e      	ldr	r1, [pc, #56]	; (29b40 <ble_conn_params_init+0x70>)
        err_code = app_timer_create(&p_instance->timer_id,
   29b08:	4a0e      	ldr	r2, [pc, #56]	; (29b44 <ble_conn_params_init+0x74>)
        p_instance->timer_id = &m_timer_data[i];
   29b0a:	4618      	mov	r0, r3
    p_instance->conn_handle = BLE_CONN_HANDLE_INVALID;
   29b0c:	f64f 74ff 	movw	r4, #65535	; 0xffff
        p_instance->timer_id = &m_timer_data[i];
   29b10:	f840 1f04 	str.w	r1, [r0, #4]!
    p_instance->conn_handle = BLE_CONN_HANDLE_INVALID;
   29b14:	801c      	strh	r4, [r3, #0]
        err_code = app_timer_create(&p_instance->timer_id,
   29b16:	2100      	movs	r1, #0
   29b18:	f7fd fde6 	bl	276e8 <app_timer_create>
            return NRF_ERROR_INTERNAL;
   29b1c:	2800      	cmp	r0, #0
   29b1e:	bf18      	it	ne
   29b20:	2003      	movne	r0, #3
}
   29b22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        err_code = sd_ble_gap_ppcp_get(&m_preferred_conn_params);
   29b24:	4628      	mov	r0, r5
   29b26:	f7ff feab 	bl	29880 <sd_ble_gap_ppcp_get>
        if (err_code != NRF_SUCCESS)
   29b2a:	2800      	cmp	r0, #0
   29b2c:	d0ea      	beq.n	29b04 <ble_conn_params_init+0x34>
}
   29b2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    VERIFY_PARAM_NOT_NULL(p_init);
   29b30:	200e      	movs	r0, #14
}
   29b32:	4770      	bx	lr
   29b34:	200022c8 	.word	0x200022c8
   29b38:	200022f8 	.word	0x200022f8
   29b3c:	200022e4 	.word	0x200022e4
   29b40:	20002300 	.word	0x20002300
   29b44:	00029885 	.word	0x00029885

00029b48 <ble_conn_params_stop>:
{
   29b48:	b508      	push	{r3, lr}
        err_code = app_timer_stop(m_conn_params_instances[i].timer_id);
   29b4a:	4b06      	ldr	r3, [pc, #24]	; (29b64 <ble_conn_params_stop+0x1c>)
   29b4c:	6858      	ldr	r0, [r3, #4]
   29b4e:	f7fd fe1f 	bl	27790 <app_timer_stop>
        switch (err_code)
   29b52:	2804      	cmp	r0, #4
   29b54:	d004      	beq.n	29b60 <ble_conn_params_stop+0x18>
   29b56:	f030 0008 	bics.w	r0, r0, #8
   29b5a:	bf18      	it	ne
   29b5c:	2003      	movne	r0, #3
}
   29b5e:	bd08      	pop	{r3, pc}
                return NRF_ERROR_BUSY;
   29b60:	2011      	movs	r0, #17
}
   29b62:	bd08      	pop	{r3, pc}
   29b64:	200022e4 	.word	0x200022e4

00029b68 <exit>:
   29b68:	b508      	push	{r3, lr}
   29b6a:	4b07      	ldr	r3, [pc, #28]	; (29b88 <exit+0x20>)
   29b6c:	4604      	mov	r4, r0
   29b6e:	b113      	cbz	r3, 29b76 <exit+0xe>
   29b70:	2100      	movs	r1, #0
   29b72:	f3af 8000 	nop.w
   29b76:	4b05      	ldr	r3, [pc, #20]	; (29b8c <exit+0x24>)
   29b78:	6818      	ldr	r0, [r3, #0]
   29b7a:	6a83      	ldr	r3, [r0, #40]	; 0x28
   29b7c:	b103      	cbz	r3, 29b80 <exit+0x18>
   29b7e:	4798      	blx	r3
   29b80:	4620      	mov	r0, r4
   29b82:	f000 fcdb 	bl	2a53c <_exit>
   29b86:	bf00      	nop
   29b88:	00000000 	.word	0x00000000
   29b8c:	0002bd68 	.word	0x0002bd68

00029b90 <__libc_init_array>:
   29b90:	b570      	push	{r4, r5, r6, lr}
   29b92:	4d0d      	ldr	r5, [pc, #52]	; (29bc8 <__libc_init_array+0x38>)
   29b94:	4c0d      	ldr	r4, [pc, #52]	; (29bcc <__libc_init_array+0x3c>)
   29b96:	1b64      	subs	r4, r4, r5
   29b98:	10a4      	asrs	r4, r4, #2
   29b9a:	2600      	movs	r6, #0
   29b9c:	42a6      	cmp	r6, r4
   29b9e:	d109      	bne.n	29bb4 <__libc_init_array+0x24>
   29ba0:	4d0b      	ldr	r5, [pc, #44]	; (29bd0 <__libc_init_array+0x40>)
   29ba2:	4c0c      	ldr	r4, [pc, #48]	; (29bd4 <__libc_init_array+0x44>)
   29ba4:	f002 f888 	bl	2bcb8 <_init>
   29ba8:	1b64      	subs	r4, r4, r5
   29baa:	10a4      	asrs	r4, r4, #2
   29bac:	2600      	movs	r6, #0
   29bae:	42a6      	cmp	r6, r4
   29bb0:	d105      	bne.n	29bbe <__libc_init_array+0x2e>
   29bb2:	bd70      	pop	{r4, r5, r6, pc}
   29bb4:	f855 3b04 	ldr.w	r3, [r5], #4
   29bb8:	4798      	blx	r3
   29bba:	3601      	adds	r6, #1
   29bbc:	e7ee      	b.n	29b9c <__libc_init_array+0xc>
   29bbe:	f855 3b04 	ldr.w	r3, [r5], #4
   29bc2:	4798      	blx	r3
   29bc4:	3601      	adds	r6, #1
   29bc6:	e7f2      	b.n	29bae <__libc_init_array+0x1e>
   29bc8:	2000209c 	.word	0x2000209c
   29bcc:	2000209c 	.word	0x2000209c
   29bd0:	2000209c 	.word	0x2000209c
   29bd4:	200020a4 	.word	0x200020a4

00029bd8 <memcpy>:
   29bd8:	440a      	add	r2, r1
   29bda:	4291      	cmp	r1, r2
   29bdc:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   29be0:	d100      	bne.n	29be4 <memcpy+0xc>
   29be2:	4770      	bx	lr
   29be4:	b510      	push	{r4, lr}
   29be6:	f811 4b01 	ldrb.w	r4, [r1], #1
   29bea:	f803 4f01 	strb.w	r4, [r3, #1]!
   29bee:	4291      	cmp	r1, r2
   29bf0:	d1f9      	bne.n	29be6 <memcpy+0xe>
   29bf2:	bd10      	pop	{r4, pc}

00029bf4 <memset>:
   29bf4:	4402      	add	r2, r0
   29bf6:	4603      	mov	r3, r0
   29bf8:	4293      	cmp	r3, r2
   29bfa:	d100      	bne.n	29bfe <memset+0xa>
   29bfc:	4770      	bx	lr
   29bfe:	f803 1b01 	strb.w	r1, [r3], #1
   29c02:	e7f9      	b.n	29bf8 <memset+0x4>

00029c04 <sniprintf>:
   29c04:	b40c      	push	{r2, r3}
   29c06:	b530      	push	{r4, r5, lr}
   29c08:	4b17      	ldr	r3, [pc, #92]	; (29c68 <sniprintf+0x64>)
   29c0a:	1e0c      	subs	r4, r1, #0
   29c0c:	681d      	ldr	r5, [r3, #0]
   29c0e:	b09d      	sub	sp, #116	; 0x74
   29c10:	da08      	bge.n	29c24 <sniprintf+0x20>
   29c12:	238b      	movs	r3, #139	; 0x8b
   29c14:	602b      	str	r3, [r5, #0]
   29c16:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29c1a:	b01d      	add	sp, #116	; 0x74
   29c1c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   29c20:	b002      	add	sp, #8
   29c22:	4770      	bx	lr
   29c24:	f44f 7302 	mov.w	r3, #520	; 0x208
   29c28:	f8ad 3014 	strh.w	r3, [sp, #20]
   29c2c:	bf14      	ite	ne
   29c2e:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
   29c32:	4623      	moveq	r3, r4
   29c34:	9304      	str	r3, [sp, #16]
   29c36:	9307      	str	r3, [sp, #28]
   29c38:	f64f 73ff 	movw	r3, #65535	; 0xffff
   29c3c:	9002      	str	r0, [sp, #8]
   29c3e:	9006      	str	r0, [sp, #24]
   29c40:	f8ad 3016 	strh.w	r3, [sp, #22]
   29c44:	9a20      	ldr	r2, [sp, #128]	; 0x80
   29c46:	ab21      	add	r3, sp, #132	; 0x84
   29c48:	a902      	add	r1, sp, #8
   29c4a:	4628      	mov	r0, r5
   29c4c:	9301      	str	r3, [sp, #4]
   29c4e:	f000 f871 	bl	29d34 <_svfiprintf_r>
   29c52:	1c43      	adds	r3, r0, #1
   29c54:	bfbc      	itt	lt
   29c56:	238b      	movlt	r3, #139	; 0x8b
   29c58:	602b      	strlt	r3, [r5, #0]
   29c5a:	2c00      	cmp	r4, #0
   29c5c:	d0dd      	beq.n	29c1a <sniprintf+0x16>
   29c5e:	9b02      	ldr	r3, [sp, #8]
   29c60:	2200      	movs	r2, #0
   29c62:	701a      	strb	r2, [r3, #0]
   29c64:	e7d9      	b.n	29c1a <sniprintf+0x16>
   29c66:	bf00      	nop
   29c68:	20002038 	.word	0x20002038

00029c6c <strlen>:
   29c6c:	4603      	mov	r3, r0
   29c6e:	f813 2b01 	ldrb.w	r2, [r3], #1
   29c72:	2a00      	cmp	r2, #0
   29c74:	d1fb      	bne.n	29c6e <strlen+0x2>
   29c76:	1a18      	subs	r0, r3, r0
   29c78:	3801      	subs	r0, #1
   29c7a:	4770      	bx	lr

00029c7c <__ssputs_r>:
   29c7c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   29c80:	688e      	ldr	r6, [r1, #8]
   29c82:	429e      	cmp	r6, r3
   29c84:	4682      	mov	sl, r0
   29c86:	460c      	mov	r4, r1
   29c88:	4690      	mov	r8, r2
   29c8a:	461f      	mov	r7, r3
   29c8c:	d838      	bhi.n	29d00 <__ssputs_r+0x84>
   29c8e:	898a      	ldrh	r2, [r1, #12]
   29c90:	f412 6f90 	tst.w	r2, #1152	; 0x480
   29c94:	d032      	beq.n	29cfc <__ssputs_r+0x80>
   29c96:	6825      	ldr	r5, [r4, #0]
   29c98:	6909      	ldr	r1, [r1, #16]
   29c9a:	eba5 0901 	sub.w	r9, r5, r1
   29c9e:	6965      	ldr	r5, [r4, #20]
   29ca0:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   29ca4:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   29ca8:	3301      	adds	r3, #1
   29caa:	444b      	add	r3, r9
   29cac:	106d      	asrs	r5, r5, #1
   29cae:	429d      	cmp	r5, r3
   29cb0:	bf38      	it	cc
   29cb2:	461d      	movcc	r5, r3
   29cb4:	0553      	lsls	r3, r2, #21
   29cb6:	d531      	bpl.n	29d1c <__ssputs_r+0xa0>
   29cb8:	4629      	mov	r1, r5
   29cba:	f000 fb8b 	bl	2a3d4 <_malloc_r>
   29cbe:	4606      	mov	r6, r0
   29cc0:	b950      	cbnz	r0, 29cd8 <__ssputs_r+0x5c>
   29cc2:	230c      	movs	r3, #12
   29cc4:	f8ca 3000 	str.w	r3, [sl]
   29cc8:	89a3      	ldrh	r3, [r4, #12]
   29cca:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   29cce:	81a3      	strh	r3, [r4, #12]
   29cd0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29cd4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   29cd8:	6921      	ldr	r1, [r4, #16]
   29cda:	464a      	mov	r2, r9
   29cdc:	f7ff ff7c 	bl	29bd8 <memcpy>
   29ce0:	89a3      	ldrh	r3, [r4, #12]
   29ce2:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
   29ce6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   29cea:	81a3      	strh	r3, [r4, #12]
   29cec:	6126      	str	r6, [r4, #16]
   29cee:	6165      	str	r5, [r4, #20]
   29cf0:	444e      	add	r6, r9
   29cf2:	eba5 0509 	sub.w	r5, r5, r9
   29cf6:	6026      	str	r6, [r4, #0]
   29cf8:	60a5      	str	r5, [r4, #8]
   29cfa:	463e      	mov	r6, r7
   29cfc:	42be      	cmp	r6, r7
   29cfe:	d900      	bls.n	29d02 <__ssputs_r+0x86>
   29d00:	463e      	mov	r6, r7
   29d02:	4632      	mov	r2, r6
   29d04:	6820      	ldr	r0, [r4, #0]
   29d06:	4641      	mov	r1, r8
   29d08:	f000 fafa 	bl	2a300 <memmove>
   29d0c:	68a3      	ldr	r3, [r4, #8]
   29d0e:	6822      	ldr	r2, [r4, #0]
   29d10:	1b9b      	subs	r3, r3, r6
   29d12:	4432      	add	r2, r6
   29d14:	60a3      	str	r3, [r4, #8]
   29d16:	6022      	str	r2, [r4, #0]
   29d18:	2000      	movs	r0, #0
   29d1a:	e7db      	b.n	29cd4 <__ssputs_r+0x58>
   29d1c:	462a      	mov	r2, r5
   29d1e:	f000 fbb3 	bl	2a488 <_realloc_r>
   29d22:	4606      	mov	r6, r0
   29d24:	2800      	cmp	r0, #0
   29d26:	d1e1      	bne.n	29cec <__ssputs_r+0x70>
   29d28:	6921      	ldr	r1, [r4, #16]
   29d2a:	4650      	mov	r0, sl
   29d2c:	f000 fb02 	bl	2a334 <_free_r>
   29d30:	e7c7      	b.n	29cc2 <__ssputs_r+0x46>
	...

00029d34 <_svfiprintf_r>:
   29d34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   29d38:	4698      	mov	r8, r3
   29d3a:	898b      	ldrh	r3, [r1, #12]
   29d3c:	061b      	lsls	r3, r3, #24
   29d3e:	b09d      	sub	sp, #116	; 0x74
   29d40:	4607      	mov	r7, r0
   29d42:	460d      	mov	r5, r1
   29d44:	4614      	mov	r4, r2
   29d46:	d50e      	bpl.n	29d66 <_svfiprintf_r+0x32>
   29d48:	690b      	ldr	r3, [r1, #16]
   29d4a:	b963      	cbnz	r3, 29d66 <_svfiprintf_r+0x32>
   29d4c:	2140      	movs	r1, #64	; 0x40
   29d4e:	f000 fb41 	bl	2a3d4 <_malloc_r>
   29d52:	6028      	str	r0, [r5, #0]
   29d54:	6128      	str	r0, [r5, #16]
   29d56:	b920      	cbnz	r0, 29d62 <_svfiprintf_r+0x2e>
   29d58:	230c      	movs	r3, #12
   29d5a:	603b      	str	r3, [r7, #0]
   29d5c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29d60:	e0d1      	b.n	29f06 <_svfiprintf_r+0x1d2>
   29d62:	2340      	movs	r3, #64	; 0x40
   29d64:	616b      	str	r3, [r5, #20]
   29d66:	2300      	movs	r3, #0
   29d68:	9309      	str	r3, [sp, #36]	; 0x24
   29d6a:	2320      	movs	r3, #32
   29d6c:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   29d70:	f8cd 800c 	str.w	r8, [sp, #12]
   29d74:	2330      	movs	r3, #48	; 0x30
   29d76:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 29f20 <_svfiprintf_r+0x1ec>
   29d7a:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   29d7e:	f04f 0901 	mov.w	r9, #1
   29d82:	4623      	mov	r3, r4
   29d84:	469a      	mov	sl, r3
   29d86:	f813 2b01 	ldrb.w	r2, [r3], #1
   29d8a:	b10a      	cbz	r2, 29d90 <_svfiprintf_r+0x5c>
   29d8c:	2a25      	cmp	r2, #37	; 0x25
   29d8e:	d1f9      	bne.n	29d84 <_svfiprintf_r+0x50>
   29d90:	ebba 0b04 	subs.w	fp, sl, r4
   29d94:	d00b      	beq.n	29dae <_svfiprintf_r+0x7a>
   29d96:	465b      	mov	r3, fp
   29d98:	4622      	mov	r2, r4
   29d9a:	4629      	mov	r1, r5
   29d9c:	4638      	mov	r0, r7
   29d9e:	f7ff ff6d 	bl	29c7c <__ssputs_r>
   29da2:	3001      	adds	r0, #1
   29da4:	f000 80aa 	beq.w	29efc <_svfiprintf_r+0x1c8>
   29da8:	9a09      	ldr	r2, [sp, #36]	; 0x24
   29daa:	445a      	add	r2, fp
   29dac:	9209      	str	r2, [sp, #36]	; 0x24
   29dae:	f89a 3000 	ldrb.w	r3, [sl]
   29db2:	2b00      	cmp	r3, #0
   29db4:	f000 80a2 	beq.w	29efc <_svfiprintf_r+0x1c8>
   29db8:	2300      	movs	r3, #0
   29dba:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   29dbe:	e9cd 2305 	strd	r2, r3, [sp, #20]
   29dc2:	f10a 0a01 	add.w	sl, sl, #1
   29dc6:	9304      	str	r3, [sp, #16]
   29dc8:	9307      	str	r3, [sp, #28]
   29dca:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   29dce:	931a      	str	r3, [sp, #104]	; 0x68
   29dd0:	4654      	mov	r4, sl
   29dd2:	2205      	movs	r2, #5
   29dd4:	f814 1b01 	ldrb.w	r1, [r4], #1
   29dd8:	4851      	ldr	r0, [pc, #324]	; (29f20 <_svfiprintf_r+0x1ec>)
   29dda:	f000 fa41 	bl	2a260 <memchr>
   29dde:	9a04      	ldr	r2, [sp, #16]
   29de0:	b9d8      	cbnz	r0, 29e1a <_svfiprintf_r+0xe6>
   29de2:	06d0      	lsls	r0, r2, #27
   29de4:	bf44      	itt	mi
   29de6:	2320      	movmi	r3, #32
   29de8:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
   29dec:	0711      	lsls	r1, r2, #28
   29dee:	bf44      	itt	mi
   29df0:	232b      	movmi	r3, #43	; 0x2b
   29df2:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
   29df6:	f89a 3000 	ldrb.w	r3, [sl]
   29dfa:	2b2a      	cmp	r3, #42	; 0x2a
   29dfc:	d015      	beq.n	29e2a <_svfiprintf_r+0xf6>
   29dfe:	9a07      	ldr	r2, [sp, #28]
   29e00:	4654      	mov	r4, sl
   29e02:	2000      	movs	r0, #0
   29e04:	f04f 0c0a 	mov.w	ip, #10
   29e08:	4621      	mov	r1, r4
   29e0a:	f811 3b01 	ldrb.w	r3, [r1], #1
   29e0e:	3b30      	subs	r3, #48	; 0x30
   29e10:	2b09      	cmp	r3, #9
   29e12:	d94e      	bls.n	29eb2 <_svfiprintf_r+0x17e>
   29e14:	b1b0      	cbz	r0, 29e44 <_svfiprintf_r+0x110>
   29e16:	9207      	str	r2, [sp, #28]
   29e18:	e014      	b.n	29e44 <_svfiprintf_r+0x110>
   29e1a:	eba0 0308 	sub.w	r3, r0, r8
   29e1e:	fa09 f303 	lsl.w	r3, r9, r3
   29e22:	4313      	orrs	r3, r2
   29e24:	9304      	str	r3, [sp, #16]
   29e26:	46a2      	mov	sl, r4
   29e28:	e7d2      	b.n	29dd0 <_svfiprintf_r+0x9c>
   29e2a:	9b03      	ldr	r3, [sp, #12]
   29e2c:	1d19      	adds	r1, r3, #4
   29e2e:	681b      	ldr	r3, [r3, #0]
   29e30:	9103      	str	r1, [sp, #12]
   29e32:	2b00      	cmp	r3, #0
   29e34:	bfbb      	ittet	lt
   29e36:	425b      	neglt	r3, r3
   29e38:	f042 0202 	orrlt.w	r2, r2, #2
   29e3c:	9307      	strge	r3, [sp, #28]
   29e3e:	9307      	strlt	r3, [sp, #28]
   29e40:	bfb8      	it	lt
   29e42:	9204      	strlt	r2, [sp, #16]
   29e44:	7823      	ldrb	r3, [r4, #0]
   29e46:	2b2e      	cmp	r3, #46	; 0x2e
   29e48:	d10c      	bne.n	29e64 <_svfiprintf_r+0x130>
   29e4a:	7863      	ldrb	r3, [r4, #1]
   29e4c:	2b2a      	cmp	r3, #42	; 0x2a
   29e4e:	d135      	bne.n	29ebc <_svfiprintf_r+0x188>
   29e50:	9b03      	ldr	r3, [sp, #12]
   29e52:	1d1a      	adds	r2, r3, #4
   29e54:	681b      	ldr	r3, [r3, #0]
   29e56:	9203      	str	r2, [sp, #12]
   29e58:	2b00      	cmp	r3, #0
   29e5a:	bfb8      	it	lt
   29e5c:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   29e60:	3402      	adds	r4, #2
   29e62:	9305      	str	r3, [sp, #20]
   29e64:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 29f30 <_svfiprintf_r+0x1fc>
   29e68:	7821      	ldrb	r1, [r4, #0]
   29e6a:	2203      	movs	r2, #3
   29e6c:	4650      	mov	r0, sl
   29e6e:	f000 f9f7 	bl	2a260 <memchr>
   29e72:	b140      	cbz	r0, 29e86 <_svfiprintf_r+0x152>
   29e74:	2340      	movs	r3, #64	; 0x40
   29e76:	eba0 000a 	sub.w	r0, r0, sl
   29e7a:	fa03 f000 	lsl.w	r0, r3, r0
   29e7e:	9b04      	ldr	r3, [sp, #16]
   29e80:	4303      	orrs	r3, r0
   29e82:	3401      	adds	r4, #1
   29e84:	9304      	str	r3, [sp, #16]
   29e86:	f814 1b01 	ldrb.w	r1, [r4], #1
   29e8a:	4826      	ldr	r0, [pc, #152]	; (29f24 <_svfiprintf_r+0x1f0>)
   29e8c:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   29e90:	2206      	movs	r2, #6
   29e92:	f000 f9e5 	bl	2a260 <memchr>
   29e96:	2800      	cmp	r0, #0
   29e98:	d038      	beq.n	29f0c <_svfiprintf_r+0x1d8>
   29e9a:	4b23      	ldr	r3, [pc, #140]	; (29f28 <_svfiprintf_r+0x1f4>)
   29e9c:	bb1b      	cbnz	r3, 29ee6 <_svfiprintf_r+0x1b2>
   29e9e:	9b03      	ldr	r3, [sp, #12]
   29ea0:	3307      	adds	r3, #7
   29ea2:	f023 0307 	bic.w	r3, r3, #7
   29ea6:	3308      	adds	r3, #8
   29ea8:	9303      	str	r3, [sp, #12]
   29eaa:	9b09      	ldr	r3, [sp, #36]	; 0x24
   29eac:	4433      	add	r3, r6
   29eae:	9309      	str	r3, [sp, #36]	; 0x24
   29eb0:	e767      	b.n	29d82 <_svfiprintf_r+0x4e>
   29eb2:	fb0c 3202 	mla	r2, ip, r2, r3
   29eb6:	460c      	mov	r4, r1
   29eb8:	2001      	movs	r0, #1
   29eba:	e7a5      	b.n	29e08 <_svfiprintf_r+0xd4>
   29ebc:	2300      	movs	r3, #0
   29ebe:	3401      	adds	r4, #1
   29ec0:	9305      	str	r3, [sp, #20]
   29ec2:	4619      	mov	r1, r3
   29ec4:	f04f 0c0a 	mov.w	ip, #10
   29ec8:	4620      	mov	r0, r4
   29eca:	f810 2b01 	ldrb.w	r2, [r0], #1
   29ece:	3a30      	subs	r2, #48	; 0x30
   29ed0:	2a09      	cmp	r2, #9
   29ed2:	d903      	bls.n	29edc <_svfiprintf_r+0x1a8>
   29ed4:	2b00      	cmp	r3, #0
   29ed6:	d0c5      	beq.n	29e64 <_svfiprintf_r+0x130>
   29ed8:	9105      	str	r1, [sp, #20]
   29eda:	e7c3      	b.n	29e64 <_svfiprintf_r+0x130>
   29edc:	fb0c 2101 	mla	r1, ip, r1, r2
   29ee0:	4604      	mov	r4, r0
   29ee2:	2301      	movs	r3, #1
   29ee4:	e7f0      	b.n	29ec8 <_svfiprintf_r+0x194>
   29ee6:	ab03      	add	r3, sp, #12
   29ee8:	9300      	str	r3, [sp, #0]
   29eea:	462a      	mov	r2, r5
   29eec:	4b0f      	ldr	r3, [pc, #60]	; (29f2c <_svfiprintf_r+0x1f8>)
   29eee:	a904      	add	r1, sp, #16
   29ef0:	4638      	mov	r0, r7
   29ef2:	f3af 8000 	nop.w
   29ef6:	1c42      	adds	r2, r0, #1
   29ef8:	4606      	mov	r6, r0
   29efa:	d1d6      	bne.n	29eaa <_svfiprintf_r+0x176>
   29efc:	89ab      	ldrh	r3, [r5, #12]
   29efe:	065b      	lsls	r3, r3, #25
   29f00:	f53f af2c 	bmi.w	29d5c <_svfiprintf_r+0x28>
   29f04:	9809      	ldr	r0, [sp, #36]	; 0x24
   29f06:	b01d      	add	sp, #116	; 0x74
   29f08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   29f0c:	ab03      	add	r3, sp, #12
   29f0e:	9300      	str	r3, [sp, #0]
   29f10:	462a      	mov	r2, r5
   29f12:	4b06      	ldr	r3, [pc, #24]	; (29f2c <_svfiprintf_r+0x1f8>)
   29f14:	a904      	add	r1, sp, #16
   29f16:	4638      	mov	r0, r7
   29f18:	f000 f87a 	bl	2a010 <_printf_i>
   29f1c:	e7eb      	b.n	29ef6 <_svfiprintf_r+0x1c2>
   29f1e:	bf00      	nop
   29f20:	0002bd6c 	.word	0x0002bd6c
   29f24:	0002bd76 	.word	0x0002bd76
   29f28:	00000000 	.word	0x00000000
   29f2c:	00029c7d 	.word	0x00029c7d
   29f30:	0002bd72 	.word	0x0002bd72

00029f34 <_printf_common>:
   29f34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   29f38:	4616      	mov	r6, r2
   29f3a:	4699      	mov	r9, r3
   29f3c:	688a      	ldr	r2, [r1, #8]
   29f3e:	690b      	ldr	r3, [r1, #16]
   29f40:	f8dd 8020 	ldr.w	r8, [sp, #32]
   29f44:	4293      	cmp	r3, r2
   29f46:	bfb8      	it	lt
   29f48:	4613      	movlt	r3, r2
   29f4a:	6033      	str	r3, [r6, #0]
   29f4c:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
   29f50:	4607      	mov	r7, r0
   29f52:	460c      	mov	r4, r1
   29f54:	b10a      	cbz	r2, 29f5a <_printf_common+0x26>
   29f56:	3301      	adds	r3, #1
   29f58:	6033      	str	r3, [r6, #0]
   29f5a:	6823      	ldr	r3, [r4, #0]
   29f5c:	0699      	lsls	r1, r3, #26
   29f5e:	bf42      	ittt	mi
   29f60:	6833      	ldrmi	r3, [r6, #0]
   29f62:	3302      	addmi	r3, #2
   29f64:	6033      	strmi	r3, [r6, #0]
   29f66:	6825      	ldr	r5, [r4, #0]
   29f68:	f015 0506 	ands.w	r5, r5, #6
   29f6c:	d106      	bne.n	29f7c <_printf_common+0x48>
   29f6e:	f104 0a19 	add.w	sl, r4, #25
   29f72:	68e3      	ldr	r3, [r4, #12]
   29f74:	6832      	ldr	r2, [r6, #0]
   29f76:	1a9b      	subs	r3, r3, r2
   29f78:	42ab      	cmp	r3, r5
   29f7a:	dc26      	bgt.n	29fca <_printf_common+0x96>
   29f7c:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
   29f80:	1e13      	subs	r3, r2, #0
   29f82:	6822      	ldr	r2, [r4, #0]
   29f84:	bf18      	it	ne
   29f86:	2301      	movne	r3, #1
   29f88:	0692      	lsls	r2, r2, #26
   29f8a:	d42b      	bmi.n	29fe4 <_printf_common+0xb0>
   29f8c:	f104 0243 	add.w	r2, r4, #67	; 0x43
   29f90:	4649      	mov	r1, r9
   29f92:	4638      	mov	r0, r7
   29f94:	47c0      	blx	r8
   29f96:	3001      	adds	r0, #1
   29f98:	d01e      	beq.n	29fd8 <_printf_common+0xa4>
   29f9a:	6823      	ldr	r3, [r4, #0]
   29f9c:	68e5      	ldr	r5, [r4, #12]
   29f9e:	6832      	ldr	r2, [r6, #0]
   29fa0:	f003 0306 	and.w	r3, r3, #6
   29fa4:	2b04      	cmp	r3, #4
   29fa6:	bf08      	it	eq
   29fa8:	1aad      	subeq	r5, r5, r2
   29faa:	68a3      	ldr	r3, [r4, #8]
   29fac:	6922      	ldr	r2, [r4, #16]
   29fae:	bf0c      	ite	eq
   29fb0:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
   29fb4:	2500      	movne	r5, #0
   29fb6:	4293      	cmp	r3, r2
   29fb8:	bfc4      	itt	gt
   29fba:	1a9b      	subgt	r3, r3, r2
   29fbc:	18ed      	addgt	r5, r5, r3
   29fbe:	2600      	movs	r6, #0
   29fc0:	341a      	adds	r4, #26
   29fc2:	42b5      	cmp	r5, r6
   29fc4:	d11a      	bne.n	29ffc <_printf_common+0xc8>
   29fc6:	2000      	movs	r0, #0
   29fc8:	e008      	b.n	29fdc <_printf_common+0xa8>
   29fca:	2301      	movs	r3, #1
   29fcc:	4652      	mov	r2, sl
   29fce:	4649      	mov	r1, r9
   29fd0:	4638      	mov	r0, r7
   29fd2:	47c0      	blx	r8
   29fd4:	3001      	adds	r0, #1
   29fd6:	d103      	bne.n	29fe0 <_printf_common+0xac>
   29fd8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29fdc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   29fe0:	3501      	adds	r5, #1
   29fe2:	e7c6      	b.n	29f72 <_printf_common+0x3e>
   29fe4:	18e1      	adds	r1, r4, r3
   29fe6:	1c5a      	adds	r2, r3, #1
   29fe8:	2030      	movs	r0, #48	; 0x30
   29fea:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
   29fee:	4422      	add	r2, r4
   29ff0:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
   29ff4:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
   29ff8:	3302      	adds	r3, #2
   29ffa:	e7c7      	b.n	29f8c <_printf_common+0x58>
   29ffc:	2301      	movs	r3, #1
   29ffe:	4622      	mov	r2, r4
   2a000:	4649      	mov	r1, r9
   2a002:	4638      	mov	r0, r7
   2a004:	47c0      	blx	r8
   2a006:	3001      	adds	r0, #1
   2a008:	d0e6      	beq.n	29fd8 <_printf_common+0xa4>
   2a00a:	3601      	adds	r6, #1
   2a00c:	e7d9      	b.n	29fc2 <_printf_common+0x8e>
	...

0002a010 <_printf_i>:
   2a010:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   2a014:	460c      	mov	r4, r1
   2a016:	4691      	mov	r9, r2
   2a018:	7e27      	ldrb	r7, [r4, #24]
   2a01a:	990c      	ldr	r1, [sp, #48]	; 0x30
   2a01c:	2f78      	cmp	r7, #120	; 0x78
   2a01e:	4680      	mov	r8, r0
   2a020:	469a      	mov	sl, r3
   2a022:	f104 0243 	add.w	r2, r4, #67	; 0x43
   2a026:	d807      	bhi.n	2a038 <_printf_i+0x28>
   2a028:	2f62      	cmp	r7, #98	; 0x62
   2a02a:	d80a      	bhi.n	2a042 <_printf_i+0x32>
   2a02c:	2f00      	cmp	r7, #0
   2a02e:	f000 80d8 	beq.w	2a1e2 <_printf_i+0x1d2>
   2a032:	2f58      	cmp	r7, #88	; 0x58
   2a034:	f000 80a3 	beq.w	2a17e <_printf_i+0x16e>
   2a038:	f104 0642 	add.w	r6, r4, #66	; 0x42
   2a03c:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
   2a040:	e03a      	b.n	2a0b8 <_printf_i+0xa8>
   2a042:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
   2a046:	2b15      	cmp	r3, #21
   2a048:	d8f6      	bhi.n	2a038 <_printf_i+0x28>
   2a04a:	a001      	add	r0, pc, #4	; (adr r0, 2a050 <_printf_i+0x40>)
   2a04c:	f850 f023 	ldr.w	pc, [r0, r3, lsl #2]
   2a050:	0002a0a9 	.word	0x0002a0a9
   2a054:	0002a0bd 	.word	0x0002a0bd
   2a058:	0002a039 	.word	0x0002a039
   2a05c:	0002a039 	.word	0x0002a039
   2a060:	0002a039 	.word	0x0002a039
   2a064:	0002a039 	.word	0x0002a039
   2a068:	0002a0bd 	.word	0x0002a0bd
   2a06c:	0002a039 	.word	0x0002a039
   2a070:	0002a039 	.word	0x0002a039
   2a074:	0002a039 	.word	0x0002a039
   2a078:	0002a039 	.word	0x0002a039
   2a07c:	0002a1c9 	.word	0x0002a1c9
   2a080:	0002a0ed 	.word	0x0002a0ed
   2a084:	0002a1ab 	.word	0x0002a1ab
   2a088:	0002a039 	.word	0x0002a039
   2a08c:	0002a039 	.word	0x0002a039
   2a090:	0002a1eb 	.word	0x0002a1eb
   2a094:	0002a039 	.word	0x0002a039
   2a098:	0002a0ed 	.word	0x0002a0ed
   2a09c:	0002a039 	.word	0x0002a039
   2a0a0:	0002a039 	.word	0x0002a039
   2a0a4:	0002a1b3 	.word	0x0002a1b3
   2a0a8:	680b      	ldr	r3, [r1, #0]
   2a0aa:	1d1a      	adds	r2, r3, #4
   2a0ac:	681b      	ldr	r3, [r3, #0]
   2a0ae:	600a      	str	r2, [r1, #0]
   2a0b0:	f104 0642 	add.w	r6, r4, #66	; 0x42
   2a0b4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
   2a0b8:	2301      	movs	r3, #1
   2a0ba:	e0a3      	b.n	2a204 <_printf_i+0x1f4>
   2a0bc:	6825      	ldr	r5, [r4, #0]
   2a0be:	6808      	ldr	r0, [r1, #0]
   2a0c0:	062e      	lsls	r6, r5, #24
   2a0c2:	f100 0304 	add.w	r3, r0, #4
   2a0c6:	d50a      	bpl.n	2a0de <_printf_i+0xce>
   2a0c8:	6805      	ldr	r5, [r0, #0]
   2a0ca:	600b      	str	r3, [r1, #0]
   2a0cc:	2d00      	cmp	r5, #0
   2a0ce:	da03      	bge.n	2a0d8 <_printf_i+0xc8>
   2a0d0:	232d      	movs	r3, #45	; 0x2d
   2a0d2:	426d      	negs	r5, r5
   2a0d4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   2a0d8:	485e      	ldr	r0, [pc, #376]	; (2a254 <_printf_i+0x244>)
   2a0da:	230a      	movs	r3, #10
   2a0dc:	e019      	b.n	2a112 <_printf_i+0x102>
   2a0de:	f015 0f40 	tst.w	r5, #64	; 0x40
   2a0e2:	6805      	ldr	r5, [r0, #0]
   2a0e4:	600b      	str	r3, [r1, #0]
   2a0e6:	bf18      	it	ne
   2a0e8:	b22d      	sxthne	r5, r5
   2a0ea:	e7ef      	b.n	2a0cc <_printf_i+0xbc>
   2a0ec:	680b      	ldr	r3, [r1, #0]
   2a0ee:	6825      	ldr	r5, [r4, #0]
   2a0f0:	1d18      	adds	r0, r3, #4
   2a0f2:	6008      	str	r0, [r1, #0]
   2a0f4:	0628      	lsls	r0, r5, #24
   2a0f6:	d501      	bpl.n	2a0fc <_printf_i+0xec>
   2a0f8:	681d      	ldr	r5, [r3, #0]
   2a0fa:	e002      	b.n	2a102 <_printf_i+0xf2>
   2a0fc:	0669      	lsls	r1, r5, #25
   2a0fe:	d5fb      	bpl.n	2a0f8 <_printf_i+0xe8>
   2a100:	881d      	ldrh	r5, [r3, #0]
   2a102:	4854      	ldr	r0, [pc, #336]	; (2a254 <_printf_i+0x244>)
   2a104:	2f6f      	cmp	r7, #111	; 0x6f
   2a106:	bf0c      	ite	eq
   2a108:	2308      	moveq	r3, #8
   2a10a:	230a      	movne	r3, #10
   2a10c:	2100      	movs	r1, #0
   2a10e:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
   2a112:	6866      	ldr	r6, [r4, #4]
   2a114:	60a6      	str	r6, [r4, #8]
   2a116:	2e00      	cmp	r6, #0
   2a118:	bfa2      	ittt	ge
   2a11a:	6821      	ldrge	r1, [r4, #0]
   2a11c:	f021 0104 	bicge.w	r1, r1, #4
   2a120:	6021      	strge	r1, [r4, #0]
   2a122:	b90d      	cbnz	r5, 2a128 <_printf_i+0x118>
   2a124:	2e00      	cmp	r6, #0
   2a126:	d04d      	beq.n	2a1c4 <_printf_i+0x1b4>
   2a128:	4616      	mov	r6, r2
   2a12a:	fbb5 f1f3 	udiv	r1, r5, r3
   2a12e:	fb03 5711 	mls	r7, r3, r1, r5
   2a132:	5dc7      	ldrb	r7, [r0, r7]
   2a134:	f806 7d01 	strb.w	r7, [r6, #-1]!
   2a138:	462f      	mov	r7, r5
   2a13a:	42bb      	cmp	r3, r7
   2a13c:	460d      	mov	r5, r1
   2a13e:	d9f4      	bls.n	2a12a <_printf_i+0x11a>
   2a140:	2b08      	cmp	r3, #8
   2a142:	d10b      	bne.n	2a15c <_printf_i+0x14c>
   2a144:	6823      	ldr	r3, [r4, #0]
   2a146:	07df      	lsls	r7, r3, #31
   2a148:	d508      	bpl.n	2a15c <_printf_i+0x14c>
   2a14a:	6923      	ldr	r3, [r4, #16]
   2a14c:	6861      	ldr	r1, [r4, #4]
   2a14e:	4299      	cmp	r1, r3
   2a150:	bfde      	ittt	le
   2a152:	2330      	movle	r3, #48	; 0x30
   2a154:	f806 3c01 	strble.w	r3, [r6, #-1]
   2a158:	f106 36ff 	addle.w	r6, r6, #4294967295	; 0xffffffff
   2a15c:	1b92      	subs	r2, r2, r6
   2a15e:	6122      	str	r2, [r4, #16]
   2a160:	f8cd a000 	str.w	sl, [sp]
   2a164:	464b      	mov	r3, r9
   2a166:	aa03      	add	r2, sp, #12
   2a168:	4621      	mov	r1, r4
   2a16a:	4640      	mov	r0, r8
   2a16c:	f7ff fee2 	bl	29f34 <_printf_common>
   2a170:	3001      	adds	r0, #1
   2a172:	d14c      	bne.n	2a20e <_printf_i+0x1fe>
   2a174:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a178:	b004      	add	sp, #16
   2a17a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2a17e:	4835      	ldr	r0, [pc, #212]	; (2a254 <_printf_i+0x244>)
   2a180:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
   2a184:	6823      	ldr	r3, [r4, #0]
   2a186:	680e      	ldr	r6, [r1, #0]
   2a188:	061f      	lsls	r7, r3, #24
   2a18a:	f856 5b04 	ldr.w	r5, [r6], #4
   2a18e:	600e      	str	r6, [r1, #0]
   2a190:	d514      	bpl.n	2a1bc <_printf_i+0x1ac>
   2a192:	07d9      	lsls	r1, r3, #31
   2a194:	bf44      	itt	mi
   2a196:	f043 0320 	orrmi.w	r3, r3, #32
   2a19a:	6023      	strmi	r3, [r4, #0]
   2a19c:	b91d      	cbnz	r5, 2a1a6 <_printf_i+0x196>
   2a19e:	6823      	ldr	r3, [r4, #0]
   2a1a0:	f023 0320 	bic.w	r3, r3, #32
   2a1a4:	6023      	str	r3, [r4, #0]
   2a1a6:	2310      	movs	r3, #16
   2a1a8:	e7b0      	b.n	2a10c <_printf_i+0xfc>
   2a1aa:	6823      	ldr	r3, [r4, #0]
   2a1ac:	f043 0320 	orr.w	r3, r3, #32
   2a1b0:	6023      	str	r3, [r4, #0]
   2a1b2:	2378      	movs	r3, #120	; 0x78
   2a1b4:	4828      	ldr	r0, [pc, #160]	; (2a258 <_printf_i+0x248>)
   2a1b6:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
   2a1ba:	e7e3      	b.n	2a184 <_printf_i+0x174>
   2a1bc:	065e      	lsls	r6, r3, #25
   2a1be:	bf48      	it	mi
   2a1c0:	b2ad      	uxthmi	r5, r5
   2a1c2:	e7e6      	b.n	2a192 <_printf_i+0x182>
   2a1c4:	4616      	mov	r6, r2
   2a1c6:	e7bb      	b.n	2a140 <_printf_i+0x130>
   2a1c8:	680b      	ldr	r3, [r1, #0]
   2a1ca:	6826      	ldr	r6, [r4, #0]
   2a1cc:	6960      	ldr	r0, [r4, #20]
   2a1ce:	1d1d      	adds	r5, r3, #4
   2a1d0:	600d      	str	r5, [r1, #0]
   2a1d2:	0635      	lsls	r5, r6, #24
   2a1d4:	681b      	ldr	r3, [r3, #0]
   2a1d6:	d501      	bpl.n	2a1dc <_printf_i+0x1cc>
   2a1d8:	6018      	str	r0, [r3, #0]
   2a1da:	e002      	b.n	2a1e2 <_printf_i+0x1d2>
   2a1dc:	0671      	lsls	r1, r6, #25
   2a1de:	d5fb      	bpl.n	2a1d8 <_printf_i+0x1c8>
   2a1e0:	8018      	strh	r0, [r3, #0]
   2a1e2:	2300      	movs	r3, #0
   2a1e4:	6123      	str	r3, [r4, #16]
   2a1e6:	4616      	mov	r6, r2
   2a1e8:	e7ba      	b.n	2a160 <_printf_i+0x150>
   2a1ea:	680b      	ldr	r3, [r1, #0]
   2a1ec:	1d1a      	adds	r2, r3, #4
   2a1ee:	600a      	str	r2, [r1, #0]
   2a1f0:	681e      	ldr	r6, [r3, #0]
   2a1f2:	6862      	ldr	r2, [r4, #4]
   2a1f4:	2100      	movs	r1, #0
   2a1f6:	4630      	mov	r0, r6
   2a1f8:	f000 f832 	bl	2a260 <memchr>
   2a1fc:	b108      	cbz	r0, 2a202 <_printf_i+0x1f2>
   2a1fe:	1b80      	subs	r0, r0, r6
   2a200:	6060      	str	r0, [r4, #4]
   2a202:	6863      	ldr	r3, [r4, #4]
   2a204:	6123      	str	r3, [r4, #16]
   2a206:	2300      	movs	r3, #0
   2a208:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   2a20c:	e7a8      	b.n	2a160 <_printf_i+0x150>
   2a20e:	6923      	ldr	r3, [r4, #16]
   2a210:	4632      	mov	r2, r6
   2a212:	4649      	mov	r1, r9
   2a214:	4640      	mov	r0, r8
   2a216:	47d0      	blx	sl
   2a218:	3001      	adds	r0, #1
   2a21a:	d0ab      	beq.n	2a174 <_printf_i+0x164>
   2a21c:	6823      	ldr	r3, [r4, #0]
   2a21e:	079b      	lsls	r3, r3, #30
   2a220:	d413      	bmi.n	2a24a <_printf_i+0x23a>
   2a222:	68e0      	ldr	r0, [r4, #12]
   2a224:	9b03      	ldr	r3, [sp, #12]
   2a226:	4298      	cmp	r0, r3
   2a228:	bfb8      	it	lt
   2a22a:	4618      	movlt	r0, r3
   2a22c:	e7a4      	b.n	2a178 <_printf_i+0x168>
   2a22e:	2301      	movs	r3, #1
   2a230:	4632      	mov	r2, r6
   2a232:	4649      	mov	r1, r9
   2a234:	4640      	mov	r0, r8
   2a236:	47d0      	blx	sl
   2a238:	3001      	adds	r0, #1
   2a23a:	d09b      	beq.n	2a174 <_printf_i+0x164>
   2a23c:	3501      	adds	r5, #1
   2a23e:	68e3      	ldr	r3, [r4, #12]
   2a240:	9903      	ldr	r1, [sp, #12]
   2a242:	1a5b      	subs	r3, r3, r1
   2a244:	42ab      	cmp	r3, r5
   2a246:	dcf2      	bgt.n	2a22e <_printf_i+0x21e>
   2a248:	e7eb      	b.n	2a222 <_printf_i+0x212>
   2a24a:	2500      	movs	r5, #0
   2a24c:	f104 0619 	add.w	r6, r4, #25
   2a250:	e7f5      	b.n	2a23e <_printf_i+0x22e>
   2a252:	bf00      	nop
   2a254:	0002bd7d 	.word	0x0002bd7d
   2a258:	0002bd8e 	.word	0x0002bd8e
   2a25c:	00000000 	.word	0x00000000

0002a260 <memchr>:
   2a260:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   2a264:	2a10      	cmp	r2, #16
   2a266:	db2b      	blt.n	2a2c0 <memchr+0x60>
   2a268:	f010 0f07 	tst.w	r0, #7
   2a26c:	d008      	beq.n	2a280 <memchr+0x20>
   2a26e:	f810 3b01 	ldrb.w	r3, [r0], #1
   2a272:	3a01      	subs	r2, #1
   2a274:	428b      	cmp	r3, r1
   2a276:	d02d      	beq.n	2a2d4 <memchr+0x74>
   2a278:	f010 0f07 	tst.w	r0, #7
   2a27c:	b342      	cbz	r2, 2a2d0 <memchr+0x70>
   2a27e:	d1f6      	bne.n	2a26e <memchr+0xe>
   2a280:	b4f0      	push	{r4, r5, r6, r7}
   2a282:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
   2a286:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
   2a28a:	f022 0407 	bic.w	r4, r2, #7
   2a28e:	f07f 0700 	mvns.w	r7, #0
   2a292:	2300      	movs	r3, #0
   2a294:	e8f0 5602 	ldrd	r5, r6, [r0], #8
   2a298:	3c08      	subs	r4, #8
   2a29a:	ea85 0501 	eor.w	r5, r5, r1
   2a29e:	ea86 0601 	eor.w	r6, r6, r1
   2a2a2:	fa85 f547 	uadd8	r5, r5, r7
   2a2a6:	faa3 f587 	sel	r5, r3, r7
   2a2aa:	fa86 f647 	uadd8	r6, r6, r7
   2a2ae:	faa5 f687 	sel	r6, r5, r7
   2a2b2:	b98e      	cbnz	r6, 2a2d8 <memchr+0x78>
   2a2b4:	d1ee      	bne.n	2a294 <memchr+0x34>
   2a2b6:	bcf0      	pop	{r4, r5, r6, r7}
   2a2b8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   2a2bc:	f002 0207 	and.w	r2, r2, #7
   2a2c0:	b132      	cbz	r2, 2a2d0 <memchr+0x70>
   2a2c2:	f810 3b01 	ldrb.w	r3, [r0], #1
   2a2c6:	3a01      	subs	r2, #1
   2a2c8:	ea83 0301 	eor.w	r3, r3, r1
   2a2cc:	b113      	cbz	r3, 2a2d4 <memchr+0x74>
   2a2ce:	d1f8      	bne.n	2a2c2 <memchr+0x62>
   2a2d0:	2000      	movs	r0, #0
   2a2d2:	4770      	bx	lr
   2a2d4:	3801      	subs	r0, #1
   2a2d6:	4770      	bx	lr
   2a2d8:	2d00      	cmp	r5, #0
   2a2da:	bf06      	itte	eq
   2a2dc:	4635      	moveq	r5, r6
   2a2de:	3803      	subeq	r0, #3
   2a2e0:	3807      	subne	r0, #7
   2a2e2:	f015 0f01 	tst.w	r5, #1
   2a2e6:	d107      	bne.n	2a2f8 <memchr+0x98>
   2a2e8:	3001      	adds	r0, #1
   2a2ea:	f415 7f80 	tst.w	r5, #256	; 0x100
   2a2ee:	bf02      	ittt	eq
   2a2f0:	3001      	addeq	r0, #1
   2a2f2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
   2a2f6:	3001      	addeq	r0, #1
   2a2f8:	bcf0      	pop	{r4, r5, r6, r7}
   2a2fa:	3801      	subs	r0, #1
   2a2fc:	4770      	bx	lr
   2a2fe:	bf00      	nop

0002a300 <memmove>:
   2a300:	4288      	cmp	r0, r1
   2a302:	b510      	push	{r4, lr}
   2a304:	eb01 0402 	add.w	r4, r1, r2
   2a308:	d902      	bls.n	2a310 <memmove+0x10>
   2a30a:	4284      	cmp	r4, r0
   2a30c:	4623      	mov	r3, r4
   2a30e:	d807      	bhi.n	2a320 <memmove+0x20>
   2a310:	1e43      	subs	r3, r0, #1
   2a312:	42a1      	cmp	r1, r4
   2a314:	d008      	beq.n	2a328 <memmove+0x28>
   2a316:	f811 2b01 	ldrb.w	r2, [r1], #1
   2a31a:	f803 2f01 	strb.w	r2, [r3, #1]!
   2a31e:	e7f8      	b.n	2a312 <memmove+0x12>
   2a320:	4402      	add	r2, r0
   2a322:	4601      	mov	r1, r0
   2a324:	428a      	cmp	r2, r1
   2a326:	d100      	bne.n	2a32a <memmove+0x2a>
   2a328:	bd10      	pop	{r4, pc}
   2a32a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
   2a32e:	f802 4d01 	strb.w	r4, [r2, #-1]!
   2a332:	e7f7      	b.n	2a324 <memmove+0x24>

0002a334 <_free_r>:
   2a334:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2a336:	2900      	cmp	r1, #0
   2a338:	d048      	beq.n	2a3cc <_free_r+0x98>
   2a33a:	f851 3c04 	ldr.w	r3, [r1, #-4]
   2a33e:	9001      	str	r0, [sp, #4]
   2a340:	2b00      	cmp	r3, #0
   2a342:	f1a1 0404 	sub.w	r4, r1, #4
   2a346:	bfb8      	it	lt
   2a348:	18e4      	addlt	r4, r4, r3
   2a34a:	f000 f8d3 	bl	2a4f4 <__malloc_lock>
   2a34e:	4a20      	ldr	r2, [pc, #128]	; (2a3d0 <_free_r+0x9c>)
   2a350:	9801      	ldr	r0, [sp, #4]
   2a352:	6813      	ldr	r3, [r2, #0]
   2a354:	4615      	mov	r5, r2
   2a356:	b933      	cbnz	r3, 2a366 <_free_r+0x32>
   2a358:	6063      	str	r3, [r4, #4]
   2a35a:	6014      	str	r4, [r2, #0]
   2a35c:	b003      	add	sp, #12
   2a35e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   2a362:	f000 b8cd 	b.w	2a500 <__malloc_unlock>
   2a366:	42a3      	cmp	r3, r4
   2a368:	d90b      	bls.n	2a382 <_free_r+0x4e>
   2a36a:	6821      	ldr	r1, [r4, #0]
   2a36c:	1862      	adds	r2, r4, r1
   2a36e:	4293      	cmp	r3, r2
   2a370:	bf04      	itt	eq
   2a372:	681a      	ldreq	r2, [r3, #0]
   2a374:	685b      	ldreq	r3, [r3, #4]
   2a376:	6063      	str	r3, [r4, #4]
   2a378:	bf04      	itt	eq
   2a37a:	1852      	addeq	r2, r2, r1
   2a37c:	6022      	streq	r2, [r4, #0]
   2a37e:	602c      	str	r4, [r5, #0]
   2a380:	e7ec      	b.n	2a35c <_free_r+0x28>
   2a382:	461a      	mov	r2, r3
   2a384:	685b      	ldr	r3, [r3, #4]
   2a386:	b10b      	cbz	r3, 2a38c <_free_r+0x58>
   2a388:	42a3      	cmp	r3, r4
   2a38a:	d9fa      	bls.n	2a382 <_free_r+0x4e>
   2a38c:	6811      	ldr	r1, [r2, #0]
   2a38e:	1855      	adds	r5, r2, r1
   2a390:	42a5      	cmp	r5, r4
   2a392:	d10b      	bne.n	2a3ac <_free_r+0x78>
   2a394:	6824      	ldr	r4, [r4, #0]
   2a396:	4421      	add	r1, r4
   2a398:	1854      	adds	r4, r2, r1
   2a39a:	42a3      	cmp	r3, r4
   2a39c:	6011      	str	r1, [r2, #0]
   2a39e:	d1dd      	bne.n	2a35c <_free_r+0x28>
   2a3a0:	681c      	ldr	r4, [r3, #0]
   2a3a2:	685b      	ldr	r3, [r3, #4]
   2a3a4:	6053      	str	r3, [r2, #4]
   2a3a6:	4421      	add	r1, r4
   2a3a8:	6011      	str	r1, [r2, #0]
   2a3aa:	e7d7      	b.n	2a35c <_free_r+0x28>
   2a3ac:	d902      	bls.n	2a3b4 <_free_r+0x80>
   2a3ae:	230c      	movs	r3, #12
   2a3b0:	6003      	str	r3, [r0, #0]
   2a3b2:	e7d3      	b.n	2a35c <_free_r+0x28>
   2a3b4:	6825      	ldr	r5, [r4, #0]
   2a3b6:	1961      	adds	r1, r4, r5
   2a3b8:	428b      	cmp	r3, r1
   2a3ba:	bf04      	itt	eq
   2a3bc:	6819      	ldreq	r1, [r3, #0]
   2a3be:	685b      	ldreq	r3, [r3, #4]
   2a3c0:	6063      	str	r3, [r4, #4]
   2a3c2:	bf04      	itt	eq
   2a3c4:	1949      	addeq	r1, r1, r5
   2a3c6:	6021      	streq	r1, [r4, #0]
   2a3c8:	6054      	str	r4, [r2, #4]
   2a3ca:	e7c7      	b.n	2a35c <_free_r+0x28>
   2a3cc:	b003      	add	sp, #12
   2a3ce:	bd30      	pop	{r4, r5, pc}
   2a3d0:	20002320 	.word	0x20002320

0002a3d4 <_malloc_r>:
   2a3d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2a3d6:	1ccd      	adds	r5, r1, #3
   2a3d8:	f025 0503 	bic.w	r5, r5, #3
   2a3dc:	3508      	adds	r5, #8
   2a3de:	2d0c      	cmp	r5, #12
   2a3e0:	bf38      	it	cc
   2a3e2:	250c      	movcc	r5, #12
   2a3e4:	2d00      	cmp	r5, #0
   2a3e6:	4606      	mov	r6, r0
   2a3e8:	db01      	blt.n	2a3ee <_malloc_r+0x1a>
   2a3ea:	42a9      	cmp	r1, r5
   2a3ec:	d903      	bls.n	2a3f6 <_malloc_r+0x22>
   2a3ee:	230c      	movs	r3, #12
   2a3f0:	6033      	str	r3, [r6, #0]
   2a3f2:	2000      	movs	r0, #0
   2a3f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2a3f6:	f000 f87d 	bl	2a4f4 <__malloc_lock>
   2a3fa:	4921      	ldr	r1, [pc, #132]	; (2a480 <_malloc_r+0xac>)
   2a3fc:	680a      	ldr	r2, [r1, #0]
   2a3fe:	4614      	mov	r4, r2
   2a400:	b99c      	cbnz	r4, 2a42a <_malloc_r+0x56>
   2a402:	4f20      	ldr	r7, [pc, #128]	; (2a484 <_malloc_r+0xb0>)
   2a404:	683b      	ldr	r3, [r7, #0]
   2a406:	b923      	cbnz	r3, 2a412 <_malloc_r+0x3e>
   2a408:	4621      	mov	r1, r4
   2a40a:	4630      	mov	r0, r6
   2a40c:	f000 f862 	bl	2a4d4 <_sbrk_r>
   2a410:	6038      	str	r0, [r7, #0]
   2a412:	4629      	mov	r1, r5
   2a414:	4630      	mov	r0, r6
   2a416:	f000 f85d 	bl	2a4d4 <_sbrk_r>
   2a41a:	1c43      	adds	r3, r0, #1
   2a41c:	d123      	bne.n	2a466 <_malloc_r+0x92>
   2a41e:	230c      	movs	r3, #12
   2a420:	6033      	str	r3, [r6, #0]
   2a422:	4630      	mov	r0, r6
   2a424:	f000 f86c 	bl	2a500 <__malloc_unlock>
   2a428:	e7e3      	b.n	2a3f2 <_malloc_r+0x1e>
   2a42a:	6823      	ldr	r3, [r4, #0]
   2a42c:	1b5b      	subs	r3, r3, r5
   2a42e:	d417      	bmi.n	2a460 <_malloc_r+0x8c>
   2a430:	2b0b      	cmp	r3, #11
   2a432:	d903      	bls.n	2a43c <_malloc_r+0x68>
   2a434:	6023      	str	r3, [r4, #0]
   2a436:	441c      	add	r4, r3
   2a438:	6025      	str	r5, [r4, #0]
   2a43a:	e004      	b.n	2a446 <_malloc_r+0x72>
   2a43c:	6863      	ldr	r3, [r4, #4]
   2a43e:	42a2      	cmp	r2, r4
   2a440:	bf0c      	ite	eq
   2a442:	600b      	streq	r3, [r1, #0]
   2a444:	6053      	strne	r3, [r2, #4]
   2a446:	4630      	mov	r0, r6
   2a448:	f000 f85a 	bl	2a500 <__malloc_unlock>
   2a44c:	f104 000b 	add.w	r0, r4, #11
   2a450:	1d23      	adds	r3, r4, #4
   2a452:	f020 0007 	bic.w	r0, r0, #7
   2a456:	1ac2      	subs	r2, r0, r3
   2a458:	d0cc      	beq.n	2a3f4 <_malloc_r+0x20>
   2a45a:	1a1b      	subs	r3, r3, r0
   2a45c:	50a3      	str	r3, [r4, r2]
   2a45e:	e7c9      	b.n	2a3f4 <_malloc_r+0x20>
   2a460:	4622      	mov	r2, r4
   2a462:	6864      	ldr	r4, [r4, #4]
   2a464:	e7cc      	b.n	2a400 <_malloc_r+0x2c>
   2a466:	1cc4      	adds	r4, r0, #3
   2a468:	f024 0403 	bic.w	r4, r4, #3
   2a46c:	42a0      	cmp	r0, r4
   2a46e:	d0e3      	beq.n	2a438 <_malloc_r+0x64>
   2a470:	1a21      	subs	r1, r4, r0
   2a472:	4630      	mov	r0, r6
   2a474:	f000 f82e 	bl	2a4d4 <_sbrk_r>
   2a478:	3001      	adds	r0, #1
   2a47a:	d1dd      	bne.n	2a438 <_malloc_r+0x64>
   2a47c:	e7cf      	b.n	2a41e <_malloc_r+0x4a>
   2a47e:	bf00      	nop
   2a480:	20002320 	.word	0x20002320
   2a484:	20002324 	.word	0x20002324

0002a488 <_realloc_r>:
   2a488:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2a48a:	4607      	mov	r7, r0
   2a48c:	4614      	mov	r4, r2
   2a48e:	460e      	mov	r6, r1
   2a490:	b921      	cbnz	r1, 2a49c <_realloc_r+0x14>
   2a492:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   2a496:	4611      	mov	r1, r2
   2a498:	f7ff bf9c 	b.w	2a3d4 <_malloc_r>
   2a49c:	b922      	cbnz	r2, 2a4a8 <_realloc_r+0x20>
   2a49e:	f7ff ff49 	bl	2a334 <_free_r>
   2a4a2:	4625      	mov	r5, r4
   2a4a4:	4628      	mov	r0, r5
   2a4a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2a4a8:	f000 f830 	bl	2a50c <_malloc_usable_size_r>
   2a4ac:	42a0      	cmp	r0, r4
   2a4ae:	d20f      	bcs.n	2a4d0 <_realloc_r+0x48>
   2a4b0:	4621      	mov	r1, r4
   2a4b2:	4638      	mov	r0, r7
   2a4b4:	f7ff ff8e 	bl	2a3d4 <_malloc_r>
   2a4b8:	4605      	mov	r5, r0
   2a4ba:	2800      	cmp	r0, #0
   2a4bc:	d0f2      	beq.n	2a4a4 <_realloc_r+0x1c>
   2a4be:	4631      	mov	r1, r6
   2a4c0:	4622      	mov	r2, r4
   2a4c2:	f7ff fb89 	bl	29bd8 <memcpy>
   2a4c6:	4631      	mov	r1, r6
   2a4c8:	4638      	mov	r0, r7
   2a4ca:	f7ff ff33 	bl	2a334 <_free_r>
   2a4ce:	e7e9      	b.n	2a4a4 <_realloc_r+0x1c>
   2a4d0:	4635      	mov	r5, r6
   2a4d2:	e7e7      	b.n	2a4a4 <_realloc_r+0x1c>

0002a4d4 <_sbrk_r>:
   2a4d4:	b538      	push	{r3, r4, r5, lr}
   2a4d6:	4d06      	ldr	r5, [pc, #24]	; (2a4f0 <_sbrk_r+0x1c>)
   2a4d8:	2300      	movs	r3, #0
   2a4da:	4604      	mov	r4, r0
   2a4dc:	4608      	mov	r0, r1
   2a4de:	602b      	str	r3, [r5, #0]
   2a4e0:	f000 f81e 	bl	2a520 <_sbrk>
   2a4e4:	1c43      	adds	r3, r0, #1
   2a4e6:	d102      	bne.n	2a4ee <_sbrk_r+0x1a>
   2a4e8:	682b      	ldr	r3, [r5, #0]
   2a4ea:	b103      	cbz	r3, 2a4ee <_sbrk_r+0x1a>
   2a4ec:	6023      	str	r3, [r4, #0]
   2a4ee:	bd38      	pop	{r3, r4, r5, pc}
   2a4f0:	20002338 	.word	0x20002338

0002a4f4 <__malloc_lock>:
   2a4f4:	4801      	ldr	r0, [pc, #4]	; (2a4fc <__malloc_lock+0x8>)
   2a4f6:	f000 b811 	b.w	2a51c <__retarget_lock_acquire_recursive>
   2a4fa:	bf00      	nop
   2a4fc:	20002340 	.word	0x20002340

0002a500 <__malloc_unlock>:
   2a500:	4801      	ldr	r0, [pc, #4]	; (2a508 <__malloc_unlock+0x8>)
   2a502:	f000 b80c 	b.w	2a51e <__retarget_lock_release_recursive>
   2a506:	bf00      	nop
   2a508:	20002340 	.word	0x20002340

0002a50c <_malloc_usable_size_r>:
   2a50c:	f851 3c04 	ldr.w	r3, [r1, #-4]
   2a510:	1f18      	subs	r0, r3, #4
   2a512:	2b00      	cmp	r3, #0
   2a514:	bfbc      	itt	lt
   2a516:	580b      	ldrlt	r3, [r1, r0]
   2a518:	18c0      	addlt	r0, r0, r3
   2a51a:	4770      	bx	lr

0002a51c <__retarget_lock_acquire_recursive>:
   2a51c:	4770      	bx	lr

0002a51e <__retarget_lock_release_recursive>:
   2a51e:	4770      	bx	lr

0002a520 <_sbrk>:
   2a520:	4a04      	ldr	r2, [pc, #16]	; (2a534 <_sbrk+0x14>)
   2a522:	4905      	ldr	r1, [pc, #20]	; (2a538 <_sbrk+0x18>)
   2a524:	6813      	ldr	r3, [r2, #0]
   2a526:	2b00      	cmp	r3, #0
   2a528:	bf08      	it	eq
   2a52a:	460b      	moveq	r3, r1
   2a52c:	4418      	add	r0, r3
   2a52e:	6010      	str	r0, [r2, #0]
   2a530:	4618      	mov	r0, r3
   2a532:	4770      	bx	lr
   2a534:	20002328 	.word	0x20002328
   2a538:	20002348 	.word	0x20002348

0002a53c <_exit>:
   2a53c:	e7fe      	b.n	2a53c <_exit>
   2a53e:	bf00      	nop

0002a540 <ceil>:
   2a540:	ec51 0b10 	vmov	r0, r1, d0
   2a544:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2a546:	f3c1 530a 	ubfx	r3, r1, #20, #11
   2a54a:	f2a3 35ff 	subw	r5, r3, #1023	; 0x3ff
   2a54e:	2d13      	cmp	r5, #19
   2a550:	ee10 6a10 	vmov	r6, s0
   2a554:	460c      	mov	r4, r1
   2a556:	dc32      	bgt.n	2a5be <ceil+0x7e>
   2a558:	2d00      	cmp	r5, #0
   2a55a:	db1e      	blt.n	2a59a <ceil+0x5a>
   2a55c:	4f36      	ldr	r7, [pc, #216]	; (2a638 <ceil+0xf8>)
   2a55e:	412f      	asrs	r7, r5
   2a560:	ea01 0307 	and.w	r3, r1, r7
   2a564:	4303      	orrs	r3, r0
   2a566:	d02f      	beq.n	2a5c8 <ceil+0x88>
   2a568:	a331      	add	r3, pc, #196	; (adr r3, 2a630 <ceil+0xf0>)
   2a56a:	e9d3 2300 	ldrd	r2, r3, [r3]
   2a56e:	f000 f997 	bl	2a8a0 <__adddf3>
   2a572:	2200      	movs	r2, #0
   2a574:	2300      	movs	r3, #0
   2a576:	f000 fbc7 	bl	2ad08 <__aeabi_dcmpgt>
   2a57a:	b148      	cbz	r0, 2a590 <ceil+0x50>
   2a57c:	2c00      	cmp	r4, #0
   2a57e:	dd04      	ble.n	2a58a <ceil+0x4a>
   2a580:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   2a584:	fa43 f505 	asr.w	r5, r3, r5
   2a588:	442c      	add	r4, r5
   2a58a:	ea24 0407 	bic.w	r4, r4, r7
   2a58e:	2600      	movs	r6, #0
   2a590:	4623      	mov	r3, r4
   2a592:	4632      	mov	r2, r6
   2a594:	ec43 2b10 	vmov	d0, r2, r3
   2a598:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2a59a:	a325      	add	r3, pc, #148	; (adr r3, 2a630 <ceil+0xf0>)
   2a59c:	e9d3 2300 	ldrd	r2, r3, [r3]
   2a5a0:	f000 f97e 	bl	2a8a0 <__adddf3>
   2a5a4:	2200      	movs	r2, #0
   2a5a6:	2300      	movs	r3, #0
   2a5a8:	f000 fbae 	bl	2ad08 <__aeabi_dcmpgt>
   2a5ac:	2800      	cmp	r0, #0
   2a5ae:	d0ef      	beq.n	2a590 <ceil+0x50>
   2a5b0:	2c00      	cmp	r4, #0
   2a5b2:	db39      	blt.n	2a628 <ceil+0xe8>
   2a5b4:	4326      	orrs	r6, r4
   2a5b6:	d033      	beq.n	2a620 <ceil+0xe0>
   2a5b8:	4c20      	ldr	r4, [pc, #128]	; (2a63c <ceil+0xfc>)
   2a5ba:	2600      	movs	r6, #0
   2a5bc:	e7e8      	b.n	2a590 <ceil+0x50>
   2a5be:	2d33      	cmp	r5, #51	; 0x33
   2a5c0:	dd05      	ble.n	2a5ce <ceil+0x8e>
   2a5c2:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
   2a5c6:	d023      	beq.n	2a610 <ceil+0xd0>
   2a5c8:	ec41 0b10 	vmov	d0, r0, r1
   2a5cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2a5ce:	f2a3 4313 	subw	r3, r3, #1043	; 0x413
   2a5d2:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   2a5d6:	40df      	lsrs	r7, r3
   2a5d8:	4207      	tst	r7, r0
   2a5da:	d0f5      	beq.n	2a5c8 <ceil+0x88>
   2a5dc:	a314      	add	r3, pc, #80	; (adr r3, 2a630 <ceil+0xf0>)
   2a5de:	e9d3 2300 	ldrd	r2, r3, [r3]
   2a5e2:	f000 f95d 	bl	2a8a0 <__adddf3>
   2a5e6:	2200      	movs	r2, #0
   2a5e8:	2300      	movs	r3, #0
   2a5ea:	f000 fb8d 	bl	2ad08 <__aeabi_dcmpgt>
   2a5ee:	2800      	cmp	r0, #0
   2a5f0:	d0ce      	beq.n	2a590 <ceil+0x50>
   2a5f2:	2c00      	cmp	r4, #0
   2a5f4:	dd09      	ble.n	2a60a <ceil+0xca>
   2a5f6:	2d14      	cmp	r5, #20
   2a5f8:	d014      	beq.n	2a624 <ceil+0xe4>
   2a5fa:	2301      	movs	r3, #1
   2a5fc:	f1c5 0534 	rsb	r5, r5, #52	; 0x34
   2a600:	fa03 f505 	lsl.w	r5, r3, r5
   2a604:	19ae      	adds	r6, r5, r6
   2a606:	bf28      	it	cs
   2a608:	18e4      	addcs	r4, r4, r3
   2a60a:	ea26 0607 	bic.w	r6, r6, r7
   2a60e:	e7bf      	b.n	2a590 <ceil+0x50>
   2a610:	ee10 2a10 	vmov	r2, s0
   2a614:	460b      	mov	r3, r1
   2a616:	f000 f943 	bl	2a8a0 <__adddf3>
   2a61a:	ec41 0b10 	vmov	d0, r0, r1
   2a61e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2a620:	4634      	mov	r4, r6
   2a622:	e7b5      	b.n	2a590 <ceil+0x50>
   2a624:	3401      	adds	r4, #1
   2a626:	e7f0      	b.n	2a60a <ceil+0xca>
   2a628:	2600      	movs	r6, #0
   2a62a:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
   2a62e:	e7af      	b.n	2a590 <ceil+0x50>
   2a630:	8800759c 	.word	0x8800759c
   2a634:	7e37e43c 	.word	0x7e37e43c
   2a638:	000fffff 	.word	0x000fffff
   2a63c:	3ff00000 	.word	0x3ff00000

0002a640 <__aeabi_dmul>:
   2a640:	b570      	push	{r4, r5, r6, lr}
   2a642:	f04f 0cff 	mov.w	ip, #255	; 0xff
   2a646:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   2a64a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   2a64e:	bf1d      	ittte	ne
   2a650:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   2a654:	ea94 0f0c 	teqne	r4, ip
   2a658:	ea95 0f0c 	teqne	r5, ip
   2a65c:	f000 f8de 	bleq	2a81c <__aeabi_dmul+0x1dc>
   2a660:	442c      	add	r4, r5
   2a662:	ea81 0603 	eor.w	r6, r1, r3
   2a666:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   2a66a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   2a66e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   2a672:	bf18      	it	ne
   2a674:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   2a678:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   2a67c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   2a680:	d038      	beq.n	2a6f4 <__aeabi_dmul+0xb4>
   2a682:	fba0 ce02 	umull	ip, lr, r0, r2
   2a686:	f04f 0500 	mov.w	r5, #0
   2a68a:	fbe1 e502 	umlal	lr, r5, r1, r2
   2a68e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   2a692:	fbe0 e503 	umlal	lr, r5, r0, r3
   2a696:	f04f 0600 	mov.w	r6, #0
   2a69a:	fbe1 5603 	umlal	r5, r6, r1, r3
   2a69e:	f09c 0f00 	teq	ip, #0
   2a6a2:	bf18      	it	ne
   2a6a4:	f04e 0e01 	orrne.w	lr, lr, #1
   2a6a8:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   2a6ac:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   2a6b0:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   2a6b4:	d204      	bcs.n	2a6c0 <__aeabi_dmul+0x80>
   2a6b6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   2a6ba:	416d      	adcs	r5, r5
   2a6bc:	eb46 0606 	adc.w	r6, r6, r6
   2a6c0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   2a6c4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   2a6c8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   2a6cc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   2a6d0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   2a6d4:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   2a6d8:	bf88      	it	hi
   2a6da:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   2a6de:	d81e      	bhi.n	2a71e <__aeabi_dmul+0xde>
   2a6e0:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   2a6e4:	bf08      	it	eq
   2a6e6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   2a6ea:	f150 0000 	adcs.w	r0, r0, #0
   2a6ee:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   2a6f2:	bd70      	pop	{r4, r5, r6, pc}
   2a6f4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   2a6f8:	ea46 0101 	orr.w	r1, r6, r1
   2a6fc:	ea40 0002 	orr.w	r0, r0, r2
   2a700:	ea81 0103 	eor.w	r1, r1, r3
   2a704:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   2a708:	bfc2      	ittt	gt
   2a70a:	ebd4 050c 	rsbsgt	r5, r4, ip
   2a70e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   2a712:	bd70      	popgt	{r4, r5, r6, pc}
   2a714:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   2a718:	f04f 0e00 	mov.w	lr, #0
   2a71c:	3c01      	subs	r4, #1
   2a71e:	f300 80ab 	bgt.w	2a878 <__aeabi_dmul+0x238>
   2a722:	f114 0f36 	cmn.w	r4, #54	; 0x36
   2a726:	bfde      	ittt	le
   2a728:	2000      	movle	r0, #0
   2a72a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   2a72e:	bd70      	pople	{r4, r5, r6, pc}
   2a730:	f1c4 0400 	rsb	r4, r4, #0
   2a734:	3c20      	subs	r4, #32
   2a736:	da35      	bge.n	2a7a4 <__aeabi_dmul+0x164>
   2a738:	340c      	adds	r4, #12
   2a73a:	dc1b      	bgt.n	2a774 <__aeabi_dmul+0x134>
   2a73c:	f104 0414 	add.w	r4, r4, #20
   2a740:	f1c4 0520 	rsb	r5, r4, #32
   2a744:	fa00 f305 	lsl.w	r3, r0, r5
   2a748:	fa20 f004 	lsr.w	r0, r0, r4
   2a74c:	fa01 f205 	lsl.w	r2, r1, r5
   2a750:	ea40 0002 	orr.w	r0, r0, r2
   2a754:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   2a758:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   2a75c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   2a760:	fa21 f604 	lsr.w	r6, r1, r4
   2a764:	eb42 0106 	adc.w	r1, r2, r6
   2a768:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   2a76c:	bf08      	it	eq
   2a76e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   2a772:	bd70      	pop	{r4, r5, r6, pc}
   2a774:	f1c4 040c 	rsb	r4, r4, #12
   2a778:	f1c4 0520 	rsb	r5, r4, #32
   2a77c:	fa00 f304 	lsl.w	r3, r0, r4
   2a780:	fa20 f005 	lsr.w	r0, r0, r5
   2a784:	fa01 f204 	lsl.w	r2, r1, r4
   2a788:	ea40 0002 	orr.w	r0, r0, r2
   2a78c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   2a790:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   2a794:	f141 0100 	adc.w	r1, r1, #0
   2a798:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   2a79c:	bf08      	it	eq
   2a79e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   2a7a2:	bd70      	pop	{r4, r5, r6, pc}
   2a7a4:	f1c4 0520 	rsb	r5, r4, #32
   2a7a8:	fa00 f205 	lsl.w	r2, r0, r5
   2a7ac:	ea4e 0e02 	orr.w	lr, lr, r2
   2a7b0:	fa20 f304 	lsr.w	r3, r0, r4
   2a7b4:	fa01 f205 	lsl.w	r2, r1, r5
   2a7b8:	ea43 0302 	orr.w	r3, r3, r2
   2a7bc:	fa21 f004 	lsr.w	r0, r1, r4
   2a7c0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   2a7c4:	fa21 f204 	lsr.w	r2, r1, r4
   2a7c8:	ea20 0002 	bic.w	r0, r0, r2
   2a7cc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   2a7d0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   2a7d4:	bf08      	it	eq
   2a7d6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   2a7da:	bd70      	pop	{r4, r5, r6, pc}
   2a7dc:	f094 0f00 	teq	r4, #0
   2a7e0:	d10f      	bne.n	2a802 <__aeabi_dmul+0x1c2>
   2a7e2:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   2a7e6:	0040      	lsls	r0, r0, #1
   2a7e8:	eb41 0101 	adc.w	r1, r1, r1
   2a7ec:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   2a7f0:	bf08      	it	eq
   2a7f2:	3c01      	subeq	r4, #1
   2a7f4:	d0f7      	beq.n	2a7e6 <__aeabi_dmul+0x1a6>
   2a7f6:	ea41 0106 	orr.w	r1, r1, r6
   2a7fa:	f095 0f00 	teq	r5, #0
   2a7fe:	bf18      	it	ne
   2a800:	4770      	bxne	lr
   2a802:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   2a806:	0052      	lsls	r2, r2, #1
   2a808:	eb43 0303 	adc.w	r3, r3, r3
   2a80c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   2a810:	bf08      	it	eq
   2a812:	3d01      	subeq	r5, #1
   2a814:	d0f7      	beq.n	2a806 <__aeabi_dmul+0x1c6>
   2a816:	ea43 0306 	orr.w	r3, r3, r6
   2a81a:	4770      	bx	lr
   2a81c:	ea94 0f0c 	teq	r4, ip
   2a820:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   2a824:	bf18      	it	ne
   2a826:	ea95 0f0c 	teqne	r5, ip
   2a82a:	d00c      	beq.n	2a846 <__aeabi_dmul+0x206>
   2a82c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   2a830:	bf18      	it	ne
   2a832:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   2a836:	d1d1      	bne.n	2a7dc <__aeabi_dmul+0x19c>
   2a838:	ea81 0103 	eor.w	r1, r1, r3
   2a83c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   2a840:	f04f 0000 	mov.w	r0, #0
   2a844:	bd70      	pop	{r4, r5, r6, pc}
   2a846:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   2a84a:	bf06      	itte	eq
   2a84c:	4610      	moveq	r0, r2
   2a84e:	4619      	moveq	r1, r3
   2a850:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   2a854:	d019      	beq.n	2a88a <__aeabi_dmul+0x24a>
   2a856:	ea94 0f0c 	teq	r4, ip
   2a85a:	d102      	bne.n	2a862 <__aeabi_dmul+0x222>
   2a85c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   2a860:	d113      	bne.n	2a88a <__aeabi_dmul+0x24a>
   2a862:	ea95 0f0c 	teq	r5, ip
   2a866:	d105      	bne.n	2a874 <__aeabi_dmul+0x234>
   2a868:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   2a86c:	bf1c      	itt	ne
   2a86e:	4610      	movne	r0, r2
   2a870:	4619      	movne	r1, r3
   2a872:	d10a      	bne.n	2a88a <__aeabi_dmul+0x24a>
   2a874:	ea81 0103 	eor.w	r1, r1, r3
   2a878:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   2a87c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   2a880:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   2a884:	f04f 0000 	mov.w	r0, #0
   2a888:	bd70      	pop	{r4, r5, r6, pc}
   2a88a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   2a88e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   2a892:	bd70      	pop	{r4, r5, r6, pc}

0002a894 <__aeabi_drsub>:
   2a894:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   2a898:	e002      	b.n	2a8a0 <__adddf3>
   2a89a:	bf00      	nop

0002a89c <__aeabi_dsub>:
   2a89c:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0002a8a0 <__adddf3>:
   2a8a0:	b530      	push	{r4, r5, lr}
   2a8a2:	ea4f 0441 	mov.w	r4, r1, lsl #1
   2a8a6:	ea4f 0543 	mov.w	r5, r3, lsl #1
   2a8aa:	ea94 0f05 	teq	r4, r5
   2a8ae:	bf08      	it	eq
   2a8b0:	ea90 0f02 	teqeq	r0, r2
   2a8b4:	bf1f      	itttt	ne
   2a8b6:	ea54 0c00 	orrsne.w	ip, r4, r0
   2a8ba:	ea55 0c02 	orrsne.w	ip, r5, r2
   2a8be:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   2a8c2:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   2a8c6:	f000 80e2 	beq.w	2aa8e <__adddf3+0x1ee>
   2a8ca:	ea4f 5454 	mov.w	r4, r4, lsr #21
   2a8ce:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   2a8d2:	bfb8      	it	lt
   2a8d4:	426d      	neglt	r5, r5
   2a8d6:	dd0c      	ble.n	2a8f2 <__adddf3+0x52>
   2a8d8:	442c      	add	r4, r5
   2a8da:	ea80 0202 	eor.w	r2, r0, r2
   2a8de:	ea81 0303 	eor.w	r3, r1, r3
   2a8e2:	ea82 0000 	eor.w	r0, r2, r0
   2a8e6:	ea83 0101 	eor.w	r1, r3, r1
   2a8ea:	ea80 0202 	eor.w	r2, r0, r2
   2a8ee:	ea81 0303 	eor.w	r3, r1, r3
   2a8f2:	2d36      	cmp	r5, #54	; 0x36
   2a8f4:	bf88      	it	hi
   2a8f6:	bd30      	pophi	{r4, r5, pc}
   2a8f8:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   2a8fc:	ea4f 3101 	mov.w	r1, r1, lsl #12
   2a900:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   2a904:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   2a908:	d002      	beq.n	2a910 <__adddf3+0x70>
   2a90a:	4240      	negs	r0, r0
   2a90c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   2a910:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   2a914:	ea4f 3303 	mov.w	r3, r3, lsl #12
   2a918:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   2a91c:	d002      	beq.n	2a924 <__adddf3+0x84>
   2a91e:	4252      	negs	r2, r2
   2a920:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   2a924:	ea94 0f05 	teq	r4, r5
   2a928:	f000 80a7 	beq.w	2aa7a <__adddf3+0x1da>
   2a92c:	f1a4 0401 	sub.w	r4, r4, #1
   2a930:	f1d5 0e20 	rsbs	lr, r5, #32
   2a934:	db0d      	blt.n	2a952 <__adddf3+0xb2>
   2a936:	fa02 fc0e 	lsl.w	ip, r2, lr
   2a93a:	fa22 f205 	lsr.w	r2, r2, r5
   2a93e:	1880      	adds	r0, r0, r2
   2a940:	f141 0100 	adc.w	r1, r1, #0
   2a944:	fa03 f20e 	lsl.w	r2, r3, lr
   2a948:	1880      	adds	r0, r0, r2
   2a94a:	fa43 f305 	asr.w	r3, r3, r5
   2a94e:	4159      	adcs	r1, r3
   2a950:	e00e      	b.n	2a970 <__adddf3+0xd0>
   2a952:	f1a5 0520 	sub.w	r5, r5, #32
   2a956:	f10e 0e20 	add.w	lr, lr, #32
   2a95a:	2a01      	cmp	r2, #1
   2a95c:	fa03 fc0e 	lsl.w	ip, r3, lr
   2a960:	bf28      	it	cs
   2a962:	f04c 0c02 	orrcs.w	ip, ip, #2
   2a966:	fa43 f305 	asr.w	r3, r3, r5
   2a96a:	18c0      	adds	r0, r0, r3
   2a96c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   2a970:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   2a974:	d507      	bpl.n	2a986 <__adddf3+0xe6>
   2a976:	f04f 0e00 	mov.w	lr, #0
   2a97a:	f1dc 0c00 	rsbs	ip, ip, #0
   2a97e:	eb7e 0000 	sbcs.w	r0, lr, r0
   2a982:	eb6e 0101 	sbc.w	r1, lr, r1
   2a986:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   2a98a:	d31b      	bcc.n	2a9c4 <__adddf3+0x124>
   2a98c:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   2a990:	d30c      	bcc.n	2a9ac <__adddf3+0x10c>
   2a992:	0849      	lsrs	r1, r1, #1
   2a994:	ea5f 0030 	movs.w	r0, r0, rrx
   2a998:	ea4f 0c3c 	mov.w	ip, ip, rrx
   2a99c:	f104 0401 	add.w	r4, r4, #1
   2a9a0:	ea4f 5244 	mov.w	r2, r4, lsl #21
   2a9a4:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   2a9a8:	f080 809a 	bcs.w	2aae0 <__adddf3+0x240>
   2a9ac:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   2a9b0:	bf08      	it	eq
   2a9b2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   2a9b6:	f150 0000 	adcs.w	r0, r0, #0
   2a9ba:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   2a9be:	ea41 0105 	orr.w	r1, r1, r5
   2a9c2:	bd30      	pop	{r4, r5, pc}
   2a9c4:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   2a9c8:	4140      	adcs	r0, r0
   2a9ca:	eb41 0101 	adc.w	r1, r1, r1
   2a9ce:	3c01      	subs	r4, #1
   2a9d0:	bf28      	it	cs
   2a9d2:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
   2a9d6:	d2e9      	bcs.n	2a9ac <__adddf3+0x10c>
   2a9d8:	f091 0f00 	teq	r1, #0
   2a9dc:	bf04      	itt	eq
   2a9de:	4601      	moveq	r1, r0
   2a9e0:	2000      	moveq	r0, #0
   2a9e2:	fab1 f381 	clz	r3, r1
   2a9e6:	bf08      	it	eq
   2a9e8:	3320      	addeq	r3, #32
   2a9ea:	f1a3 030b 	sub.w	r3, r3, #11
   2a9ee:	f1b3 0220 	subs.w	r2, r3, #32
   2a9f2:	da0c      	bge.n	2aa0e <__adddf3+0x16e>
   2a9f4:	320c      	adds	r2, #12
   2a9f6:	dd08      	ble.n	2aa0a <__adddf3+0x16a>
   2a9f8:	f102 0c14 	add.w	ip, r2, #20
   2a9fc:	f1c2 020c 	rsb	r2, r2, #12
   2aa00:	fa01 f00c 	lsl.w	r0, r1, ip
   2aa04:	fa21 f102 	lsr.w	r1, r1, r2
   2aa08:	e00c      	b.n	2aa24 <__adddf3+0x184>
   2aa0a:	f102 0214 	add.w	r2, r2, #20
   2aa0e:	bfd8      	it	le
   2aa10:	f1c2 0c20 	rsble	ip, r2, #32
   2aa14:	fa01 f102 	lsl.w	r1, r1, r2
   2aa18:	fa20 fc0c 	lsr.w	ip, r0, ip
   2aa1c:	bfdc      	itt	le
   2aa1e:	ea41 010c 	orrle.w	r1, r1, ip
   2aa22:	4090      	lslle	r0, r2
   2aa24:	1ae4      	subs	r4, r4, r3
   2aa26:	bfa2      	ittt	ge
   2aa28:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   2aa2c:	4329      	orrge	r1, r5
   2aa2e:	bd30      	popge	{r4, r5, pc}
   2aa30:	ea6f 0404 	mvn.w	r4, r4
   2aa34:	3c1f      	subs	r4, #31
   2aa36:	da1c      	bge.n	2aa72 <__adddf3+0x1d2>
   2aa38:	340c      	adds	r4, #12
   2aa3a:	dc0e      	bgt.n	2aa5a <__adddf3+0x1ba>
   2aa3c:	f104 0414 	add.w	r4, r4, #20
   2aa40:	f1c4 0220 	rsb	r2, r4, #32
   2aa44:	fa20 f004 	lsr.w	r0, r0, r4
   2aa48:	fa01 f302 	lsl.w	r3, r1, r2
   2aa4c:	ea40 0003 	orr.w	r0, r0, r3
   2aa50:	fa21 f304 	lsr.w	r3, r1, r4
   2aa54:	ea45 0103 	orr.w	r1, r5, r3
   2aa58:	bd30      	pop	{r4, r5, pc}
   2aa5a:	f1c4 040c 	rsb	r4, r4, #12
   2aa5e:	f1c4 0220 	rsb	r2, r4, #32
   2aa62:	fa20 f002 	lsr.w	r0, r0, r2
   2aa66:	fa01 f304 	lsl.w	r3, r1, r4
   2aa6a:	ea40 0003 	orr.w	r0, r0, r3
   2aa6e:	4629      	mov	r1, r5
   2aa70:	bd30      	pop	{r4, r5, pc}
   2aa72:	fa21 f004 	lsr.w	r0, r1, r4
   2aa76:	4629      	mov	r1, r5
   2aa78:	bd30      	pop	{r4, r5, pc}
   2aa7a:	f094 0f00 	teq	r4, #0
   2aa7e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   2aa82:	bf06      	itte	eq
   2aa84:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   2aa88:	3401      	addeq	r4, #1
   2aa8a:	3d01      	subne	r5, #1
   2aa8c:	e74e      	b.n	2a92c <__adddf3+0x8c>
   2aa8e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   2aa92:	bf18      	it	ne
   2aa94:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   2aa98:	d029      	beq.n	2aaee <__adddf3+0x24e>
   2aa9a:	ea94 0f05 	teq	r4, r5
   2aa9e:	bf08      	it	eq
   2aaa0:	ea90 0f02 	teqeq	r0, r2
   2aaa4:	d005      	beq.n	2aab2 <__adddf3+0x212>
   2aaa6:	ea54 0c00 	orrs.w	ip, r4, r0
   2aaaa:	bf04      	itt	eq
   2aaac:	4619      	moveq	r1, r3
   2aaae:	4610      	moveq	r0, r2
   2aab0:	bd30      	pop	{r4, r5, pc}
   2aab2:	ea91 0f03 	teq	r1, r3
   2aab6:	bf1e      	ittt	ne
   2aab8:	2100      	movne	r1, #0
   2aaba:	2000      	movne	r0, #0
   2aabc:	bd30      	popne	{r4, r5, pc}
   2aabe:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   2aac2:	d105      	bne.n	2aad0 <__adddf3+0x230>
   2aac4:	0040      	lsls	r0, r0, #1
   2aac6:	4149      	adcs	r1, r1
   2aac8:	bf28      	it	cs
   2aaca:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   2aace:	bd30      	pop	{r4, r5, pc}
   2aad0:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   2aad4:	bf3c      	itt	cc
   2aad6:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   2aada:	bd30      	popcc	{r4, r5, pc}
   2aadc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   2aae0:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   2aae4:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   2aae8:	f04f 0000 	mov.w	r0, #0
   2aaec:	bd30      	pop	{r4, r5, pc}
   2aaee:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   2aaf2:	bf1a      	itte	ne
   2aaf4:	4619      	movne	r1, r3
   2aaf6:	4610      	movne	r0, r2
   2aaf8:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   2aafc:	bf1c      	itt	ne
   2aafe:	460b      	movne	r3, r1
   2ab00:	4602      	movne	r2, r0
   2ab02:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   2ab06:	bf06      	itte	eq
   2ab08:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   2ab0c:	ea91 0f03 	teqeq	r1, r3
   2ab10:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   2ab14:	bd30      	pop	{r4, r5, pc}
   2ab16:	bf00      	nop

0002ab18 <__aeabi_ui2d>:
   2ab18:	f090 0f00 	teq	r0, #0
   2ab1c:	bf04      	itt	eq
   2ab1e:	2100      	moveq	r1, #0
   2ab20:	4770      	bxeq	lr
   2ab22:	b530      	push	{r4, r5, lr}
   2ab24:	f44f 6480 	mov.w	r4, #1024	; 0x400
   2ab28:	f104 0432 	add.w	r4, r4, #50	; 0x32
   2ab2c:	f04f 0500 	mov.w	r5, #0
   2ab30:	f04f 0100 	mov.w	r1, #0
   2ab34:	e750      	b.n	2a9d8 <__adddf3+0x138>
   2ab36:	bf00      	nop

0002ab38 <__aeabi_i2d>:
   2ab38:	f090 0f00 	teq	r0, #0
   2ab3c:	bf04      	itt	eq
   2ab3e:	2100      	moveq	r1, #0
   2ab40:	4770      	bxeq	lr
   2ab42:	b530      	push	{r4, r5, lr}
   2ab44:	f44f 6480 	mov.w	r4, #1024	; 0x400
   2ab48:	f104 0432 	add.w	r4, r4, #50	; 0x32
   2ab4c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   2ab50:	bf48      	it	mi
   2ab52:	4240      	negmi	r0, r0
   2ab54:	f04f 0100 	mov.w	r1, #0
   2ab58:	e73e      	b.n	2a9d8 <__adddf3+0x138>
   2ab5a:	bf00      	nop

0002ab5c <__aeabi_f2d>:
   2ab5c:	0042      	lsls	r2, r0, #1
   2ab5e:	ea4f 01e2 	mov.w	r1, r2, asr #3
   2ab62:	ea4f 0131 	mov.w	r1, r1, rrx
   2ab66:	ea4f 7002 	mov.w	r0, r2, lsl #28
   2ab6a:	bf1f      	itttt	ne
   2ab6c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   2ab70:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   2ab74:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   2ab78:	4770      	bxne	lr
   2ab7a:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   2ab7e:	bf08      	it	eq
   2ab80:	4770      	bxeq	lr
   2ab82:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
   2ab86:	bf04      	itt	eq
   2ab88:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
   2ab8c:	4770      	bxeq	lr
   2ab8e:	b530      	push	{r4, r5, lr}
   2ab90:	f44f 7460 	mov.w	r4, #896	; 0x380
   2ab94:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   2ab98:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   2ab9c:	e71c      	b.n	2a9d8 <__adddf3+0x138>
   2ab9e:	bf00      	nop

0002aba0 <__aeabi_ul2d>:
   2aba0:	ea50 0201 	orrs.w	r2, r0, r1
   2aba4:	bf08      	it	eq
   2aba6:	4770      	bxeq	lr
   2aba8:	b530      	push	{r4, r5, lr}
   2abaa:	f04f 0500 	mov.w	r5, #0
   2abae:	e00a      	b.n	2abc6 <__aeabi_l2d+0x16>

0002abb0 <__aeabi_l2d>:
   2abb0:	ea50 0201 	orrs.w	r2, r0, r1
   2abb4:	bf08      	it	eq
   2abb6:	4770      	bxeq	lr
   2abb8:	b530      	push	{r4, r5, lr}
   2abba:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   2abbe:	d502      	bpl.n	2abc6 <__aeabi_l2d+0x16>
   2abc0:	4240      	negs	r0, r0
   2abc2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   2abc6:	f44f 6480 	mov.w	r4, #1024	; 0x400
   2abca:	f104 0432 	add.w	r4, r4, #50	; 0x32
   2abce:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   2abd2:	f43f aed8 	beq.w	2a986 <__adddf3+0xe6>
   2abd6:	f04f 0203 	mov.w	r2, #3
   2abda:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   2abde:	bf18      	it	ne
   2abe0:	3203      	addne	r2, #3
   2abe2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   2abe6:	bf18      	it	ne
   2abe8:	3203      	addne	r2, #3
   2abea:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   2abee:	f1c2 0320 	rsb	r3, r2, #32
   2abf2:	fa00 fc03 	lsl.w	ip, r0, r3
   2abf6:	fa20 f002 	lsr.w	r0, r0, r2
   2abfa:	fa01 fe03 	lsl.w	lr, r1, r3
   2abfe:	ea40 000e 	orr.w	r0, r0, lr
   2ac02:	fa21 f102 	lsr.w	r1, r1, r2
   2ac06:	4414      	add	r4, r2
   2ac08:	e6bd      	b.n	2a986 <__adddf3+0xe6>
   2ac0a:	bf00      	nop

0002ac0c <__gedf2>:
   2ac0c:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
   2ac10:	e006      	b.n	2ac20 <__cmpdf2+0x4>
   2ac12:	bf00      	nop

0002ac14 <__ledf2>:
   2ac14:	f04f 0c01 	mov.w	ip, #1
   2ac18:	e002      	b.n	2ac20 <__cmpdf2+0x4>
   2ac1a:	bf00      	nop

0002ac1c <__cmpdf2>:
   2ac1c:	f04f 0c01 	mov.w	ip, #1
   2ac20:	f84d cd04 	str.w	ip, [sp, #-4]!
   2ac24:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   2ac28:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   2ac2c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   2ac30:	bf18      	it	ne
   2ac32:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
   2ac36:	d01b      	beq.n	2ac70 <__cmpdf2+0x54>
   2ac38:	b001      	add	sp, #4
   2ac3a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
   2ac3e:	bf0c      	ite	eq
   2ac40:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
   2ac44:	ea91 0f03 	teqne	r1, r3
   2ac48:	bf02      	ittt	eq
   2ac4a:	ea90 0f02 	teqeq	r0, r2
   2ac4e:	2000      	moveq	r0, #0
   2ac50:	4770      	bxeq	lr
   2ac52:	f110 0f00 	cmn.w	r0, #0
   2ac56:	ea91 0f03 	teq	r1, r3
   2ac5a:	bf58      	it	pl
   2ac5c:	4299      	cmppl	r1, r3
   2ac5e:	bf08      	it	eq
   2ac60:	4290      	cmpeq	r0, r2
   2ac62:	bf2c      	ite	cs
   2ac64:	17d8      	asrcs	r0, r3, #31
   2ac66:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
   2ac6a:	f040 0001 	orr.w	r0, r0, #1
   2ac6e:	4770      	bx	lr
   2ac70:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   2ac74:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   2ac78:	d102      	bne.n	2ac80 <__cmpdf2+0x64>
   2ac7a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   2ac7e:	d107      	bne.n	2ac90 <__cmpdf2+0x74>
   2ac80:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   2ac84:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   2ac88:	d1d6      	bne.n	2ac38 <__cmpdf2+0x1c>
   2ac8a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   2ac8e:	d0d3      	beq.n	2ac38 <__cmpdf2+0x1c>
   2ac90:	f85d 0b04 	ldr.w	r0, [sp], #4
   2ac94:	4770      	bx	lr
   2ac96:	bf00      	nop

0002ac98 <__aeabi_cdrcmple>:
   2ac98:	4684      	mov	ip, r0
   2ac9a:	4610      	mov	r0, r2
   2ac9c:	4662      	mov	r2, ip
   2ac9e:	468c      	mov	ip, r1
   2aca0:	4619      	mov	r1, r3
   2aca2:	4663      	mov	r3, ip
   2aca4:	e000      	b.n	2aca8 <__aeabi_cdcmpeq>
   2aca6:	bf00      	nop

0002aca8 <__aeabi_cdcmpeq>:
   2aca8:	b501      	push	{r0, lr}
   2acaa:	f7ff ffb7 	bl	2ac1c <__cmpdf2>
   2acae:	2800      	cmp	r0, #0
   2acb0:	bf48      	it	mi
   2acb2:	f110 0f00 	cmnmi.w	r0, #0
   2acb6:	bd01      	pop	{r0, pc}

0002acb8 <__aeabi_dcmpeq>:
   2acb8:	f84d ed08 	str.w	lr, [sp, #-8]!
   2acbc:	f7ff fff4 	bl	2aca8 <__aeabi_cdcmpeq>
   2acc0:	bf0c      	ite	eq
   2acc2:	2001      	moveq	r0, #1
   2acc4:	2000      	movne	r0, #0
   2acc6:	f85d fb08 	ldr.w	pc, [sp], #8
   2acca:	bf00      	nop

0002accc <__aeabi_dcmplt>:
   2accc:	f84d ed08 	str.w	lr, [sp, #-8]!
   2acd0:	f7ff ffea 	bl	2aca8 <__aeabi_cdcmpeq>
   2acd4:	bf34      	ite	cc
   2acd6:	2001      	movcc	r0, #1
   2acd8:	2000      	movcs	r0, #0
   2acda:	f85d fb08 	ldr.w	pc, [sp], #8
   2acde:	bf00      	nop

0002ace0 <__aeabi_dcmple>:
   2ace0:	f84d ed08 	str.w	lr, [sp, #-8]!
   2ace4:	f7ff ffe0 	bl	2aca8 <__aeabi_cdcmpeq>
   2ace8:	bf94      	ite	ls
   2acea:	2001      	movls	r0, #1
   2acec:	2000      	movhi	r0, #0
   2acee:	f85d fb08 	ldr.w	pc, [sp], #8
   2acf2:	bf00      	nop

0002acf4 <__aeabi_dcmpge>:
   2acf4:	f84d ed08 	str.w	lr, [sp, #-8]!
   2acf8:	f7ff ffce 	bl	2ac98 <__aeabi_cdrcmple>
   2acfc:	bf94      	ite	ls
   2acfe:	2001      	movls	r0, #1
   2ad00:	2000      	movhi	r0, #0
   2ad02:	f85d fb08 	ldr.w	pc, [sp], #8
   2ad06:	bf00      	nop

0002ad08 <__aeabi_dcmpgt>:
   2ad08:	f84d ed08 	str.w	lr, [sp, #-8]!
   2ad0c:	f7ff ffc4 	bl	2ac98 <__aeabi_cdrcmple>
   2ad10:	bf34      	ite	cc
   2ad12:	2001      	movcc	r0, #1
   2ad14:	2000      	movcs	r0, #0
   2ad16:	f85d fb08 	ldr.w	pc, [sp], #8
   2ad1a:	bf00      	nop

0002ad1c <__aeabi_d2uiz>:
   2ad1c:	004a      	lsls	r2, r1, #1
   2ad1e:	d211      	bcs.n	2ad44 <__aeabi_d2uiz+0x28>
   2ad20:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   2ad24:	d211      	bcs.n	2ad4a <__aeabi_d2uiz+0x2e>
   2ad26:	d50d      	bpl.n	2ad44 <__aeabi_d2uiz+0x28>
   2ad28:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   2ad2c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   2ad30:	d40e      	bmi.n	2ad50 <__aeabi_d2uiz+0x34>
   2ad32:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   2ad36:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   2ad3a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   2ad3e:	fa23 f002 	lsr.w	r0, r3, r2
   2ad42:	4770      	bx	lr
   2ad44:	f04f 0000 	mov.w	r0, #0
   2ad48:	4770      	bx	lr
   2ad4a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   2ad4e:	d102      	bne.n	2ad56 <__aeabi_d2uiz+0x3a>
   2ad50:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2ad54:	4770      	bx	lr
   2ad56:	f04f 0000 	mov.w	r0, #0
   2ad5a:	4770      	bx	lr

0002ad5c <selfrel_offset31>:
   2ad5c:	6803      	ldr	r3, [r0, #0]
   2ad5e:	005a      	lsls	r2, r3, #1
   2ad60:	bf4c      	ite	mi
   2ad62:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
   2ad66:	f023 4300 	bicpl.w	r3, r3, #2147483648	; 0x80000000
   2ad6a:	4418      	add	r0, r3
   2ad6c:	4770      	bx	lr
   2ad6e:	bf00      	nop

0002ad70 <search_EIT_table>:
   2ad70:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2ad74:	b329      	cbz	r1, 2adc2 <search_EIT_table+0x52>
   2ad76:	1e4f      	subs	r7, r1, #1
   2ad78:	4604      	mov	r4, r0
   2ad7a:	4615      	mov	r5, r2
   2ad7c:	463e      	mov	r6, r7
   2ad7e:	f04f 0800 	mov.w	r8, #0
   2ad82:	eb08 0106 	add.w	r1, r8, r6
   2ad86:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
   2ad8a:	1049      	asrs	r1, r1, #1
   2ad8c:	eb04 09c1 	add.w	r9, r4, r1, lsl #3
   2ad90:	4648      	mov	r0, r9
   2ad92:	f7ff ffe3 	bl	2ad5c <selfrel_offset31>
   2ad96:	4603      	mov	r3, r0
   2ad98:	00c8      	lsls	r0, r1, #3
   2ad9a:	3008      	adds	r0, #8
   2ad9c:	428f      	cmp	r7, r1
   2ad9e:	4420      	add	r0, r4
   2ada0:	d009      	beq.n	2adb6 <search_EIT_table+0x46>
   2ada2:	42ab      	cmp	r3, r5
   2ada4:	d809      	bhi.n	2adba <search_EIT_table+0x4a>
   2ada6:	f7ff ffd9 	bl	2ad5c <selfrel_offset31>
   2adaa:	3801      	subs	r0, #1
   2adac:	42a8      	cmp	r0, r5
   2adae:	d20a      	bcs.n	2adc6 <search_EIT_table+0x56>
   2adb0:	f101 0801 	add.w	r8, r1, #1
   2adb4:	e7e5      	b.n	2ad82 <search_EIT_table+0x12>
   2adb6:	42ab      	cmp	r3, r5
   2adb8:	d905      	bls.n	2adc6 <search_EIT_table+0x56>
   2adba:	4588      	cmp	r8, r1
   2adbc:	d001      	beq.n	2adc2 <search_EIT_table+0x52>
   2adbe:	1e4e      	subs	r6, r1, #1
   2adc0:	e7df      	b.n	2ad82 <search_EIT_table+0x12>
   2adc2:	f04f 0900 	mov.w	r9, #0
   2adc6:	4648      	mov	r0, r9
   2adc8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0002adcc <__gnu_unwind_get_pr_addr>:
   2adcc:	2801      	cmp	r0, #1
   2adce:	d007      	beq.n	2ade0 <__gnu_unwind_get_pr_addr+0x14>
   2add0:	2802      	cmp	r0, #2
   2add2:	d007      	beq.n	2ade4 <__gnu_unwind_get_pr_addr+0x18>
   2add4:	4b04      	ldr	r3, [pc, #16]	; (2ade8 <__gnu_unwind_get_pr_addr+0x1c>)
   2add6:	2800      	cmp	r0, #0
   2add8:	bf0c      	ite	eq
   2adda:	4618      	moveq	r0, r3
   2addc:	2000      	movne	r0, #0
   2adde:	4770      	bx	lr
   2ade0:	4802      	ldr	r0, [pc, #8]	; (2adec <__gnu_unwind_get_pr_addr+0x20>)
   2ade2:	4770      	bx	lr
   2ade4:	4802      	ldr	r0, [pc, #8]	; (2adf0 <__gnu_unwind_get_pr_addr+0x24>)
   2ade6:	4770      	bx	lr
   2ade8:	0002b491 	.word	0x0002b491
   2adec:	0002b495 	.word	0x0002b495
   2adf0:	0002b499 	.word	0x0002b499

0002adf4 <get_eit_entry>:
   2adf4:	b530      	push	{r4, r5, lr}
   2adf6:	4b23      	ldr	r3, [pc, #140]	; (2ae84 <get_eit_entry+0x90>)
   2adf8:	b083      	sub	sp, #12
   2adfa:	4604      	mov	r4, r0
   2adfc:	1e8d      	subs	r5, r1, #2
   2adfe:	b33b      	cbz	r3, 2ae50 <get_eit_entry+0x5c>
   2ae00:	a901      	add	r1, sp, #4
   2ae02:	4628      	mov	r0, r5
   2ae04:	f3af 8000 	nop.w
   2ae08:	b1e8      	cbz	r0, 2ae46 <get_eit_entry+0x52>
   2ae0a:	9901      	ldr	r1, [sp, #4]
   2ae0c:	462a      	mov	r2, r5
   2ae0e:	f7ff ffaf 	bl	2ad70 <search_EIT_table>
   2ae12:	4601      	mov	r1, r0
   2ae14:	b1b8      	cbz	r0, 2ae46 <get_eit_entry+0x52>
   2ae16:	f7ff ffa1 	bl	2ad5c <selfrel_offset31>
   2ae1a:	684b      	ldr	r3, [r1, #4]
   2ae1c:	64a0      	str	r0, [r4, #72]	; 0x48
   2ae1e:	2b01      	cmp	r3, #1
   2ae20:	d02b      	beq.n	2ae7a <get_eit_entry+0x86>
   2ae22:	2b00      	cmp	r3, #0
   2ae24:	f101 0004 	add.w	r0, r1, #4
   2ae28:	db23      	blt.n	2ae72 <get_eit_entry+0x7e>
   2ae2a:	f7ff ff97 	bl	2ad5c <selfrel_offset31>
   2ae2e:	2300      	movs	r3, #0
   2ae30:	e9c4 0313 	strd	r0, r3, [r4, #76]	; 0x4c
   2ae34:	6803      	ldr	r3, [r0, #0]
   2ae36:	2b00      	cmp	r3, #0
   2ae38:	db10      	blt.n	2ae5c <get_eit_entry+0x68>
   2ae3a:	f7ff ff8f 	bl	2ad5c <selfrel_offset31>
   2ae3e:	6120      	str	r0, [r4, #16]
   2ae40:	2000      	movs	r0, #0
   2ae42:	b003      	add	sp, #12
   2ae44:	bd30      	pop	{r4, r5, pc}
   2ae46:	2300      	movs	r3, #0
   2ae48:	2009      	movs	r0, #9
   2ae4a:	6123      	str	r3, [r4, #16]
   2ae4c:	b003      	add	sp, #12
   2ae4e:	bd30      	pop	{r4, r5, pc}
   2ae50:	490d      	ldr	r1, [pc, #52]	; (2ae88 <get_eit_entry+0x94>)
   2ae52:	480e      	ldr	r0, [pc, #56]	; (2ae8c <get_eit_entry+0x98>)
   2ae54:	1a09      	subs	r1, r1, r0
   2ae56:	10c9      	asrs	r1, r1, #3
   2ae58:	9101      	str	r1, [sp, #4]
   2ae5a:	e7d7      	b.n	2ae0c <get_eit_entry+0x18>
   2ae5c:	f3c3 6003 	ubfx	r0, r3, #24, #4
   2ae60:	f7ff ffb4 	bl	2adcc <__gnu_unwind_get_pr_addr>
   2ae64:	2800      	cmp	r0, #0
   2ae66:	6120      	str	r0, [r4, #16]
   2ae68:	bf14      	ite	ne
   2ae6a:	2000      	movne	r0, #0
   2ae6c:	2009      	moveq	r0, #9
   2ae6e:	b003      	add	sp, #12
   2ae70:	bd30      	pop	{r4, r5, pc}
   2ae72:	2301      	movs	r3, #1
   2ae74:	e9c4 0313 	strd	r0, r3, [r4, #76]	; 0x4c
   2ae78:	e7dc      	b.n	2ae34 <get_eit_entry+0x40>
   2ae7a:	2300      	movs	r3, #0
   2ae7c:	6123      	str	r3, [r4, #16]
   2ae7e:	2005      	movs	r0, #5
   2ae80:	e7df      	b.n	2ae42 <get_eit_entry+0x4e>
   2ae82:	bf00      	nop
   2ae84:	00000000 	.word	0x00000000
   2ae88:	0002bf4c 	.word	0x0002bf4c
   2ae8c:	0002be0c 	.word	0x0002be0c

0002ae90 <restore_non_core_regs>:
   2ae90:	6803      	ldr	r3, [r0, #0]
   2ae92:	07da      	lsls	r2, r3, #31
   2ae94:	b510      	push	{r4, lr}
   2ae96:	4604      	mov	r4, r0
   2ae98:	d406      	bmi.n	2aea8 <restore_non_core_regs+0x18>
   2ae9a:	079b      	lsls	r3, r3, #30
   2ae9c:	f100 0048 	add.w	r0, r0, #72	; 0x48
   2aea0:	d509      	bpl.n	2aeb6 <restore_non_core_regs+0x26>
   2aea2:	f000 fc4b 	bl	2b73c <__gnu_Unwind_Restore_VFP_D>
   2aea6:	6823      	ldr	r3, [r4, #0]
   2aea8:	0759      	lsls	r1, r3, #29
   2aeaa:	d509      	bpl.n	2aec0 <restore_non_core_regs+0x30>
   2aeac:	071a      	lsls	r2, r3, #28
   2aeae:	d50e      	bpl.n	2aece <restore_non_core_regs+0x3e>
   2aeb0:	06db      	lsls	r3, r3, #27
   2aeb2:	d513      	bpl.n	2aedc <restore_non_core_regs+0x4c>
   2aeb4:	bd10      	pop	{r4, pc}
   2aeb6:	f000 fc39 	bl	2b72c <__gnu_Unwind_Restore_VFP>
   2aeba:	6823      	ldr	r3, [r4, #0]
   2aebc:	0759      	lsls	r1, r3, #29
   2aebe:	d4f5      	bmi.n	2aeac <restore_non_core_regs+0x1c>
   2aec0:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
   2aec4:	f000 fc42 	bl	2b74c <__gnu_Unwind_Restore_VFP_D_16_to_31>
   2aec8:	6823      	ldr	r3, [r4, #0]
   2aeca:	071a      	lsls	r2, r3, #28
   2aecc:	d4f0      	bmi.n	2aeb0 <restore_non_core_regs+0x20>
   2aece:	f504 70a8 	add.w	r0, r4, #336	; 0x150
   2aed2:	f000 fc43 	bl	2b75c <__gnu_Unwind_Restore_WMMXD>
   2aed6:	6823      	ldr	r3, [r4, #0]
   2aed8:	06db      	lsls	r3, r3, #27
   2aeda:	d4eb      	bmi.n	2aeb4 <restore_non_core_regs+0x24>
   2aedc:	f504 70e8 	add.w	r0, r4, #464	; 0x1d0
   2aee0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2aee4:	f000 bc7e 	b.w	2b7e4 <__gnu_Unwind_Restore_WMMXC>

0002aee8 <_Unwind_decode_typeinfo_ptr.isra.0>:
   2aee8:	4603      	mov	r3, r0
   2aeea:	6800      	ldr	r0, [r0, #0]
   2aeec:	b100      	cbz	r0, 2aef0 <_Unwind_decode_typeinfo_ptr.isra.0+0x8>
   2aeee:	4418      	add	r0, r3
   2aef0:	4770      	bx	lr
   2aef2:	bf00      	nop

0002aef4 <__gnu_unwind_24bit.isra.0>:
   2aef4:	2009      	movs	r0, #9
   2aef6:	4770      	bx	lr

0002aef8 <_Unwind_DebugHook>:
   2aef8:	4770      	bx	lr
   2aefa:	bf00      	nop

0002aefc <unwind_phase2>:
   2aefc:	b570      	push	{r4, r5, r6, lr}
   2aefe:	4604      	mov	r4, r0
   2af00:	460e      	mov	r6, r1
   2af02:	6c31      	ldr	r1, [r6, #64]	; 0x40
   2af04:	4620      	mov	r0, r4
   2af06:	f7ff ff75 	bl	2adf4 <get_eit_entry>
   2af0a:	4605      	mov	r5, r0
   2af0c:	b988      	cbnz	r0, 2af32 <unwind_phase2+0x36>
   2af0e:	6c33      	ldr	r3, [r6, #64]	; 0x40
   2af10:	6163      	str	r3, [r4, #20]
   2af12:	4632      	mov	r2, r6
   2af14:	6923      	ldr	r3, [r4, #16]
   2af16:	4621      	mov	r1, r4
   2af18:	2001      	movs	r0, #1
   2af1a:	4798      	blx	r3
   2af1c:	2808      	cmp	r0, #8
   2af1e:	d0f0      	beq.n	2af02 <unwind_phase2+0x6>
   2af20:	2807      	cmp	r0, #7
   2af22:	d106      	bne.n	2af32 <unwind_phase2+0x36>
   2af24:	4628      	mov	r0, r5
   2af26:	6c31      	ldr	r1, [r6, #64]	; 0x40
   2af28:	f7ff ffe6 	bl	2aef8 <_Unwind_DebugHook>
   2af2c:	1d30      	adds	r0, r6, #4
   2af2e:	f000 fbf1 	bl	2b714 <__restore_core_regs>
   2af32:	f000 fe65 	bl	2bc00 <abort>
   2af36:	bf00      	nop

0002af38 <unwind_phase2_forced>:
   2af38:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2af3c:	1d0d      	adds	r5, r1, #4
   2af3e:	4606      	mov	r6, r0
   2af40:	4614      	mov	r4, r2
   2af42:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   2af44:	f5ad 7d72 	sub.w	sp, sp, #968	; 0x3c8
   2af48:	f10d 0c0c 	add.w	ip, sp, #12
   2af4c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   2af50:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   2af52:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   2af56:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   2af58:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   2af5c:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   2af60:	ad02      	add	r5, sp, #8
   2af62:	68f7      	ldr	r7, [r6, #12]
   2af64:	f8d6 8018 	ldr.w	r8, [r6, #24]
   2af68:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
   2af6c:	2300      	movs	r3, #0
   2af6e:	602b      	str	r3, [r5, #0]
   2af70:	e021      	b.n	2afb6 <unwind_phase2_forced+0x7e>
   2af72:	6c2b      	ldr	r3, [r5, #64]	; 0x40
   2af74:	6173      	str	r3, [r6, #20]
   2af76:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
   2af7a:	4629      	mov	r1, r5
   2af7c:	a87a      	add	r0, sp, #488	; 0x1e8
   2af7e:	f7fe fe2b 	bl	29bd8 <memcpy>
   2af82:	6933      	ldr	r3, [r6, #16]
   2af84:	aa7a      	add	r2, sp, #488	; 0x1e8
   2af86:	4631      	mov	r1, r6
   2af88:	4650      	mov	r0, sl
   2af8a:	4798      	blx	r3
   2af8c:	9b88      	ldr	r3, [sp, #544]	; 0x220
   2af8e:	e9cd 5800 	strd	r5, r8, [sp]
   2af92:	4621      	mov	r1, r4
   2af94:	646b      	str	r3, [r5, #68]	; 0x44
   2af96:	4681      	mov	r9, r0
   2af98:	4633      	mov	r3, r6
   2af9a:	4632      	mov	r2, r6
   2af9c:	2001      	movs	r0, #1
   2af9e:	47b8      	blx	r7
   2afa0:	4604      	mov	r4, r0
   2afa2:	b9e8      	cbnz	r0, 2afe0 <unwind_phase2_forced+0xa8>
   2afa4:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
   2afa8:	a97a      	add	r1, sp, #488	; 0x1e8
   2afaa:	4628      	mov	r0, r5
   2afac:	f7fe fe14 	bl	29bd8 <memcpy>
   2afb0:	f1b9 0f08 	cmp.w	r9, #8
   2afb4:	d11b      	bne.n	2afee <unwind_phase2_forced+0xb6>
   2afb6:	6c29      	ldr	r1, [r5, #64]	; 0x40
   2afb8:	4630      	mov	r0, r6
   2afba:	f7ff ff1b 	bl	2adf4 <get_eit_entry>
   2afbe:	3409      	adds	r4, #9
   2afc0:	fa5f fa84 	uxtb.w	sl, r4
   2afc4:	4681      	mov	r9, r0
   2afc6:	2800      	cmp	r0, #0
   2afc8:	d0d3      	beq.n	2af72 <unwind_phase2_forced+0x3a>
   2afca:	6bab      	ldr	r3, [r5, #56]	; 0x38
   2afcc:	f04a 0110 	orr.w	r1, sl, #16
   2afd0:	e9cd 5800 	strd	r5, r8, [sp]
   2afd4:	4632      	mov	r2, r6
   2afd6:	646b      	str	r3, [r5, #68]	; 0x44
   2afd8:	2001      	movs	r0, #1
   2afda:	4633      	mov	r3, r6
   2afdc:	47b8      	blx	r7
   2afde:	b108      	cbz	r0, 2afe4 <unwind_phase2_forced+0xac>
   2afe0:	f04f 0909 	mov.w	r9, #9
   2afe4:	4648      	mov	r0, r9
   2afe6:	f50d 7d72 	add.w	sp, sp, #968	; 0x3c8
   2afea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2afee:	f1b9 0f07 	cmp.w	r9, #7
   2aff2:	d1f5      	bne.n	2afe0 <unwind_phase2_forced+0xa8>
   2aff4:	4620      	mov	r0, r4
   2aff6:	6c29      	ldr	r1, [r5, #64]	; 0x40
   2aff8:	f7ff ff7e 	bl	2aef8 <_Unwind_DebugHook>
   2affc:	a803      	add	r0, sp, #12
   2affe:	f000 fb89 	bl	2b714 <__restore_core_regs>
   2b002:	bf00      	nop

0002b004 <_Unwind_GetCFA>:
   2b004:	6c40      	ldr	r0, [r0, #68]	; 0x44
   2b006:	4770      	bx	lr

0002b008 <__gnu_Unwind_RaiseException>:
   2b008:	b5f0      	push	{r4, r5, r6, r7, lr}
   2b00a:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
   2b00c:	640b      	str	r3, [r1, #64]	; 0x40
   2b00e:	1d0e      	adds	r6, r1, #4
   2b010:	460f      	mov	r7, r1
   2b012:	4605      	mov	r5, r0
   2b014:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   2b016:	b0f9      	sub	sp, #484	; 0x1e4
   2b018:	ac01      	add	r4, sp, #4
   2b01a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   2b01c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   2b01e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   2b020:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   2b022:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   2b024:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
   2b028:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2b02c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
   2b030:	9600      	str	r6, [sp, #0]
   2b032:	e006      	b.n	2b042 <__gnu_Unwind_RaiseException+0x3a>
   2b034:	692b      	ldr	r3, [r5, #16]
   2b036:	466a      	mov	r2, sp
   2b038:	4629      	mov	r1, r5
   2b03a:	4798      	blx	r3
   2b03c:	2808      	cmp	r0, #8
   2b03e:	4604      	mov	r4, r0
   2b040:	d108      	bne.n	2b054 <__gnu_Unwind_RaiseException+0x4c>
   2b042:	9910      	ldr	r1, [sp, #64]	; 0x40
   2b044:	4628      	mov	r0, r5
   2b046:	f7ff fed5 	bl	2adf4 <get_eit_entry>
   2b04a:	2800      	cmp	r0, #0
   2b04c:	d0f2      	beq.n	2b034 <__gnu_Unwind_RaiseException+0x2c>
   2b04e:	2009      	movs	r0, #9
   2b050:	b079      	add	sp, #484	; 0x1e4
   2b052:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2b054:	4668      	mov	r0, sp
   2b056:	f7ff ff1b 	bl	2ae90 <restore_non_core_regs>
   2b05a:	2c06      	cmp	r4, #6
   2b05c:	d1f7      	bne.n	2b04e <__gnu_Unwind_RaiseException+0x46>
   2b05e:	4639      	mov	r1, r7
   2b060:	4628      	mov	r0, r5
   2b062:	f7ff ff4b 	bl	2aefc <unwind_phase2>
   2b066:	bf00      	nop

0002b068 <__gnu_Unwind_ForcedUnwind>:
   2b068:	b430      	push	{r4, r5}
   2b06a:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
   2b06c:	60c1      	str	r1, [r0, #12]
   2b06e:	6182      	str	r2, [r0, #24]
   2b070:	4619      	mov	r1, r3
   2b072:	641d      	str	r5, [r3, #64]	; 0x40
   2b074:	2200      	movs	r2, #0
   2b076:	bc30      	pop	{r4, r5}
   2b078:	e75e      	b.n	2af38 <unwind_phase2_forced>
   2b07a:	bf00      	nop

0002b07c <__gnu_Unwind_Resume>:
   2b07c:	b570      	push	{r4, r5, r6, lr}
   2b07e:	68c6      	ldr	r6, [r0, #12]
   2b080:	6943      	ldr	r3, [r0, #20]
   2b082:	640b      	str	r3, [r1, #64]	; 0x40
   2b084:	b9ae      	cbnz	r6, 2b0b2 <__gnu_Unwind_Resume+0x36>
   2b086:	6903      	ldr	r3, [r0, #16]
   2b088:	460a      	mov	r2, r1
   2b08a:	4604      	mov	r4, r0
   2b08c:	460d      	mov	r5, r1
   2b08e:	4601      	mov	r1, r0
   2b090:	2002      	movs	r0, #2
   2b092:	4798      	blx	r3
   2b094:	2807      	cmp	r0, #7
   2b096:	d005      	beq.n	2b0a4 <__gnu_Unwind_Resume+0x28>
   2b098:	2808      	cmp	r0, #8
   2b09a:	d10f      	bne.n	2b0bc <__gnu_Unwind_Resume+0x40>
   2b09c:	4629      	mov	r1, r5
   2b09e:	4620      	mov	r0, r4
   2b0a0:	f7ff ff2c 	bl	2aefc <unwind_phase2>
   2b0a4:	4630      	mov	r0, r6
   2b0a6:	6c29      	ldr	r1, [r5, #64]	; 0x40
   2b0a8:	f7ff ff26 	bl	2aef8 <_Unwind_DebugHook>
   2b0ac:	1d28      	adds	r0, r5, #4
   2b0ae:	f000 fb31 	bl	2b714 <__restore_core_regs>
   2b0b2:	2201      	movs	r2, #1
   2b0b4:	f7ff ff40 	bl	2af38 <unwind_phase2_forced>
   2b0b8:	f000 fda2 	bl	2bc00 <abort>
   2b0bc:	f000 fda0 	bl	2bc00 <abort>

0002b0c0 <__gnu_Unwind_Resume_or_Rethrow>:
   2b0c0:	68c2      	ldr	r2, [r0, #12]
   2b0c2:	b11a      	cbz	r2, 2b0cc <__gnu_Unwind_Resume_or_Rethrow+0xc>
   2b0c4:	6bca      	ldr	r2, [r1, #60]	; 0x3c
   2b0c6:	640a      	str	r2, [r1, #64]	; 0x40
   2b0c8:	2200      	movs	r2, #0
   2b0ca:	e735      	b.n	2af38 <unwind_phase2_forced>
   2b0cc:	e79c      	b.n	2b008 <__gnu_Unwind_RaiseException>
   2b0ce:	bf00      	nop

0002b0d0 <_Unwind_Complete>:
   2b0d0:	4770      	bx	lr
   2b0d2:	bf00      	nop

0002b0d4 <_Unwind_DeleteException>:
   2b0d4:	6883      	ldr	r3, [r0, #8]
   2b0d6:	4601      	mov	r1, r0
   2b0d8:	b10b      	cbz	r3, 2b0de <_Unwind_DeleteException+0xa>
   2b0da:	2001      	movs	r0, #1
   2b0dc:	4718      	bx	r3
   2b0de:	4770      	bx	lr

0002b0e0 <_Unwind_VRS_Get>:
   2b0e0:	2901      	cmp	r1, #1
   2b0e2:	d012      	beq.n	2b10a <_Unwind_VRS_Get+0x2a>
   2b0e4:	d809      	bhi.n	2b0fa <_Unwind_VRS_Get+0x1a>
   2b0e6:	b973      	cbnz	r3, 2b106 <_Unwind_VRS_Get+0x26>
   2b0e8:	2a0f      	cmp	r2, #15
   2b0ea:	d80c      	bhi.n	2b106 <_Unwind_VRS_Get+0x26>
   2b0ec:	eb00 0282 	add.w	r2, r0, r2, lsl #2
   2b0f0:	4618      	mov	r0, r3
   2b0f2:	6853      	ldr	r3, [r2, #4]
   2b0f4:	9a00      	ldr	r2, [sp, #0]
   2b0f6:	6013      	str	r3, [r2, #0]
   2b0f8:	4770      	bx	lr
   2b0fa:	3903      	subs	r1, #3
   2b0fc:	2901      	cmp	r1, #1
   2b0fe:	bf94      	ite	ls
   2b100:	2001      	movls	r0, #1
   2b102:	2002      	movhi	r0, #2
   2b104:	4770      	bx	lr
   2b106:	2002      	movs	r0, #2
   2b108:	4770      	bx	lr
   2b10a:	4608      	mov	r0, r1
   2b10c:	4770      	bx	lr
   2b10e:	bf00      	nop

0002b110 <_Unwind_GetGR>:
   2b110:	b510      	push	{r4, lr}
   2b112:	b084      	sub	sp, #16
   2b114:	2300      	movs	r3, #0
   2b116:	ac03      	add	r4, sp, #12
   2b118:	460a      	mov	r2, r1
   2b11a:	9400      	str	r4, [sp, #0]
   2b11c:	4619      	mov	r1, r3
   2b11e:	f7ff ffdf 	bl	2b0e0 <_Unwind_VRS_Get>
   2b122:	9803      	ldr	r0, [sp, #12]
   2b124:	b004      	add	sp, #16
   2b126:	bd10      	pop	{r4, pc}

0002b128 <_Unwind_VRS_Set>:
   2b128:	2901      	cmp	r1, #1
   2b12a:	d012      	beq.n	2b152 <_Unwind_VRS_Set+0x2a>
   2b12c:	d809      	bhi.n	2b142 <_Unwind_VRS_Set+0x1a>
   2b12e:	b973      	cbnz	r3, 2b14e <_Unwind_VRS_Set+0x26>
   2b130:	2a0f      	cmp	r2, #15
   2b132:	d80c      	bhi.n	2b14e <_Unwind_VRS_Set+0x26>
   2b134:	eb00 0082 	add.w	r0, r0, r2, lsl #2
   2b138:	9a00      	ldr	r2, [sp, #0]
   2b13a:	6812      	ldr	r2, [r2, #0]
   2b13c:	6042      	str	r2, [r0, #4]
   2b13e:	4618      	mov	r0, r3
   2b140:	4770      	bx	lr
   2b142:	3903      	subs	r1, #3
   2b144:	2901      	cmp	r1, #1
   2b146:	bf94      	ite	ls
   2b148:	2001      	movls	r0, #1
   2b14a:	2002      	movhi	r0, #2
   2b14c:	4770      	bx	lr
   2b14e:	2002      	movs	r0, #2
   2b150:	4770      	bx	lr
   2b152:	4608      	mov	r0, r1
   2b154:	4770      	bx	lr
   2b156:	bf00      	nop

0002b158 <_Unwind_SetGR>:
   2b158:	b510      	push	{r4, lr}
   2b15a:	b084      	sub	sp, #16
   2b15c:	2300      	movs	r3, #0
   2b15e:	ac03      	add	r4, sp, #12
   2b160:	9203      	str	r2, [sp, #12]
   2b162:	9400      	str	r4, [sp, #0]
   2b164:	460a      	mov	r2, r1
   2b166:	4619      	mov	r1, r3
   2b168:	f7ff ffde 	bl	2b128 <_Unwind_VRS_Set>
   2b16c:	b004      	add	sp, #16
   2b16e:	bd10      	pop	{r4, pc}

0002b170 <__gnu_Unwind_Backtrace>:
   2b170:	b5f0      	push	{r4, r5, r6, r7, lr}
   2b172:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   2b174:	6413      	str	r3, [r2, #64]	; 0x40
   2b176:	1d15      	adds	r5, r2, #4
   2b178:	468c      	mov	ip, r1
   2b17a:	4606      	mov	r6, r0
   2b17c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   2b17e:	f5ad 7d0f 	sub.w	sp, sp, #572	; 0x23c
   2b182:	ac17      	add	r4, sp, #92	; 0x5c
   2b184:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   2b186:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   2b188:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   2b18a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   2b18c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   2b18e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   2b192:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   2b196:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
   2b19a:	4665      	mov	r5, ip
   2b19c:	9716      	str	r7, [sp, #88]	; 0x58
   2b19e:	e010      	b.n	2b1c2 <__gnu_Unwind_Backtrace+0x52>
   2b1a0:	f7ff ffda 	bl	2b158 <_Unwind_SetGR>
   2b1a4:	4629      	mov	r1, r5
   2b1a6:	a816      	add	r0, sp, #88	; 0x58
   2b1a8:	47b0      	blx	r6
   2b1aa:	4603      	mov	r3, r0
   2b1ac:	aa16      	add	r2, sp, #88	; 0x58
   2b1ae:	4669      	mov	r1, sp
   2b1b0:	2008      	movs	r0, #8
   2b1b2:	b983      	cbnz	r3, 2b1d6 <__gnu_Unwind_Backtrace+0x66>
   2b1b4:	9b04      	ldr	r3, [sp, #16]
   2b1b6:	4798      	blx	r3
   2b1b8:	2805      	cmp	r0, #5
   2b1ba:	4604      	mov	r4, r0
   2b1bc:	d00c      	beq.n	2b1d8 <__gnu_Unwind_Backtrace+0x68>
   2b1be:	2809      	cmp	r0, #9
   2b1c0:	d009      	beq.n	2b1d6 <__gnu_Unwind_Backtrace+0x66>
   2b1c2:	9926      	ldr	r1, [sp, #152]	; 0x98
   2b1c4:	4668      	mov	r0, sp
   2b1c6:	f7ff fe15 	bl	2adf4 <get_eit_entry>
   2b1ca:	4603      	mov	r3, r0
   2b1cc:	466a      	mov	r2, sp
   2b1ce:	210c      	movs	r1, #12
   2b1d0:	a816      	add	r0, sp, #88	; 0x58
   2b1d2:	2b00      	cmp	r3, #0
   2b1d4:	d0e4      	beq.n	2b1a0 <__gnu_Unwind_Backtrace+0x30>
   2b1d6:	2409      	movs	r4, #9
   2b1d8:	a816      	add	r0, sp, #88	; 0x58
   2b1da:	f7ff fe59 	bl	2ae90 <restore_non_core_regs>
   2b1de:	4620      	mov	r0, r4
   2b1e0:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
   2b1e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2b1e6:	bf00      	nop

0002b1e8 <__gnu_unwind_pr_common>:
   2b1e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2b1ec:	6ccc      	ldr	r4, [r1, #76]	; 0x4c
   2b1ee:	b089      	sub	sp, #36	; 0x24
   2b1f0:	460d      	mov	r5, r1
   2b1f2:	f854 1b04 	ldr.w	r1, [r4], #4
   2b1f6:	9406      	str	r4, [sp, #24]
   2b1f8:	4617      	mov	r7, r2
   2b1fa:	f000 0803 	and.w	r8, r0, #3
   2b1fe:	461e      	mov	r6, r3
   2b200:	2b00      	cmp	r3, #0
   2b202:	d079      	beq.n	2b2f8 <__gnu_unwind_pr_common+0x110>
   2b204:	0c0b      	lsrs	r3, r1, #16
   2b206:	b2da      	uxtb	r2, r3
   2b208:	0409      	lsls	r1, r1, #16
   2b20a:	f88d 301d 	strb.w	r3, [sp, #29]
   2b20e:	2302      	movs	r3, #2
   2b210:	eb04 0482 	add.w	r4, r4, r2, lsl #2
   2b214:	9105      	str	r1, [sp, #20]
   2b216:	f88d 301c 	strb.w	r3, [sp, #28]
   2b21a:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   2b21c:	f1b8 0f02 	cmp.w	r8, #2
   2b220:	bf08      	it	eq
   2b222:	6bac      	ldreq	r4, [r5, #56]	; 0x38
   2b224:	f013 0301 	ands.w	r3, r3, #1
   2b228:	d00c      	beq.n	2b244 <__gnu_unwind_pr_common+0x5c>
   2b22a:	4638      	mov	r0, r7
   2b22c:	a905      	add	r1, sp, #20
   2b22e:	f000 fb73 	bl	2b918 <__gnu_unwind_execute>
   2b232:	b918      	cbnz	r0, 2b23c <__gnu_unwind_pr_common+0x54>
   2b234:	2008      	movs	r0, #8
   2b236:	b009      	add	sp, #36	; 0x24
   2b238:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2b23c:	2009      	movs	r0, #9
   2b23e:	b009      	add	sp, #36	; 0x24
   2b240:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2b244:	f8d4 a000 	ldr.w	sl, [r4]
   2b248:	f1ba 0f00 	cmp.w	sl, #0
   2b24c:	d0ed      	beq.n	2b22a <__gnu_unwind_pr_common+0x42>
   2b24e:	9301      	str	r3, [sp, #4]
   2b250:	f000 0308 	and.w	r3, r0, #8
   2b254:	9302      	str	r3, [sp, #8]
   2b256:	2e02      	cmp	r6, #2
   2b258:	d04a      	beq.n	2b2f0 <__gnu_unwind_pr_common+0x108>
   2b25a:	f8b4 a000 	ldrh.w	sl, [r4]
   2b25e:	f8b4 9002 	ldrh.w	r9, [r4, #2]
   2b262:	3404      	adds	r4, #4
   2b264:	6caa      	ldr	r2, [r5, #72]	; 0x48
   2b266:	f029 0b01 	bic.w	fp, r9, #1
   2b26a:	210f      	movs	r1, #15
   2b26c:	4638      	mov	r0, r7
   2b26e:	4493      	add	fp, r2
   2b270:	f7ff ff4e 	bl	2b110 <_Unwind_GetGR>
   2b274:	4583      	cmp	fp, r0
   2b276:	d839      	bhi.n	2b2ec <__gnu_unwind_pr_common+0x104>
   2b278:	f02a 0201 	bic.w	r2, sl, #1
   2b27c:	445a      	add	r2, fp
   2b27e:	4282      	cmp	r2, r0
   2b280:	bf94      	ite	ls
   2b282:	2000      	movls	r0, #0
   2b284:	2001      	movhi	r0, #1
   2b286:	ea4f 0349 	mov.w	r3, r9, lsl #1
   2b28a:	f003 0302 	and.w	r3, r3, #2
   2b28e:	f00a 0a01 	and.w	sl, sl, #1
   2b292:	ea43 030a 	orr.w	r3, r3, sl
   2b296:	2b01      	cmp	r3, #1
   2b298:	d049      	beq.n	2b32e <__gnu_unwind_pr_common+0x146>
   2b29a:	2b02      	cmp	r3, #2
   2b29c:	d032      	beq.n	2b304 <__gnu_unwind_pr_common+0x11c>
   2b29e:	2b00      	cmp	r3, #0
   2b2a0:	d1cc      	bne.n	2b23c <__gnu_unwind_pr_common+0x54>
   2b2a2:	f1b8 0f00 	cmp.w	r8, #0
   2b2a6:	d002      	beq.n	2b2ae <__gnu_unwind_pr_common+0xc6>
   2b2a8:	2800      	cmp	r0, #0
   2b2aa:	f040 80cd 	bne.w	2b448 <__gnu_unwind_pr_common+0x260>
   2b2ae:	3404      	adds	r4, #4
   2b2b0:	f8d4 a000 	ldr.w	sl, [r4]
   2b2b4:	f1ba 0f00 	cmp.w	sl, #0
   2b2b8:	d1cd      	bne.n	2b256 <__gnu_unwind_pr_common+0x6e>
   2b2ba:	a905      	add	r1, sp, #20
   2b2bc:	4638      	mov	r0, r7
   2b2be:	f000 fb2b 	bl	2b918 <__gnu_unwind_execute>
   2b2c2:	2800      	cmp	r0, #0
   2b2c4:	d1ba      	bne.n	2b23c <__gnu_unwind_pr_common+0x54>
   2b2c6:	9b01      	ldr	r3, [sp, #4]
   2b2c8:	2b00      	cmp	r3, #0
   2b2ca:	d0b3      	beq.n	2b234 <__gnu_unwind_pr_common+0x4c>
   2b2cc:	210f      	movs	r1, #15
   2b2ce:	4638      	mov	r0, r7
   2b2d0:	f7ff ff1e 	bl	2b110 <_Unwind_GetGR>
   2b2d4:	210e      	movs	r1, #14
   2b2d6:	4602      	mov	r2, r0
   2b2d8:	4638      	mov	r0, r7
   2b2da:	f7ff ff3d 	bl	2b158 <_Unwind_SetGR>
   2b2de:	4638      	mov	r0, r7
   2b2e0:	4a6a      	ldr	r2, [pc, #424]	; (2b48c <__gnu_unwind_pr_common+0x2a4>)
   2b2e2:	210f      	movs	r1, #15
   2b2e4:	f7ff ff38 	bl	2b158 <_Unwind_SetGR>
   2b2e8:	2007      	movs	r0, #7
   2b2ea:	e7a8      	b.n	2b23e <__gnu_unwind_pr_common+0x56>
   2b2ec:	2000      	movs	r0, #0
   2b2ee:	e7ca      	b.n	2b286 <__gnu_unwind_pr_common+0x9e>
   2b2f0:	f8d4 9004 	ldr.w	r9, [r4, #4]
   2b2f4:	3408      	adds	r4, #8
   2b2f6:	e7b5      	b.n	2b264 <__gnu_unwind_pr_common+0x7c>
   2b2f8:	0209      	lsls	r1, r1, #8
   2b2fa:	2303      	movs	r3, #3
   2b2fc:	9105      	str	r1, [sp, #20]
   2b2fe:	f8ad 301c 	strh.w	r3, [sp, #28]
   2b302:	e78a      	b.n	2b21a <__gnu_unwind_pr_common+0x32>
   2b304:	6823      	ldr	r3, [r4, #0]
   2b306:	f023 4b00 	bic.w	fp, r3, #2147483648	; 0x80000000
   2b30a:	f1b8 0f00 	cmp.w	r8, #0
   2b30e:	d145      	bne.n	2b39c <__gnu_unwind_pr_common+0x1b4>
   2b310:	b128      	cbz	r0, 2b31e <__gnu_unwind_pr_common+0x136>
   2b312:	9a02      	ldr	r2, [sp, #8]
   2b314:	2a00      	cmp	r2, #0
   2b316:	d05c      	beq.n	2b3d2 <__gnu_unwind_pr_common+0x1ea>
   2b318:	f1bb 0f00 	cmp.w	fp, #0
   2b31c:	d074      	beq.n	2b408 <__gnu_unwind_pr_common+0x220>
   2b31e:	2b00      	cmp	r3, #0
   2b320:	da00      	bge.n	2b324 <__gnu_unwind_pr_common+0x13c>
   2b322:	3404      	adds	r4, #4
   2b324:	f10b 0b01 	add.w	fp, fp, #1
   2b328:	eb04 048b 	add.w	r4, r4, fp, lsl #2
   2b32c:	e7c0      	b.n	2b2b0 <__gnu_unwind_pr_common+0xc8>
   2b32e:	f1b8 0f00 	cmp.w	r8, #0
   2b332:	d119      	bne.n	2b368 <__gnu_unwind_pr_common+0x180>
   2b334:	b1b0      	cbz	r0, 2b364 <__gnu_unwind_pr_common+0x17c>
   2b336:	e9d4 2300 	ldrd	r2, r3, [r4]
   2b33a:	1c99      	adds	r1, r3, #2
   2b33c:	ea4f 72d2 	mov.w	r2, r2, lsr #31
   2b340:	f43f af7c 	beq.w	2b23c <__gnu_unwind_pr_common+0x54>
   2b344:	f105 0158 	add.w	r1, r5, #88	; 0x58
   2b348:	3301      	adds	r3, #1
   2b34a:	9104      	str	r1, [sp, #16]
   2b34c:	f000 8090 	beq.w	2b470 <__gnu_unwind_pr_common+0x288>
   2b350:	1d20      	adds	r0, r4, #4
   2b352:	f7ff fdc9 	bl	2aee8 <_Unwind_decode_typeinfo_ptr.isra.0>
   2b356:	ab04      	add	r3, sp, #16
   2b358:	4601      	mov	r1, r0
   2b35a:	4628      	mov	r0, r5
   2b35c:	f3af 8000 	nop.w
   2b360:	2800      	cmp	r0, #0
   2b362:	d15b      	bne.n	2b41c <__gnu_unwind_pr_common+0x234>
   2b364:	3408      	adds	r4, #8
   2b366:	e7a3      	b.n	2b2b0 <__gnu_unwind_pr_common+0xc8>
   2b368:	210d      	movs	r1, #13
   2b36a:	4638      	mov	r0, r7
   2b36c:	f8d5 9020 	ldr.w	r9, [r5, #32]
   2b370:	f7ff fece 	bl	2b110 <_Unwind_GetGR>
   2b374:	4581      	cmp	r9, r0
   2b376:	d1f5      	bne.n	2b364 <__gnu_unwind_pr_common+0x17c>
   2b378:	6aab      	ldr	r3, [r5, #40]	; 0x28
   2b37a:	429c      	cmp	r4, r3
   2b37c:	d1f2      	bne.n	2b364 <__gnu_unwind_pr_common+0x17c>
   2b37e:	4620      	mov	r0, r4
   2b380:	f7ff fcec 	bl	2ad5c <selfrel_offset31>
   2b384:	210f      	movs	r1, #15
   2b386:	4602      	mov	r2, r0
   2b388:	4638      	mov	r0, r7
   2b38a:	f7ff fee5 	bl	2b158 <_Unwind_SetGR>
   2b38e:	4638      	mov	r0, r7
   2b390:	462a      	mov	r2, r5
   2b392:	2100      	movs	r1, #0
   2b394:	f7ff fee0 	bl	2b158 <_Unwind_SetGR>
   2b398:	2007      	movs	r0, #7
   2b39a:	e750      	b.n	2b23e <__gnu_unwind_pr_common+0x56>
   2b39c:	210d      	movs	r1, #13
   2b39e:	4638      	mov	r0, r7
   2b3a0:	f8d5 9020 	ldr.w	r9, [r5, #32]
   2b3a4:	f7ff feb4 	bl	2b110 <_Unwind_GetGR>
   2b3a8:	4581      	cmp	r9, r0
   2b3aa:	d001      	beq.n	2b3b0 <__gnu_unwind_pr_common+0x1c8>
   2b3ac:	6823      	ldr	r3, [r4, #0]
   2b3ae:	e7b6      	b.n	2b31e <__gnu_unwind_pr_common+0x136>
   2b3b0:	6aab      	ldr	r3, [r5, #40]	; 0x28
   2b3b2:	429c      	cmp	r4, r3
   2b3b4:	d1fa      	bne.n	2b3ac <__gnu_unwind_pr_common+0x1c4>
   2b3b6:	2204      	movs	r2, #4
   2b3b8:	2100      	movs	r1, #0
   2b3ba:	e9c5 120b 	strd	r1, r2, [r5, #44]	; 0x2c
   2b3be:	18a3      	adds	r3, r4, r2
   2b3c0:	f8c5 b028 	str.w	fp, [r5, #40]	; 0x28
   2b3c4:	636b      	str	r3, [r5, #52]	; 0x34
   2b3c6:	6823      	ldr	r3, [r4, #0]
   2b3c8:	428b      	cmp	r3, r1
   2b3ca:	db59      	blt.n	2b480 <__gnu_unwind_pr_common+0x298>
   2b3cc:	2301      	movs	r3, #1
   2b3ce:	9301      	str	r3, [sp, #4]
   2b3d0:	e7a8      	b.n	2b324 <__gnu_unwind_pr_common+0x13c>
   2b3d2:	f105 0358 	add.w	r3, r5, #88	; 0x58
   2b3d6:	f8cd 800c 	str.w	r8, [sp, #12]
   2b3da:	f104 0a04 	add.w	sl, r4, #4
   2b3de:	46b0      	mov	r8, r6
   2b3e0:	4691      	mov	r9, r2
   2b3e2:	461e      	mov	r6, r3
   2b3e4:	e00d      	b.n	2b402 <__gnu_unwind_pr_common+0x21a>
   2b3e6:	9604      	str	r6, [sp, #16]
   2b3e8:	f7ff fd7e 	bl	2aee8 <_Unwind_decode_typeinfo_ptr.isra.0>
   2b3ec:	ab04      	add	r3, sp, #16
   2b3ee:	4601      	mov	r1, r0
   2b3f0:	2200      	movs	r2, #0
   2b3f2:	4628      	mov	r0, r5
   2b3f4:	f3af 8000 	nop.w
   2b3f8:	f109 0901 	add.w	r9, r9, #1
   2b3fc:	f10a 0a04 	add.w	sl, sl, #4
   2b400:	b9e8      	cbnz	r0, 2b43e <__gnu_unwind_pr_common+0x256>
   2b402:	45d9      	cmp	r9, fp
   2b404:	4650      	mov	r0, sl
   2b406:	d1ee      	bne.n	2b3e6 <__gnu_unwind_pr_common+0x1fe>
   2b408:	4638      	mov	r0, r7
   2b40a:	210d      	movs	r1, #13
   2b40c:	f7ff fe80 	bl	2b110 <_Unwind_GetGR>
   2b410:	9b04      	ldr	r3, [sp, #16]
   2b412:	6228      	str	r0, [r5, #32]
   2b414:	e9c5 3409 	strd	r3, r4, [r5, #36]	; 0x24
   2b418:	2006      	movs	r0, #6
   2b41a:	e710      	b.n	2b23e <__gnu_unwind_pr_common+0x56>
   2b41c:	4681      	mov	r9, r0
   2b41e:	210d      	movs	r1, #13
   2b420:	4638      	mov	r0, r7
   2b422:	f7ff fe75 	bl	2b110 <_Unwind_GetGR>
   2b426:	f1b9 0f02 	cmp.w	r9, #2
   2b42a:	6228      	str	r0, [r5, #32]
   2b42c:	d125      	bne.n	2b47a <__gnu_unwind_pr_common+0x292>
   2b42e:	462b      	mov	r3, r5
   2b430:	9a04      	ldr	r2, [sp, #16]
   2b432:	f843 2f2c 	str.w	r2, [r3, #44]!
   2b436:	626b      	str	r3, [r5, #36]	; 0x24
   2b438:	62ac      	str	r4, [r5, #40]	; 0x28
   2b43a:	2006      	movs	r0, #6
   2b43c:	e6ff      	b.n	2b23e <__gnu_unwind_pr_common+0x56>
   2b43e:	4646      	mov	r6, r8
   2b440:	6823      	ldr	r3, [r4, #0]
   2b442:	f8dd 800c 	ldr.w	r8, [sp, #12]
   2b446:	e76a      	b.n	2b31e <__gnu_unwind_pr_common+0x136>
   2b448:	4620      	mov	r0, r4
   2b44a:	f7ff fc87 	bl	2ad5c <selfrel_offset31>
   2b44e:	3404      	adds	r4, #4
   2b450:	4602      	mov	r2, r0
   2b452:	63ac      	str	r4, [r5, #56]	; 0x38
   2b454:	4628      	mov	r0, r5
   2b456:	4614      	mov	r4, r2
   2b458:	f3af 8000 	nop.w
   2b45c:	2800      	cmp	r0, #0
   2b45e:	f43f aeed 	beq.w	2b23c <__gnu_unwind_pr_common+0x54>
   2b462:	4638      	mov	r0, r7
   2b464:	4622      	mov	r2, r4
   2b466:	210f      	movs	r1, #15
   2b468:	f7ff fe76 	bl	2b158 <_Unwind_SetGR>
   2b46c:	2007      	movs	r0, #7
   2b46e:	e6e6      	b.n	2b23e <__gnu_unwind_pr_common+0x56>
   2b470:	4638      	mov	r0, r7
   2b472:	210d      	movs	r1, #13
   2b474:	f7ff fe4c 	bl	2b110 <_Unwind_GetGR>
   2b478:	6228      	str	r0, [r5, #32]
   2b47a:	9b04      	ldr	r3, [sp, #16]
   2b47c:	626b      	str	r3, [r5, #36]	; 0x24
   2b47e:	e7db      	b.n	2b438 <__gnu_unwind_pr_common+0x250>
   2b480:	f10b 0001 	add.w	r0, fp, #1
   2b484:	eb04 0080 	add.w	r0, r4, r0, lsl #2
   2b488:	e77a      	b.n	2b380 <__gnu_unwind_pr_common+0x198>
   2b48a:	bf00      	nop
   2b48c:	00000000 	.word	0x00000000

0002b490 <__aeabi_unwind_cpp_pr0>:
   2b490:	2300      	movs	r3, #0
   2b492:	e6a9      	b.n	2b1e8 <__gnu_unwind_pr_common>

0002b494 <__aeabi_unwind_cpp_pr1>:
   2b494:	2301      	movs	r3, #1
   2b496:	e6a7      	b.n	2b1e8 <__gnu_unwind_pr_common>

0002b498 <__aeabi_unwind_cpp_pr2>:
   2b498:	2302      	movs	r3, #2
   2b49a:	e6a5      	b.n	2b1e8 <__gnu_unwind_pr_common>

0002b49c <_Unwind_VRS_Pop>:
   2b49c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2b4a0:	4606      	mov	r6, r0
   2b4a2:	b0c3      	sub	sp, #268	; 0x10c
   2b4a4:	4615      	mov	r5, r2
   2b4a6:	461c      	mov	r4, r3
   2b4a8:	2904      	cmp	r1, #4
   2b4aa:	f200 80b9 	bhi.w	2b620 <_Unwind_VRS_Pop+0x184>
   2b4ae:	e8df f001 	tbb	[pc, r1]
   2b4b2:	539a      	.short	0x539a
   2b4b4:	29b7      	.short	0x29b7
   2b4b6:	03          	.byte	0x03
   2b4b7:	00          	.byte	0x00
   2b4b8:	2c00      	cmp	r4, #0
   2b4ba:	f040 80b1 	bne.w	2b620 <_Unwind_VRS_Pop+0x184>
   2b4be:	2a10      	cmp	r2, #16
   2b4c0:	f200 80ae 	bhi.w	2b620 <_Unwind_VRS_Pop+0x184>
   2b4c4:	6803      	ldr	r3, [r0, #0]
   2b4c6:	06d8      	lsls	r0, r3, #27
   2b4c8:	f100 80f3 	bmi.w	2b6b2 <_Unwind_VRS_Pop+0x216>
   2b4cc:	af20      	add	r7, sp, #128	; 0x80
   2b4ce:	4638      	mov	r0, r7
   2b4d0:	f000 f992 	bl	2b7f8 <__gnu_Unwind_Save_WMMXC>
   2b4d4:	6bb0      	ldr	r0, [r6, #56]	; 0x38
   2b4d6:	2300      	movs	r3, #0
   2b4d8:	2401      	movs	r4, #1
   2b4da:	fa04 f203 	lsl.w	r2, r4, r3
   2b4de:	422a      	tst	r2, r5
   2b4e0:	4601      	mov	r1, r0
   2b4e2:	d004      	beq.n	2b4ee <_Unwind_VRS_Pop+0x52>
   2b4e4:	f851 2b04 	ldr.w	r2, [r1], #4
   2b4e8:	f847 2023 	str.w	r2, [r7, r3, lsl #2]
   2b4ec:	4608      	mov	r0, r1
   2b4ee:	3301      	adds	r3, #1
   2b4f0:	2b04      	cmp	r3, #4
   2b4f2:	d1f2      	bne.n	2b4da <_Unwind_VRS_Pop+0x3e>
   2b4f4:	63b0      	str	r0, [r6, #56]	; 0x38
   2b4f6:	4638      	mov	r0, r7
   2b4f8:	f000 f974 	bl	2b7e4 <__gnu_Unwind_Restore_WMMXC>
   2b4fc:	2000      	movs	r0, #0
   2b4fe:	b043      	add	sp, #268	; 0x10c
   2b500:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2b504:	2c03      	cmp	r4, #3
   2b506:	f040 808b 	bne.w	2b620 <_Unwind_VRS_Pop+0x184>
   2b50a:	b294      	uxth	r4, r2
   2b50c:	eb04 4312 	add.w	r3, r4, r2, lsr #16
   2b510:	2b10      	cmp	r3, #16
   2b512:	ea4f 4512 	mov.w	r5, r2, lsr #16
   2b516:	f200 8083 	bhi.w	2b620 <_Unwind_VRS_Pop+0x184>
   2b51a:	6803      	ldr	r3, [r0, #0]
   2b51c:	071f      	lsls	r7, r3, #28
   2b51e:	f100 80d0 	bmi.w	2b6c2 <_Unwind_VRS_Pop+0x226>
   2b522:	af20      	add	r7, sp, #128	; 0x80
   2b524:	4638      	mov	r0, r7
   2b526:	f000 f93b 	bl	2b7a0 <__gnu_Unwind_Save_WMMXD>
   2b52a:	eb07 01c5 	add.w	r1, r7, r5, lsl #3
   2b52e:	6bb5      	ldr	r5, [r6, #56]	; 0x38
   2b530:	b154      	cbz	r4, 2b548 <_Unwind_VRS_Pop+0xac>
   2b532:	460b      	mov	r3, r1
   2b534:	1ae8      	subs	r0, r5, r3
   2b536:	eb01 01c4 	add.w	r1, r1, r4, lsl #3
   2b53a:	00e4      	lsls	r4, r4, #3
   2b53c:	581a      	ldr	r2, [r3, r0]
   2b53e:	f843 2b04 	str.w	r2, [r3], #4
   2b542:	428b      	cmp	r3, r1
   2b544:	d1fa      	bne.n	2b53c <_Unwind_VRS_Pop+0xa0>
   2b546:	4425      	add	r5, r4
   2b548:	4638      	mov	r0, r7
   2b54a:	63b5      	str	r5, [r6, #56]	; 0x38
   2b54c:	f000 f906 	bl	2b75c <__gnu_Unwind_Restore_WMMXD>
   2b550:	2000      	movs	r0, #0
   2b552:	b043      	add	sp, #268	; 0x10c
   2b554:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2b558:	2c01      	cmp	r4, #1
   2b55a:	ea4f 4812 	mov.w	r8, r2, lsr #16
   2b55e:	b295      	uxth	r5, r2
   2b560:	d05a      	beq.n	2b618 <_Unwind_VRS_Pop+0x17c>
   2b562:	2c05      	cmp	r4, #5
   2b564:	d15c      	bne.n	2b620 <_Unwind_VRS_Pop+0x184>
   2b566:	eb08 0905 	add.w	r9, r8, r5
   2b56a:	f1b9 0f20 	cmp.w	r9, #32
   2b56e:	d857      	bhi.n	2b620 <_Unwind_VRS_Pop+0x184>
   2b570:	f1b8 0f0f 	cmp.w	r8, #15
   2b574:	d977      	bls.n	2b666 <_Unwind_VRS_Pop+0x1ca>
   2b576:	46a9      	mov	r9, r5
   2b578:	2d00      	cmp	r5, #0
   2b57a:	f040 8088 	bne.w	2b68e <_Unwind_VRS_Pop+0x1f2>
   2b57e:	6bb3      	ldr	r3, [r6, #56]	; 0x38
   2b580:	b36d      	cbz	r5, 2b5de <_Unwind_VRS_Pop+0x142>
   2b582:	af20      	add	r7, sp, #128	; 0x80
   2b584:	f04f 0900 	mov.w	r9, #0
   2b588:	eb07 07c8 	add.w	r7, r7, r8, lsl #3
   2b58c:	3f04      	subs	r7, #4
   2b58e:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
   2b592:	f853 1b04 	ldr.w	r1, [r3], #4
   2b596:	f847 1f04 	str.w	r1, [r7, #4]!
   2b59a:	42ab      	cmp	r3, r5
   2b59c:	d1f9      	bne.n	2b592 <_Unwind_VRS_Pop+0xf6>
   2b59e:	f1b9 0f00 	cmp.w	r9, #0
   2b5a2:	d00f      	beq.n	2b5c4 <_Unwind_VRS_Pop+0x128>
   2b5a4:	466f      	mov	r7, sp
   2b5a6:	4641      	mov	r1, r8
   2b5a8:	2910      	cmp	r1, #16
   2b5aa:	bf38      	it	cc
   2b5ac:	2110      	movcc	r1, #16
   2b5ae:	eb07 01c1 	add.w	r1, r7, r1, lsl #3
   2b5b2:	3984      	subs	r1, #132	; 0x84
   2b5b4:	eb03 05c9 	add.w	r5, r3, r9, lsl #3
   2b5b8:	f853 0b04 	ldr.w	r0, [r3], #4
   2b5bc:	f841 0f04 	str.w	r0, [r1, #4]!
   2b5c0:	42ab      	cmp	r3, r5
   2b5c2:	d1f9      	bne.n	2b5b8 <_Unwind_VRS_Pop+0x11c>
   2b5c4:	2c01      	cmp	r4, #1
   2b5c6:	f000 8084 	beq.w	2b6d2 <_Unwind_VRS_Pop+0x236>
   2b5ca:	f1b8 0f0f 	cmp.w	r8, #15
   2b5ce:	63b5      	str	r5, [r6, #56]	; 0x38
   2b5d0:	d945      	bls.n	2b65e <_Unwind_VRS_Pop+0x1c2>
   2b5d2:	f1b9 0f00 	cmp.w	r9, #0
   2b5d6:	d002      	beq.n	2b5de <_Unwind_VRS_Pop+0x142>
   2b5d8:	4668      	mov	r0, sp
   2b5da:	f000 f8b7 	bl	2b74c <__gnu_Unwind_Restore_VFP_D_16_to_31>
   2b5de:	2000      	movs	r0, #0
   2b5e0:	b043      	add	sp, #268	; 0x10c
   2b5e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2b5e6:	b9dc      	cbnz	r4, 2b620 <_Unwind_VRS_Pop+0x184>
   2b5e8:	6b87      	ldr	r7, [r0, #56]	; 0x38
   2b5ea:	4623      	mov	r3, r4
   2b5ec:	2001      	movs	r0, #1
   2b5ee:	b294      	uxth	r4, r2
   2b5f0:	f106 0c04 	add.w	ip, r6, #4
   2b5f4:	fa00 f203 	lsl.w	r2, r0, r3
   2b5f8:	4222      	tst	r2, r4
   2b5fa:	4639      	mov	r1, r7
   2b5fc:	d004      	beq.n	2b608 <_Unwind_VRS_Pop+0x16c>
   2b5fe:	f851 2b04 	ldr.w	r2, [r1], #4
   2b602:	f84c 2023 	str.w	r2, [ip, r3, lsl #2]
   2b606:	460f      	mov	r7, r1
   2b608:	3301      	adds	r3, #1
   2b60a:	2b10      	cmp	r3, #16
   2b60c:	d1f2      	bne.n	2b5f4 <_Unwind_VRS_Pop+0x158>
   2b60e:	f415 5000 	ands.w	r0, r5, #8192	; 0x2000
   2b612:	d1e4      	bne.n	2b5de <_Unwind_VRS_Pop+0x142>
   2b614:	63b7      	str	r7, [r6, #56]	; 0x38
   2b616:	e004      	b.n	2b622 <_Unwind_VRS_Pop+0x186>
   2b618:	eb08 0305 	add.w	r3, r8, r5
   2b61c:	2b10      	cmp	r3, #16
   2b61e:	d903      	bls.n	2b628 <_Unwind_VRS_Pop+0x18c>
   2b620:	2002      	movs	r0, #2
   2b622:	b043      	add	sp, #268	; 0x10c
   2b624:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2b628:	f1b8 0f0f 	cmp.w	r8, #15
   2b62c:	d8f8      	bhi.n	2b620 <_Unwind_VRS_Pop+0x184>
   2b62e:	6833      	ldr	r3, [r6, #0]
   2b630:	07da      	lsls	r2, r3, #31
   2b632:	d506      	bpl.n	2b642 <_Unwind_VRS_Pop+0x1a6>
   2b634:	4630      	mov	r0, r6
   2b636:	f023 0303 	bic.w	r3, r3, #3
   2b63a:	f840 3b48 	str.w	r3, [r0], #72
   2b63e:	f000 f879 	bl	2b734 <__gnu_Unwind_Save_VFP>
   2b642:	af20      	add	r7, sp, #128	; 0x80
   2b644:	4638      	mov	r0, r7
   2b646:	f000 f875 	bl	2b734 <__gnu_Unwind_Save_VFP>
   2b64a:	6bb3      	ldr	r3, [r6, #56]	; 0x38
   2b64c:	2d00      	cmp	r5, #0
   2b64e:	d199      	bne.n	2b584 <_Unwind_VRS_Pop+0xe8>
   2b650:	461d      	mov	r5, r3
   2b652:	3504      	adds	r5, #4
   2b654:	63b5      	str	r5, [r6, #56]	; 0x38
   2b656:	4638      	mov	r0, r7
   2b658:	f000 f868 	bl	2b72c <__gnu_Unwind_Restore_VFP>
   2b65c:	e7bf      	b.n	2b5de <_Unwind_VRS_Pop+0x142>
   2b65e:	a820      	add	r0, sp, #128	; 0x80
   2b660:	f000 f86c 	bl	2b73c <__gnu_Unwind_Restore_VFP_D>
   2b664:	e7b5      	b.n	2b5d2 <_Unwind_VRS_Pop+0x136>
   2b666:	f1b9 0f10 	cmp.w	r9, #16
   2b66a:	d940      	bls.n	2b6ee <_Unwind_VRS_Pop+0x252>
   2b66c:	f1a9 0910 	sub.w	r9, r9, #16
   2b670:	6833      	ldr	r3, [r6, #0]
   2b672:	07d9      	lsls	r1, r3, #31
   2b674:	d508      	bpl.n	2b688 <_Unwind_VRS_Pop+0x1ec>
   2b676:	f023 0301 	bic.w	r3, r3, #1
   2b67a:	4630      	mov	r0, r6
   2b67c:	f043 0302 	orr.w	r3, r3, #2
   2b680:	f840 3b48 	str.w	r3, [r0], #72
   2b684:	f000 f85e 	bl	2b744 <__gnu_Unwind_Save_VFP_D>
   2b688:	f1b9 0f00 	cmp.w	r9, #0
   2b68c:	d032      	beq.n	2b6f4 <_Unwind_VRS_Pop+0x258>
   2b68e:	6833      	ldr	r3, [r6, #0]
   2b690:	075a      	lsls	r2, r3, #29
   2b692:	d420      	bmi.n	2b6d6 <_Unwind_VRS_Pop+0x23a>
   2b694:	f1b8 0f0f 	cmp.w	r8, #15
   2b698:	d925      	bls.n	2b6e6 <_Unwind_VRS_Pop+0x24a>
   2b69a:	466f      	mov	r7, sp
   2b69c:	4638      	mov	r0, r7
   2b69e:	f1c8 0510 	rsb	r5, r8, #16
   2b6a2:	f000 f857 	bl	2b754 <__gnu_Unwind_Save_VFP_D_16_to_31>
   2b6a6:	2d00      	cmp	r5, #0
   2b6a8:	6bb3      	ldr	r3, [r6, #56]	; 0x38
   2b6aa:	f77f af7c 	ble.w	2b5a6 <_Unwind_VRS_Pop+0x10a>
   2b6ae:	af20      	add	r7, sp, #128	; 0x80
   2b6b0:	e76a      	b.n	2b588 <_Unwind_VRS_Pop+0xec>
   2b6b2:	f023 0310 	bic.w	r3, r3, #16
   2b6b6:	6033      	str	r3, [r6, #0]
   2b6b8:	f506 70e8 	add.w	r0, r6, #464	; 0x1d0
   2b6bc:	f000 f89c 	bl	2b7f8 <__gnu_Unwind_Save_WMMXC>
   2b6c0:	e704      	b.n	2b4cc <_Unwind_VRS_Pop+0x30>
   2b6c2:	f023 0308 	bic.w	r3, r3, #8
   2b6c6:	6003      	str	r3, [r0, #0]
   2b6c8:	f500 70a8 	add.w	r0, r0, #336	; 0x150
   2b6cc:	f000 f868 	bl	2b7a0 <__gnu_Unwind_Save_WMMXD>
   2b6d0:	e727      	b.n	2b522 <_Unwind_VRS_Pop+0x86>
   2b6d2:	af20      	add	r7, sp, #128	; 0x80
   2b6d4:	e7bd      	b.n	2b652 <_Unwind_VRS_Pop+0x1b6>
   2b6d6:	4630      	mov	r0, r6
   2b6d8:	f023 0304 	bic.w	r3, r3, #4
   2b6dc:	f840 3bd0 	str.w	r3, [r0], #208
   2b6e0:	f000 f838 	bl	2b754 <__gnu_Unwind_Save_VFP_D_16_to_31>
   2b6e4:	e7d6      	b.n	2b694 <_Unwind_VRS_Pop+0x1f8>
   2b6e6:	a820      	add	r0, sp, #128	; 0x80
   2b6e8:	f000 f82c 	bl	2b744 <__gnu_Unwind_Save_VFP_D>
   2b6ec:	e7d5      	b.n	2b69a <_Unwind_VRS_Pop+0x1fe>
   2b6ee:	f04f 0900 	mov.w	r9, #0
   2b6f2:	e7bd      	b.n	2b670 <_Unwind_VRS_Pop+0x1d4>
   2b6f4:	f1b8 0f0f 	cmp.w	r8, #15
   2b6f8:	f63f af41 	bhi.w	2b57e <_Unwind_VRS_Pop+0xe2>
   2b6fc:	af20      	add	r7, sp, #128	; 0x80
   2b6fe:	4638      	mov	r0, r7
   2b700:	f000 f820 	bl	2b744 <__gnu_Unwind_Save_VFP_D>
   2b704:	6bb3      	ldr	r3, [r6, #56]	; 0x38
   2b706:	2d00      	cmp	r5, #0
   2b708:	f47f af3c 	bne.w	2b584 <_Unwind_VRS_Pop+0xe8>
   2b70c:	4638      	mov	r0, r7
   2b70e:	f000 f815 	bl	2b73c <__gnu_Unwind_Restore_VFP_D>
   2b712:	e764      	b.n	2b5de <_Unwind_VRS_Pop+0x142>

0002b714 <__restore_core_regs>:
   2b714:	f100 0134 	add.w	r1, r0, #52	; 0x34
   2b718:	e891 0038 	ldmia.w	r1, {r3, r4, r5}
   2b71c:	469c      	mov	ip, r3
   2b71e:	46a6      	mov	lr, r4
   2b720:	f84c 5d04 	str.w	r5, [ip, #-4]!
   2b724:	e890 0fff 	ldmia.w	r0, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp}
   2b728:	46e5      	mov	sp, ip
   2b72a:	bd00      	pop	{pc}

0002b72c <__gnu_Unwind_Restore_VFP>:
   2b72c:	ec90 0b21 	fldmiax	r0, {d0-d15}	;@ Deprecated
   2b730:	4770      	bx	lr
   2b732:	bf00      	nop

0002b734 <__gnu_Unwind_Save_VFP>:
   2b734:	ec80 0b21 	fstmiax	r0, {d0-d15}	;@ Deprecated
   2b738:	4770      	bx	lr
   2b73a:	bf00      	nop

0002b73c <__gnu_Unwind_Restore_VFP_D>:
   2b73c:	ec90 0b20 	vldmia	r0, {d0-d15}
   2b740:	4770      	bx	lr
   2b742:	bf00      	nop

0002b744 <__gnu_Unwind_Save_VFP_D>:
   2b744:	ec80 0b20 	vstmia	r0, {d0-d15}
   2b748:	4770      	bx	lr
   2b74a:	bf00      	nop

0002b74c <__gnu_Unwind_Restore_VFP_D_16_to_31>:
   2b74c:	ecd0 0b20 	vldmia	r0, {d16-d31}
   2b750:	4770      	bx	lr
   2b752:	bf00      	nop

0002b754 <__gnu_Unwind_Save_VFP_D_16_to_31>:
   2b754:	ecc0 0b20 	vstmia	r0, {d16-d31}
   2b758:	4770      	bx	lr
   2b75a:	bf00      	nop

0002b75c <__gnu_Unwind_Restore_WMMXD>:
   2b75c:	ecf0 0102 	ldfe	f0, [r0], #8
   2b760:	ecf0 1102 	ldfe	f1, [r0], #8
   2b764:	ecf0 2102 	ldfe	f2, [r0], #8
   2b768:	ecf0 3102 	ldfe	f3, [r0], #8
   2b76c:	ecf0 4102 	ldfe	f4, [r0], #8
   2b770:	ecf0 5102 	ldfe	f5, [r0], #8
   2b774:	ecf0 6102 	ldfe	f6, [r0], #8
   2b778:	ecf0 7102 	ldfe	f7, [r0], #8
   2b77c:	ecf0 8102 	ldfp	f0, [r0], #8
   2b780:	ecf0 9102 	ldfp	f1, [r0], #8
   2b784:	ecf0 a102 	ldfp	f2, [r0], #8
   2b788:	ecf0 b102 	ldfp	f3, [r0], #8
   2b78c:	ecf0 c102 	ldfp	f4, [r0], #8
   2b790:	ecf0 d102 	ldfp	f5, [r0], #8
   2b794:	ecf0 e102 	ldfp	f6, [r0], #8
   2b798:	ecf0 f102 	ldfp	f7, [r0], #8
   2b79c:	4770      	bx	lr
   2b79e:	bf00      	nop

0002b7a0 <__gnu_Unwind_Save_WMMXD>:
   2b7a0:	ece0 0102 	stfe	f0, [r0], #8
   2b7a4:	ece0 1102 	stfe	f1, [r0], #8
   2b7a8:	ece0 2102 	stfe	f2, [r0], #8
   2b7ac:	ece0 3102 	stfe	f3, [r0], #8
   2b7b0:	ece0 4102 	stfe	f4, [r0], #8
   2b7b4:	ece0 5102 	stfe	f5, [r0], #8
   2b7b8:	ece0 6102 	stfe	f6, [r0], #8
   2b7bc:	ece0 7102 	stfe	f7, [r0], #8
   2b7c0:	ece0 8102 	stfp	f0, [r0], #8
   2b7c4:	ece0 9102 	stfp	f1, [r0], #8
   2b7c8:	ece0 a102 	stfp	f2, [r0], #8
   2b7cc:	ece0 b102 	stfp	f3, [r0], #8
   2b7d0:	ece0 c102 	stfp	f4, [r0], #8
   2b7d4:	ece0 d102 	stfp	f5, [r0], #8
   2b7d8:	ece0 e102 	stfp	f6, [r0], #8
   2b7dc:	ece0 f102 	stfp	f7, [r0], #8
   2b7e0:	4770      	bx	lr
   2b7e2:	bf00      	nop

0002b7e4 <__gnu_Unwind_Restore_WMMXC>:
   2b7e4:	fcb0 8101 	ldc2	1, cr8, [r0], #4
   2b7e8:	fcb0 9101 	ldc2	1, cr9, [r0], #4
   2b7ec:	fcb0 a101 	ldc2	1, cr10, [r0], #4
   2b7f0:	fcb0 b101 	ldc2	1, cr11, [r0], #4
   2b7f4:	4770      	bx	lr
   2b7f6:	bf00      	nop

0002b7f8 <__gnu_Unwind_Save_WMMXC>:
   2b7f8:	fca0 8101 	stc2	1, cr8, [r0], #4
   2b7fc:	fca0 9101 	stc2	1, cr9, [r0], #4
   2b800:	fca0 a101 	stc2	1, cr10, [r0], #4
   2b804:	fca0 b101 	stc2	1, cr11, [r0], #4
   2b808:	4770      	bx	lr
   2b80a:	bf00      	nop

0002b80c <_Unwind_RaiseException>:
   2b80c:	46ec      	mov	ip, sp
   2b80e:	b500      	push	{lr}
   2b810:	e92d 5000 	stmdb	sp!, {ip, lr}
   2b814:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
   2b818:	f04f 0300 	mov.w	r3, #0
   2b81c:	e92d 000c 	stmdb	sp!, {r2, r3}
   2b820:	a901      	add	r1, sp, #4
   2b822:	f7ff fbf1 	bl	2b008 <__gnu_Unwind_RaiseException>
   2b826:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
   2b82a:	b012      	add	sp, #72	; 0x48
   2b82c:	4770      	bx	lr
   2b82e:	bf00      	nop

0002b830 <_Unwind_Resume>:
   2b830:	46ec      	mov	ip, sp
   2b832:	b500      	push	{lr}
   2b834:	e92d 5000 	stmdb	sp!, {ip, lr}
   2b838:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
   2b83c:	f04f 0300 	mov.w	r3, #0
   2b840:	e92d 000c 	stmdb	sp!, {r2, r3}
   2b844:	a901      	add	r1, sp, #4
   2b846:	f7ff fc19 	bl	2b07c <__gnu_Unwind_Resume>
   2b84a:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
   2b84e:	b012      	add	sp, #72	; 0x48
   2b850:	4770      	bx	lr
   2b852:	bf00      	nop

0002b854 <_Unwind_Resume_or_Rethrow>:
   2b854:	46ec      	mov	ip, sp
   2b856:	b500      	push	{lr}
   2b858:	e92d 5000 	stmdb	sp!, {ip, lr}
   2b85c:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
   2b860:	f04f 0300 	mov.w	r3, #0
   2b864:	e92d 000c 	stmdb	sp!, {r2, r3}
   2b868:	a901      	add	r1, sp, #4
   2b86a:	f7ff fc29 	bl	2b0c0 <__gnu_Unwind_Resume_or_Rethrow>
   2b86e:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
   2b872:	b012      	add	sp, #72	; 0x48
   2b874:	4770      	bx	lr
   2b876:	bf00      	nop

0002b878 <_Unwind_ForcedUnwind>:
   2b878:	46ec      	mov	ip, sp
   2b87a:	b500      	push	{lr}
   2b87c:	e92d 5000 	stmdb	sp!, {ip, lr}
   2b880:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
   2b884:	f04f 0300 	mov.w	r3, #0
   2b888:	e92d 000c 	stmdb	sp!, {r2, r3}
   2b88c:	ab01      	add	r3, sp, #4
   2b88e:	f7ff fbeb 	bl	2b068 <__gnu_Unwind_ForcedUnwind>
   2b892:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
   2b896:	b012      	add	sp, #72	; 0x48
   2b898:	4770      	bx	lr
   2b89a:	bf00      	nop

0002b89c <_Unwind_Backtrace>:
   2b89c:	46ec      	mov	ip, sp
   2b89e:	b500      	push	{lr}
   2b8a0:	e92d 5000 	stmdb	sp!, {ip, lr}
   2b8a4:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
   2b8a8:	f04f 0300 	mov.w	r3, #0
   2b8ac:	e92d 000c 	stmdb	sp!, {r2, r3}
   2b8b0:	aa01      	add	r2, sp, #4
   2b8b2:	f7ff fc5d 	bl	2b170 <__gnu_Unwind_Backtrace>
   2b8b6:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
   2b8ba:	b012      	add	sp, #72	; 0x48
   2b8bc:	4770      	bx	lr
   2b8be:	bf00      	nop

0002b8c0 <next_unwind_byte>:
   2b8c0:	7a02      	ldrb	r2, [r0, #8]
   2b8c2:	b97a      	cbnz	r2, 2b8e4 <next_unwind_byte+0x24>
   2b8c4:	7a43      	ldrb	r3, [r0, #9]
   2b8c6:	b1a3      	cbz	r3, 2b8f2 <next_unwind_byte+0x32>
   2b8c8:	6842      	ldr	r2, [r0, #4]
   2b8ca:	3b01      	subs	r3, #1
   2b8cc:	b410      	push	{r4}
   2b8ce:	7243      	strb	r3, [r0, #9]
   2b8d0:	6813      	ldr	r3, [r2, #0]
   2b8d2:	2103      	movs	r1, #3
   2b8d4:	1d14      	adds	r4, r2, #4
   2b8d6:	7201      	strb	r1, [r0, #8]
   2b8d8:	021a      	lsls	r2, r3, #8
   2b8da:	6044      	str	r4, [r0, #4]
   2b8dc:	6002      	str	r2, [r0, #0]
   2b8de:	bc10      	pop	{r4}
   2b8e0:	0e18      	lsrs	r0, r3, #24
   2b8e2:	4770      	bx	lr
   2b8e4:	6803      	ldr	r3, [r0, #0]
   2b8e6:	3a01      	subs	r2, #1
   2b8e8:	7202      	strb	r2, [r0, #8]
   2b8ea:	021a      	lsls	r2, r3, #8
   2b8ec:	6002      	str	r2, [r0, #0]
   2b8ee:	0e18      	lsrs	r0, r3, #24
   2b8f0:	4770      	bx	lr
   2b8f2:	20b0      	movs	r0, #176	; 0xb0
   2b8f4:	4770      	bx	lr
   2b8f6:	bf00      	nop

0002b8f8 <_Unwind_GetGR.constprop.0>:
   2b8f8:	b500      	push	{lr}
   2b8fa:	b085      	sub	sp, #20
   2b8fc:	aa03      	add	r2, sp, #12
   2b8fe:	2300      	movs	r3, #0
   2b900:	9200      	str	r2, [sp, #0]
   2b902:	4619      	mov	r1, r3
   2b904:	220c      	movs	r2, #12
   2b906:	f7ff fbeb 	bl	2b0e0 <_Unwind_VRS_Get>
   2b90a:	9803      	ldr	r0, [sp, #12]
   2b90c:	b005      	add	sp, #20
   2b90e:	f85d fb04 	ldr.w	pc, [sp], #4
   2b912:	bf00      	nop

0002b914 <unwind_UCB_from_context>:
   2b914:	e7f0      	b.n	2b8f8 <_Unwind_GetGR.constprop.0>
   2b916:	bf00      	nop

0002b918 <__gnu_unwind_execute>:
   2b918:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2b91c:	4605      	mov	r5, r0
   2b91e:	b085      	sub	sp, #20
   2b920:	460e      	mov	r6, r1
   2b922:	f04f 0800 	mov.w	r8, #0
   2b926:	4630      	mov	r0, r6
   2b928:	f7ff ffca 	bl	2b8c0 <next_unwind_byte>
   2b92c:	28b0      	cmp	r0, #176	; 0xb0
   2b92e:	4604      	mov	r4, r0
   2b930:	f000 80b2 	beq.w	2ba98 <__gnu_unwind_execute+0x180>
   2b934:	0607      	lsls	r7, r0, #24
   2b936:	d520      	bpl.n	2b97a <__gnu_unwind_execute+0x62>
   2b938:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
   2b93c:	2b80      	cmp	r3, #128	; 0x80
   2b93e:	d04d      	beq.n	2b9dc <__gnu_unwind_execute+0xc4>
   2b940:	2b90      	cmp	r3, #144	; 0x90
   2b942:	d036      	beq.n	2b9b2 <__gnu_unwind_execute+0x9a>
   2b944:	2ba0      	cmp	r3, #160	; 0xa0
   2b946:	d060      	beq.n	2ba0a <__gnu_unwind_execute+0xf2>
   2b948:	2bb0      	cmp	r3, #176	; 0xb0
   2b94a:	d074      	beq.n	2ba36 <__gnu_unwind_execute+0x11e>
   2b94c:	2bc0      	cmp	r3, #192	; 0xc0
   2b94e:	f000 808b 	beq.w	2ba68 <__gnu_unwind_execute+0x150>
   2b952:	f000 03f8 	and.w	r3, r0, #248	; 0xf8
   2b956:	2bd0      	cmp	r3, #208	; 0xd0
   2b958:	d10b      	bne.n	2b972 <__gnu_unwind_execute+0x5a>
   2b95a:	f000 0207 	and.w	r2, r0, #7
   2b95e:	3201      	adds	r2, #1
   2b960:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
   2b964:	2305      	movs	r3, #5
   2b966:	2101      	movs	r1, #1
   2b968:	4628      	mov	r0, r5
   2b96a:	f7ff fd97 	bl	2b49c <_Unwind_VRS_Pop>
   2b96e:	2800      	cmp	r0, #0
   2b970:	d0d9      	beq.n	2b926 <__gnu_unwind_execute+0xe>
   2b972:	2009      	movs	r0, #9
   2b974:	b005      	add	sp, #20
   2b976:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2b97a:	f10d 090c 	add.w	r9, sp, #12
   2b97e:	2300      	movs	r3, #0
   2b980:	4619      	mov	r1, r3
   2b982:	0087      	lsls	r7, r0, #2
   2b984:	f8cd 9000 	str.w	r9, [sp]
   2b988:	220d      	movs	r2, #13
   2b98a:	4628      	mov	r0, r5
   2b98c:	f7ff fba8 	bl	2b0e0 <_Unwind_VRS_Get>
   2b990:	b2ff      	uxtb	r7, r7
   2b992:	9b03      	ldr	r3, [sp, #12]
   2b994:	f8cd 9000 	str.w	r9, [sp]
   2b998:	3704      	adds	r7, #4
   2b99a:	0660      	lsls	r0, r4, #25
   2b99c:	bf4c      	ite	mi
   2b99e:	1bdf      	submi	r7, r3, r7
   2b9a0:	18ff      	addpl	r7, r7, r3
   2b9a2:	2300      	movs	r3, #0
   2b9a4:	4619      	mov	r1, r3
   2b9a6:	220d      	movs	r2, #13
   2b9a8:	4628      	mov	r0, r5
   2b9aa:	9703      	str	r7, [sp, #12]
   2b9ac:	f7ff fbbc 	bl	2b128 <_Unwind_VRS_Set>
   2b9b0:	e7b9      	b.n	2b926 <__gnu_unwind_execute+0xe>
   2b9b2:	f000 030d 	and.w	r3, r0, #13
   2b9b6:	2b0d      	cmp	r3, #13
   2b9b8:	d0db      	beq.n	2b972 <__gnu_unwind_execute+0x5a>
   2b9ba:	af03      	add	r7, sp, #12
   2b9bc:	2300      	movs	r3, #0
   2b9be:	f000 020f 	and.w	r2, r0, #15
   2b9c2:	4619      	mov	r1, r3
   2b9c4:	9700      	str	r7, [sp, #0]
   2b9c6:	4628      	mov	r0, r5
   2b9c8:	f7ff fb8a 	bl	2b0e0 <_Unwind_VRS_Get>
   2b9cc:	2300      	movs	r3, #0
   2b9ce:	9700      	str	r7, [sp, #0]
   2b9d0:	4619      	mov	r1, r3
   2b9d2:	220d      	movs	r2, #13
   2b9d4:	4628      	mov	r0, r5
   2b9d6:	f7ff fba7 	bl	2b128 <_Unwind_VRS_Set>
   2b9da:	e7a4      	b.n	2b926 <__gnu_unwind_execute+0xe>
   2b9dc:	4630      	mov	r0, r6
   2b9de:	f7ff ff6f 	bl	2b8c0 <next_unwind_byte>
   2b9e2:	0224      	lsls	r4, r4, #8
   2b9e4:	4320      	orrs	r0, r4
   2b9e6:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
   2b9ea:	d0c2      	beq.n	2b972 <__gnu_unwind_execute+0x5a>
   2b9ec:	0104      	lsls	r4, r0, #4
   2b9ee:	2300      	movs	r3, #0
   2b9f0:	b2a2      	uxth	r2, r4
   2b9f2:	4619      	mov	r1, r3
   2b9f4:	4628      	mov	r0, r5
   2b9f6:	f7ff fd51 	bl	2b49c <_Unwind_VRS_Pop>
   2b9fa:	2800      	cmp	r0, #0
   2b9fc:	d1b9      	bne.n	2b972 <__gnu_unwind_execute+0x5a>
   2b9fe:	f414 4f00 	tst.w	r4, #32768	; 0x8000
   2ba02:	bf18      	it	ne
   2ba04:	f04f 0801 	movne.w	r8, #1
   2ba08:	e78d      	b.n	2b926 <__gnu_unwind_execute+0xe>
   2ba0a:	43c2      	mvns	r2, r0
   2ba0c:	f002 0307 	and.w	r3, r2, #7
   2ba10:	f44f 627f 	mov.w	r2, #4080	; 0xff0
   2ba14:	411a      	asrs	r2, r3
   2ba16:	0701      	lsls	r1, r0, #28
   2ba18:	f402 627f 	and.w	r2, r2, #4080	; 0xff0
   2ba1c:	f04f 0300 	mov.w	r3, #0
   2ba20:	bf48      	it	mi
   2ba22:	f442 4280 	orrmi.w	r2, r2, #16384	; 0x4000
   2ba26:	4619      	mov	r1, r3
   2ba28:	4628      	mov	r0, r5
   2ba2a:	f7ff fd37 	bl	2b49c <_Unwind_VRS_Pop>
   2ba2e:	2800      	cmp	r0, #0
   2ba30:	f43f af79 	beq.w	2b926 <__gnu_unwind_execute+0xe>
   2ba34:	e79d      	b.n	2b972 <__gnu_unwind_execute+0x5a>
   2ba36:	28b1      	cmp	r0, #177	; 0xb1
   2ba38:	d033      	beq.n	2baa2 <__gnu_unwind_execute+0x18a>
   2ba3a:	28b2      	cmp	r0, #178	; 0xb2
   2ba3c:	f000 808b 	beq.w	2bb56 <__gnu_unwind_execute+0x23e>
   2ba40:	28b3      	cmp	r0, #179	; 0xb3
   2ba42:	d039      	beq.n	2bab8 <__gnu_unwind_execute+0x1a0>
   2ba44:	f000 03fc 	and.w	r3, r0, #252	; 0xfc
   2ba48:	2bb4      	cmp	r3, #180	; 0xb4
   2ba4a:	d092      	beq.n	2b972 <__gnu_unwind_execute+0x5a>
   2ba4c:	f000 0207 	and.w	r2, r0, #7
   2ba50:	3201      	adds	r2, #1
   2ba52:	2301      	movs	r3, #1
   2ba54:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
   2ba58:	4619      	mov	r1, r3
   2ba5a:	4628      	mov	r0, r5
   2ba5c:	f7ff fd1e 	bl	2b49c <_Unwind_VRS_Pop>
   2ba60:	2800      	cmp	r0, #0
   2ba62:	f43f af60 	beq.w	2b926 <__gnu_unwind_execute+0xe>
   2ba66:	e784      	b.n	2b972 <__gnu_unwind_execute+0x5a>
   2ba68:	28c6      	cmp	r0, #198	; 0xc6
   2ba6a:	d042      	beq.n	2baf2 <__gnu_unwind_execute+0x1da>
   2ba6c:	28c7      	cmp	r0, #199	; 0xc7
   2ba6e:	d04c      	beq.n	2bb0a <__gnu_unwind_execute+0x1f2>
   2ba70:	f000 03f8 	and.w	r3, r0, #248	; 0xf8
   2ba74:	2bc0      	cmp	r3, #192	; 0xc0
   2ba76:	d05b      	beq.n	2bb30 <__gnu_unwind_execute+0x218>
   2ba78:	28c8      	cmp	r0, #200	; 0xc8
   2ba7a:	d060      	beq.n	2bb3e <__gnu_unwind_execute+0x226>
   2ba7c:	28c9      	cmp	r0, #201	; 0xc9
   2ba7e:	f47f af78 	bne.w	2b972 <__gnu_unwind_execute+0x5a>
   2ba82:	4630      	mov	r0, r6
   2ba84:	f7ff ff1c 	bl	2b8c0 <next_unwind_byte>
   2ba88:	0302      	lsls	r2, r0, #12
   2ba8a:	f000 000f 	and.w	r0, r0, #15
   2ba8e:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
   2ba92:	3001      	adds	r0, #1
   2ba94:	4302      	orrs	r2, r0
   2ba96:	e765      	b.n	2b964 <__gnu_unwind_execute+0x4c>
   2ba98:	f1b8 0f00 	cmp.w	r8, #0
   2ba9c:	d018      	beq.n	2bad0 <__gnu_unwind_execute+0x1b8>
   2ba9e:	2000      	movs	r0, #0
   2baa0:	e768      	b.n	2b974 <__gnu_unwind_execute+0x5c>
   2baa2:	4630      	mov	r0, r6
   2baa4:	f7ff ff0c 	bl	2b8c0 <next_unwind_byte>
   2baa8:	4602      	mov	r2, r0
   2baaa:	2800      	cmp	r0, #0
   2baac:	f43f af61 	beq.w	2b972 <__gnu_unwind_execute+0x5a>
   2bab0:	f010 03f0 	ands.w	r3, r0, #240	; 0xf0
   2bab4:	d0d0      	beq.n	2ba58 <__gnu_unwind_execute+0x140>
   2bab6:	e75c      	b.n	2b972 <__gnu_unwind_execute+0x5a>
   2bab8:	4630      	mov	r0, r6
   2baba:	f7ff ff01 	bl	2b8c0 <next_unwind_byte>
   2babe:	0301      	lsls	r1, r0, #12
   2bac0:	f000 000f 	and.w	r0, r0, #15
   2bac4:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
   2bac8:	1c42      	adds	r2, r0, #1
   2baca:	2301      	movs	r3, #1
   2bacc:	430a      	orrs	r2, r1
   2bace:	e7c3      	b.n	2ba58 <__gnu_unwind_execute+0x140>
   2bad0:	ac03      	add	r4, sp, #12
   2bad2:	4643      	mov	r3, r8
   2bad4:	220e      	movs	r2, #14
   2bad6:	4641      	mov	r1, r8
   2bad8:	9400      	str	r4, [sp, #0]
   2bada:	4628      	mov	r0, r5
   2badc:	f7ff fb00 	bl	2b0e0 <_Unwind_VRS_Get>
   2bae0:	9400      	str	r4, [sp, #0]
   2bae2:	4628      	mov	r0, r5
   2bae4:	4643      	mov	r3, r8
   2bae6:	220f      	movs	r2, #15
   2bae8:	4641      	mov	r1, r8
   2baea:	f7ff fb1d 	bl	2b128 <_Unwind_VRS_Set>
   2baee:	4640      	mov	r0, r8
   2baf0:	e740      	b.n	2b974 <__gnu_unwind_execute+0x5c>
   2baf2:	4630      	mov	r0, r6
   2baf4:	f7ff fee4 	bl	2b8c0 <next_unwind_byte>
   2baf8:	0301      	lsls	r1, r0, #12
   2bafa:	f000 000f 	and.w	r0, r0, #15
   2bafe:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
   2bb02:	1c42      	adds	r2, r0, #1
   2bb04:	2303      	movs	r3, #3
   2bb06:	430a      	orrs	r2, r1
   2bb08:	e7a6      	b.n	2ba58 <__gnu_unwind_execute+0x140>
   2bb0a:	4630      	mov	r0, r6
   2bb0c:	f7ff fed8 	bl	2b8c0 <next_unwind_byte>
   2bb10:	4602      	mov	r2, r0
   2bb12:	2800      	cmp	r0, #0
   2bb14:	f43f af2d 	beq.w	2b972 <__gnu_unwind_execute+0x5a>
   2bb18:	f010 03f0 	ands.w	r3, r0, #240	; 0xf0
   2bb1c:	f47f af29 	bne.w	2b972 <__gnu_unwind_execute+0x5a>
   2bb20:	2104      	movs	r1, #4
   2bb22:	4628      	mov	r0, r5
   2bb24:	f7ff fcba 	bl	2b49c <_Unwind_VRS_Pop>
   2bb28:	2800      	cmp	r0, #0
   2bb2a:	f43f aefc 	beq.w	2b926 <__gnu_unwind_execute+0xe>
   2bb2e:	e720      	b.n	2b972 <__gnu_unwind_execute+0x5a>
   2bb30:	f000 020f 	and.w	r2, r0, #15
   2bb34:	3201      	adds	r2, #1
   2bb36:	2303      	movs	r3, #3
   2bb38:	f442 2220 	orr.w	r2, r2, #655360	; 0xa0000
   2bb3c:	e78c      	b.n	2ba58 <__gnu_unwind_execute+0x140>
   2bb3e:	4630      	mov	r0, r6
   2bb40:	f7ff febe 	bl	2b8c0 <next_unwind_byte>
   2bb44:	f000 02f0 	and.w	r2, r0, #240	; 0xf0
   2bb48:	f000 030f 	and.w	r3, r0, #15
   2bb4c:	3210      	adds	r2, #16
   2bb4e:	3301      	adds	r3, #1
   2bb50:	ea43 3202 	orr.w	r2, r3, r2, lsl #12
   2bb54:	e706      	b.n	2b964 <__gnu_unwind_execute+0x4c>
   2bb56:	2300      	movs	r3, #0
   2bb58:	f10d 090c 	add.w	r9, sp, #12
   2bb5c:	220d      	movs	r2, #13
   2bb5e:	4619      	mov	r1, r3
   2bb60:	f8cd 9000 	str.w	r9, [sp]
   2bb64:	4628      	mov	r0, r5
   2bb66:	f7ff fabb 	bl	2b0e0 <_Unwind_VRS_Get>
   2bb6a:	4630      	mov	r0, r6
   2bb6c:	f7ff fea8 	bl	2b8c0 <next_unwind_byte>
   2bb70:	0602      	lsls	r2, r0, #24
   2bb72:	f04f 0702 	mov.w	r7, #2
   2bb76:	d50c      	bpl.n	2bb92 <__gnu_unwind_execute+0x27a>
   2bb78:	9b03      	ldr	r3, [sp, #12]
   2bb7a:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   2bb7e:	40b8      	lsls	r0, r7
   2bb80:	4403      	add	r3, r0
   2bb82:	4630      	mov	r0, r6
   2bb84:	9303      	str	r3, [sp, #12]
   2bb86:	f7ff fe9b 	bl	2b8c0 <next_unwind_byte>
   2bb8a:	0603      	lsls	r3, r0, #24
   2bb8c:	f107 0707 	add.w	r7, r7, #7
   2bb90:	d4f2      	bmi.n	2bb78 <__gnu_unwind_execute+0x260>
   2bb92:	9b03      	ldr	r3, [sp, #12]
   2bb94:	f8cd 9000 	str.w	r9, [sp]
   2bb98:	f000 047f 	and.w	r4, r0, #127	; 0x7f
   2bb9c:	f503 7201 	add.w	r2, r3, #516	; 0x204
   2bba0:	40bc      	lsls	r4, r7
   2bba2:	2300      	movs	r3, #0
   2bba4:	4414      	add	r4, r2
   2bba6:	4619      	mov	r1, r3
   2bba8:	220d      	movs	r2, #13
   2bbaa:	4628      	mov	r0, r5
   2bbac:	9403      	str	r4, [sp, #12]
   2bbae:	f7ff fabb 	bl	2b128 <_Unwind_VRS_Set>
   2bbb2:	e6b8      	b.n	2b926 <__gnu_unwind_execute+0xe>

0002bbb4 <__gnu_unwind_frame>:
   2bbb4:	b510      	push	{r4, lr}
   2bbb6:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
   2bbb8:	b084      	sub	sp, #16
   2bbba:	6853      	ldr	r3, [r2, #4]
   2bbbc:	2403      	movs	r4, #3
   2bbbe:	f88d 400c 	strb.w	r4, [sp, #12]
   2bbc2:	021b      	lsls	r3, r3, #8
   2bbc4:	f102 0408 	add.w	r4, r2, #8
   2bbc8:	4608      	mov	r0, r1
   2bbca:	79d2      	ldrb	r2, [r2, #7]
   2bbcc:	9301      	str	r3, [sp, #4]
   2bbce:	a901      	add	r1, sp, #4
   2bbd0:	9402      	str	r4, [sp, #8]
   2bbd2:	f88d 200d 	strb.w	r2, [sp, #13]
   2bbd6:	f7ff fe9f 	bl	2b918 <__gnu_unwind_execute>
   2bbda:	b004      	add	sp, #16
   2bbdc:	bd10      	pop	{r4, pc}
   2bbde:	bf00      	nop

0002bbe0 <_Unwind_GetRegionStart>:
   2bbe0:	b508      	push	{r3, lr}
   2bbe2:	f7ff fe97 	bl	2b914 <unwind_UCB_from_context>
   2bbe6:	6c80      	ldr	r0, [r0, #72]	; 0x48
   2bbe8:	bd08      	pop	{r3, pc}
   2bbea:	bf00      	nop

0002bbec <_Unwind_GetLanguageSpecificData>:
   2bbec:	b508      	push	{r3, lr}
   2bbee:	f7ff fe91 	bl	2b914 <unwind_UCB_from_context>
   2bbf2:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
   2bbf4:	79c3      	ldrb	r3, [r0, #7]
   2bbf6:	3302      	adds	r3, #2
   2bbf8:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   2bbfc:	bd08      	pop	{r3, pc}
   2bbfe:	bf00      	nop

0002bc00 <abort>:
   2bc00:	b508      	push	{r3, lr}
   2bc02:	2006      	movs	r0, #6
   2bc04:	f000 f82c 	bl	2bc60 <raise>
   2bc08:	2001      	movs	r0, #1
   2bc0a:	f7fe fc97 	bl	2a53c <_exit>

0002bc0e <_raise_r>:
   2bc0e:	291f      	cmp	r1, #31
   2bc10:	b538      	push	{r3, r4, r5, lr}
   2bc12:	4604      	mov	r4, r0
   2bc14:	460d      	mov	r5, r1
   2bc16:	d904      	bls.n	2bc22 <_raise_r+0x14>
   2bc18:	2316      	movs	r3, #22
   2bc1a:	6003      	str	r3, [r0, #0]
   2bc1c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2bc20:	bd38      	pop	{r3, r4, r5, pc}
   2bc22:	6c42      	ldr	r2, [r0, #68]	; 0x44
   2bc24:	b112      	cbz	r2, 2bc2c <_raise_r+0x1e>
   2bc26:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   2bc2a:	b94b      	cbnz	r3, 2bc40 <_raise_r+0x32>
   2bc2c:	4620      	mov	r0, r4
   2bc2e:	f000 f831 	bl	2bc94 <_getpid_r>
   2bc32:	462a      	mov	r2, r5
   2bc34:	4601      	mov	r1, r0
   2bc36:	4620      	mov	r0, r4
   2bc38:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2bc3c:	f000 b818 	b.w	2bc70 <_kill_r>
   2bc40:	2b01      	cmp	r3, #1
   2bc42:	d00a      	beq.n	2bc5a <_raise_r+0x4c>
   2bc44:	1c59      	adds	r1, r3, #1
   2bc46:	d103      	bne.n	2bc50 <_raise_r+0x42>
   2bc48:	2316      	movs	r3, #22
   2bc4a:	6003      	str	r3, [r0, #0]
   2bc4c:	2001      	movs	r0, #1
   2bc4e:	e7e7      	b.n	2bc20 <_raise_r+0x12>
   2bc50:	2400      	movs	r4, #0
   2bc52:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
   2bc56:	4628      	mov	r0, r5
   2bc58:	4798      	blx	r3
   2bc5a:	2000      	movs	r0, #0
   2bc5c:	e7e0      	b.n	2bc20 <_raise_r+0x12>
	...

0002bc60 <raise>:
   2bc60:	4b02      	ldr	r3, [pc, #8]	; (2bc6c <raise+0xc>)
   2bc62:	4601      	mov	r1, r0
   2bc64:	6818      	ldr	r0, [r3, #0]
   2bc66:	f7ff bfd2 	b.w	2bc0e <_raise_r>
   2bc6a:	bf00      	nop
   2bc6c:	20002038 	.word	0x20002038

0002bc70 <_kill_r>:
   2bc70:	b538      	push	{r3, r4, r5, lr}
   2bc72:	4d07      	ldr	r5, [pc, #28]	; (2bc90 <_kill_r+0x20>)
   2bc74:	2300      	movs	r3, #0
   2bc76:	4604      	mov	r4, r0
   2bc78:	4608      	mov	r0, r1
   2bc7a:	4611      	mov	r1, r2
   2bc7c:	602b      	str	r3, [r5, #0]
   2bc7e:	f000 f813 	bl	2bca8 <_kill>
   2bc82:	1c43      	adds	r3, r0, #1
   2bc84:	d102      	bne.n	2bc8c <_kill_r+0x1c>
   2bc86:	682b      	ldr	r3, [r5, #0]
   2bc88:	b103      	cbz	r3, 2bc8c <_kill_r+0x1c>
   2bc8a:	6023      	str	r3, [r4, #0]
   2bc8c:	bd38      	pop	{r3, r4, r5, pc}
   2bc8e:	bf00      	nop
   2bc90:	20002338 	.word	0x20002338

0002bc94 <_getpid_r>:
   2bc94:	f000 b800 	b.w	2bc98 <_getpid>

0002bc98 <_getpid>:
   2bc98:	4b02      	ldr	r3, [pc, #8]	; (2bca4 <_getpid+0xc>)
   2bc9a:	2258      	movs	r2, #88	; 0x58
   2bc9c:	601a      	str	r2, [r3, #0]
   2bc9e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2bca2:	4770      	bx	lr
   2bca4:	20002338 	.word	0x20002338

0002bca8 <_kill>:
   2bca8:	4b02      	ldr	r3, [pc, #8]	; (2bcb4 <_kill+0xc>)
   2bcaa:	2258      	movs	r2, #88	; 0x58
   2bcac:	601a      	str	r2, [r3, #0]
   2bcae:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2bcb2:	4770      	bx	lr
   2bcb4:	20002338 	.word	0x20002338

0002bcb8 <_init>:
   2bcb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2bcba:	bf00      	nop
   2bcbc:	bcf8      	pop	{r3, r4, r5, r6, r7}
   2bcbe:	bc08      	pop	{r3}
   2bcc0:	469e      	mov	lr, r3
   2bcc2:	4770      	bx	lr

0002bcc4 <_fini>:
   2bcc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2bcc6:	bf00      	nop
   2bcc8:	bcf8      	pop	{r3, r4, r5, r6, r7}
   2bcca:	bc08      	pop	{r3}
   2bccc:	469e      	mov	lr, r3
   2bcce:	4770      	bx	lr
   2bcd0:	00060001 	.word	0x00060001

0002bcd4 <m_app_timer_sortlist>:
   2bcd4:	00000000 200020c4 0002734d              ..... . Ms..

0002bce0 <delay_machine_code.8746>:
   2bce0:	d8fd3803 00004770                       .8..pG..

0002bce8 <pwr_mgmt_data>:
   2bce8:	0002bdc4 0002bdc4 00000004 614e6f4e     ............NoNa
   2bcf8:	0000656d 252e6425 25204675 00000073     me..%d.%uF %s...

0002bd08 <SD_TX_LEVELS>:
   2bd08:	f0ecd800 00fcf8f4 05040302 00080706     ................
	...

0002bd20 <nrfx_coredep_delay_us::delay_machine_code>:
   2bd20:	d8fd3803 00004770 07000001              .8..pG......

0002bd2c <sdh_req_observers>:
   2bd2c:	0002bddc 0002bddc 00000008              ............

0002bd38 <sdh_stack_observers>:
   2bd38:	0002bdcc 0002bddc 00000008              ............

0002bd44 <sdh_state_observers>:
   2bd44:	0002bdc4 0002bdcc 00000008              ............

0002bd50 <sdh_ble_observers>:
   2bd50:	0002bdb4 0002bdc4 00000008              ............

0002bd5c <sdh_soc_observers>:
   2bd5c:	0002bda4 0002bdb4 00000008              ............

0002bd68 <_global_impure_ptr>:
   2bd68:	2000203c 2b302d23 6c680020 6665004c     < . #-0+ .hlL.ef
   2bd78:	47464567 32313000 36353433 41393837     gEFG.0123456789A
   2bd88:	45444342 31300046 35343332 39383736     BCDEF.0123456789
   2bd98:	64636261 00006665                       abcdef..

0002bda0 <__EH_FRAME_BEGIN__>:
   2bda0:	00000000                                ....
